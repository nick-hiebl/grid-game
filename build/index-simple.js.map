{
  "version": 3,
  "sources": ["../js/constants/ScreenConstants.ts", "../js/math/Common.ts", "../js/math/Vector.ts", "../js/math/Shapes.ts", "../js/constants/Image.ts", "../js/level/BlockTypes.ts", "../js/level/entity/Entity.ts", "../js/level/interactibles/Interactible.ts", "../js/level/interactibles/DoorInteractible.ts", "../js/puzzle-manager/constants.ts", "../js/puzzle-manager/PuzzleSpaceManager.ts", "../js/puzzle-manager/Puzzle.ts", "../js/puzzle-manager/validation/PuzzleValidation.ts", "../js/puzzle-manager/validation/CellValidation.ts", "../js/puzzle-manager/validation/EdgeValidation.ts", "../js/puzzle-manager/validation/GlobalValidation.ts", "../js/puzzle-manager/validation/PuzzleValidatorFactory.ts", "../js/puzzle-manager/PuzzleFactory.ts", "../js/puzzle-manager/PuzzleManager.ts", "../js/level/interactibles/PortalInteractible.ts", "../js/level/LevelEvent.ts", "../js/level/interactibles/PuzzleInteractible.ts", "../js/level/interactibles/SwitchInteractible.ts", "../js/level/interactibles/TrapdoorInteractible.ts", "../js/utils/Color.ts", "../js/level/entity/CoverEntity.ts", "../js/level/ExitTrigger.ts", "../js/constants/Keys.ts", "../js/InputManager.ts", "../js/level/background/BackgroundArtist.ts", "../js/level/Level.ts", "../js/level/RectPool.ts", "../js/level/Player.ts", "../js/level/LevelFactory.ts", "../js/level/entity/DecorationEntity.ts", "../js/level/interactibles/NodeInteractible.ts", "../js/level/DataLoader.ts", "../js/AppCore.ts", "../js/game-modes/utils.ts", "../js/game-modes/PuzzleMode.ts", "../js/apps/SimpleGameManager.ts", "../js/Canvas.ts", "../js/apps/SimpleScreen.ts", "../js/apps/SimpleApp.ts"],
  "sourcesContent": ["export const CANVAS_WIDTH = 1280;\nexport const CANVAS_HEIGHT = 720;\n\nexport const HORIZONTAL_TILES = 32;\nexport const VERTICAL_TILES = 18;\n\nexport const PIXELS_PER_TILE = 10;\n\nexport const PIXEL_WIDTH = CANVAS_WIDTH / HORIZONTAL_TILES / PIXELS_PER_TILE;\n\nexport const IS_MOBILE =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  );\n\nexport const ON_SCREEN_CANVAS_WIDTH = 1280;\nexport const ON_SCREEN_CANVAS_HEIGHT = 720;\n\nexport const SQUARE_CANVAS_SIZE = 720;\n\nexport const UI_CANVAS_WIDTH = ON_SCREEN_CANVAS_WIDTH;\nexport const UI_CANVAS_HEIGHT = ON_SCREEN_CANVAS_HEIGHT;\n\nexport const UI_PIXEL_WIDTH = 3;\n", "/**\n * Clamps a parameter between a low and high bound.\n * @param {number} x The number to be clamped\n * @param {number} low The lowest value that could be returned\n * @param {number} high The highest value that could be returned\n */\nexport const clamp = (x: number, low: number, high: number): number => {\n  return Math.min(high, Math.max(x, low));\n};\n\nexport const sign = (x: number): number => {\n  if (x > 0) {\n    return 1;\n  } else if (x === 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n};\n", "export class Vector {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n\n    return this;\n  }\n\n  subtract(vector: Vector) {\n    this.x -= vector.x;\n    this.y -= vector.y;\n  }\n\n  multiply(factor: number) {\n    this.x *= factor;\n    this.y *= factor;\n\n    return this;\n  }\n\n  copy() {\n    return new Vector(this.x, this.y);\n  }\n\n  setFrom(otherVector: Vector) {\n    this.x = otherVector.x;\n    this.y = otherVector.y;\n  }\n\n  get magnitude(): number {\n    return Math.hypot(this.x, this.y);\n  }\n\n  static add(a: Vector, b: Vector) {\n    return new Vector(a.x + b.x, a.y + b.y);\n  }\n\n  static diff(a: Vector, b: Vector) {\n    return new Vector(a.x - b.x, a.y - b.y);\n  }\n\n  static scale(vector: Vector, factor: number) {\n    return new Vector(vector.x * factor, vector.y * factor);\n  }\n\n  static sqrDist(a: Vector, b: Vector): number {\n    const xDiff = a.x - b.x;\n    const yDiff = a.y - b.y;\n    return xDiff * xDiff + yDiff * yDiff;\n  }\n\n  /**\n   * This is not actually manhattan distance. Consider refactoring.\n   */\n  static manhattanDist(a: Vector, b: Vector) {\n    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n  }\n\n  static dist(a: Vector, b: Vector) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  static lerp(v1: Vector, v2: Vector, t: number) {\n    return new Vector(v1.x * (1 - t) + v2.x * t, v1.y * (1 - t) + v2.y * t);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { clamp, sign } from \"./Common\";\nimport { Vector } from \"./Vector\";\n\nexport class Circle {\n  position: Vector;\n  radius: number;\n\n  constructor(position: Vector, radius: number) {\n    this.position = position;\n    this.radius = radius;\n  }\n\n  /**\n   * Check if another circle intersects with this circle\n   * @param {Circle} otherCircle The circle to check intersection with\n   */\n  intersectsCircle(otherCircle: Circle) {\n    const radiusSum = this.radius + otherCircle.radius;\n    return (\n      Vector.sqrDist(this.position, otherCircle.position) <\n      radiusSum * radiusSum\n    );\n  }\n\n  /**\n   * Check if a point intersects with this circle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsVector(point: Vector) {\n    return Vector.sqrDist(this.position, point) < this.radius * this.radius;\n  }\n\n  /**\n   * Check if a rectangle intersects with this circle.\n   * @param {Rectangle} rectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(rectangle: Rectangle) {\n    // Find the co-ordinates of the closest point in the rectangle to the circle center.\n    const closestX = clamp(this.position.x, rectangle.x1, rectangle.x2);\n    const closestY = clamp(this.position.y, rectangle.y1, rectangle.y2);\n\n    // Find if the closest point in the rectangle overlaps with the circle.\n    return this.intersectsVector(new Vector(closestX, closestY));\n  }\n\n  /**\n   * Determine if this circle is exactly kissing a rectangle below.\n   * @param {Rectangle} rectangle The rectangle to check for a kiss with\n   */\n  isKissingBelow(rectangle: Rectangle) {\n    return (\n      this.position.y + this.radius === rectangle.y1 &&\n      rectangle.x1 <= this.position.x &&\n      this.position.x <= rectangle.x2\n    );\n  }\n\n  /**\n   * Draw this circle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas) {\n    canvas.fillEllipse(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      this.radius\n    );\n  }\n}\n\nexport class Rectangle {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /**\n   * Check if a point intersects with this rectangle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsPoint(point: Vector) {\n    return (\n      this.x1 <= point.x &&\n      point.x <= this.x2 &&\n      this.y1 <= point.y &&\n      point.y <= this.y2\n    );\n  }\n\n  get width() {\n    return this.x2 - this.x1;\n  }\n\n  get height() {\n    return this.y2 - this.y1;\n  }\n\n  get midpoint() {\n    return new Vector((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n  }\n\n  xInRange(x: number): boolean {\n    return this.x1 <= x && x < this.x2;\n  }\n\n  yInRange(y: number): boolean {\n    return this.y1 <= y && y < this.y2;\n  }\n\n  /**\n   * Check if another rectangle intersects with this rectangle.\n   * @param {Rectangle} otherRectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(otherRectangle: Rectangle) {\n    return (\n      otherRectangle.x1 <= this.x2 &&\n      this.x1 <= otherRectangle.x2 &&\n      otherRectangle.y1 <= this.y2 &&\n      this.y1 <= otherRectangle.y2\n    );\n  }\n\n  /**\n   * Compute the smallest vector in the reverse direction to movement to\n   * uncollide with a given rectangle.\n   * @param {Circle} circle\n   */\n  uncollideCircle(circle: Circle) {\n    const closestX = clamp(circle.position.x, this.x1, this.x2);\n    const closestY = clamp(circle.position.y, this.y1, this.y2);\n\n    const p0 = new Vector(closestX, closestY);\n    const pToCenter = Vector.diff(circle.position, p0);\n\n    const distFromCenter = pToCenter.magnitude || 1;\n\n    if (distFromCenter >= circle.radius) {\n      const circleDistToMyCenter = Vector.diff(circle.position, this.midpoint);\n      const horizontalDistance =\n        this.width / 2 - Math.abs(circleDistToMyCenter.x);\n      const verticalDistance =\n        this.height / 2 - Math.abs(circleDistToMyCenter.y);\n\n      // Shortest way out is horizontally\n      if (horizontalDistance < verticalDistance) {\n        return new Vector(\n          (horizontalDistance + circle.radius) * sign(circleDistToMyCenter.x),\n          0\n        );\n      } else {\n        return new Vector(\n          0,\n          (verticalDistance + circle.radius) * sign(circleDistToMyCenter.y)\n        );\n      }\n    }\n\n    return Vector.scale(\n      pToCenter,\n      (circle.radius - distFromCenter) / distFromCenter\n    );\n  }\n\n  /**\n   * Draw this rectangle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas, outset = 0) {\n    canvas.fillRect(\n      this.x1 - outset,\n      this.y1 - outset,\n      this.width + outset * 2,\n      this.height + outset * 2\n    );\n  }\n\n  stroke(canvas: Canvas, inset = 0) {\n    canvas.strokeRectInset(this.x1, this.y1, this.width, this.height, inset);\n  }\n\n  inset(insetBy: number) {\n    return new Rectangle(\n      this.x1 + insetBy,\n      this.y1 + insetBy,\n      this.x2 - insetBy,\n      this.y2 - insetBy\n    );\n  }\n\n  static widthForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x, y, x + width, y + height);\n  }\n\n  static centerForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x - width, y - height, x + width, y + height);\n  }\n\n  static aroundPoint(point: Vector, halfWidth: number, halfHeight: number) {\n    return new Rectangle(\n      point.x - halfWidth,\n      point.y - halfHeight,\n      point.x + halfWidth,\n      point.y + halfHeight\n    );\n  }\n\n  // Creates a rectangle that overlaps all of the provided ones\n  static merged(rectangles: Rectangle[]) {\n    const [x1, y1, x2, y2] = rectangles.reduce<\n      [number, number, number, number]\n    >(\n      ([x1, y1, x2, y2], rect) => [\n        Math.min(rect.x1, x1),\n        Math.min(rect.y1, y1),\n        Math.max(rect.x2, x2),\n        Math.max(rect.y2, y2),\n      ],\n      [Infinity, Infinity, -Infinity, -Infinity]\n    );\n\n    return new Rectangle(x1, y1, x2, y2);\n  }\n}\n", "export const TileImage = new Image();\nTileImage.src = \"/img/tileset.png\";\n\nexport const EntityImage = new Image();\nEntityImage.src = \"/img/entity-set.png\";\n\nexport const DecorationImage = new Image();\nDecorationImage.src = \"/img/decoration.png\";\n", "export enum BlockEnum {\n  SOLID = 1,\n  LEDGE = 2,\n  VENT = 3,\n  LADDER = 4,\n}\n\nexport const BlockType = {\n  isSolid: (blockType?: BlockEnum) => {\n    return blockType === BlockEnum.SOLID;\n  },\n  isGrounding: (blockType?: BlockEnum) => {\n    return blockType === BlockEnum.LEDGE || BlockType.isSolid(blockType);\n  },\n};\n", "import { Canvas } from \"../../Canvas\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nexport class Entity {\n  id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  onStart(_level: Level) {\n    // Do nothing\n  }\n\n  onAwaken() {\n    // Do nothing\n  }\n\n  update(_player: Player, _deltaTime: number, _level: Level) {\n    // Do nothing\n  }\n\n  draw(_screenManager: ScreenManager) {\n    // Do nothing\n  }\n\n  drawForMap(_canvas: Canvas) {\n    // Do nothing\n  }\n\n  drawAsMapIcon(_canvas: Canvas, _level: Level) {\n    // Do nothing\n  }\n}\n", "import { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Entity } from \"../entity/Entity\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\nimport { LevelEvent } from \"../LevelEvent\";\n\nconst AREA_DEBUG = false;\n\nexport class Interactible extends Entity {\n  position: Vector;\n  triggerArea: Rectangle | undefined;\n\n  prerequisites: string[];\n  prereqsActive: boolean;\n  prereqEntities: Interactible[];\n\n  isEnabled: boolean;\n  isAreaActive: boolean;\n\n  connectionPoint: Vector;\n  outputPoint: Vector;\n\n  showAsMapIcon: boolean;\n\n  constructor(\n    id: string,\n    position: Vector,\n    triggerArea: Rectangle | undefined,\n    prerequisites: string[] = []\n  ) {\n    super(id);\n\n    this.position = position;\n    this.triggerArea = triggerArea;\n\n    this.prerequisites = prerequisites;\n    this.prereqsActive = prerequisites.length === 0;\n    this.prereqEntities = [];\n\n    this.isEnabled = false;\n\n    this.isAreaActive = false;\n\n    this.connectionPoint = this.position;\n    this.outputPoint = this.position;\n\n    this.showAsMapIcon = false;\n  }\n\n  onStart(level: Level) {\n    this.findPrerequisites(level);\n  }\n\n  onAwaken() {\n    // Do nothing\n  }\n\n  findPrerequisites(level: Level): Interactible[] {\n    if (this.prereqEntities.length === this.prerequisites.length) {\n      return this.prereqEntities;\n    }\n\n    this.prereqEntities = level.interactibles.filter((i) =>\n      this.prerequisites.includes(i.id)\n    );\n\n    return this.prereqEntities;\n  }\n\n  update(player: Player, _deltaTime: number, _level: Level) {\n    this.prereqsActive = this.prereqEntities.every((i) => i.isEnabled);\n    this.isAreaActive = !!(\n      this.prereqsActive && this.triggerArea?.intersectsPoint(player.position)\n    );\n  }\n\n  /**\n   * Draw the element on the canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(screenManager: ScreenManager) {\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (AREA_DEBUG) {\n      canvas.setColorRGB(255, 255, 255);\n      canvas.setLineWidth(0.1);\n      canvas.setLineDash([0.2, 0.2]);\n      this.triggerArea?.stroke(canvas);\n    }\n\n    screenManager.behindGroundCanvas.setLineWidth(0.2);\n    for (const prereq of this.prereqEntities) {\n      screenManager.behindGroundCanvas.setColor(\n        prereq.isEnabled ? \"white\" : \"black\"\n      );\n      const xDiff = Vector.manhattanDist(\n        prereq.outputPoint,\n        this.connectionPoint\n      );\n      const mid = Vector.lerp(prereq.outputPoint, this.connectionPoint, 0.5);\n      const control = Vector.add(mid, new Vector(0, xDiff * 0.3));\n      screenManager.behindGroundCanvas.drawQuadratic(\n        prereq.outputPoint.x,\n        prereq.outputPoint.y,\n        this.connectionPoint.x,\n        this.connectionPoint.y,\n        control.x,\n        control.y\n      );\n    }\n  }\n\n  clickedOnMap(): LevelEvent | undefined | void {\n    // Maybe return an event\n  }\n\n  onInteract(): LevelEvent | undefined | void {\n    // Maybe return an event\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { EntityImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { BlockEnum } from \"../BlockTypes\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nconst OPEN_CLOSE_DURATION = 0.8;\n\nexport class DoorInteractible extends Interactible {\n  headCollider: Rectangle;\n  doorCollider: Rectangle;\n\n  fullHeight: number;\n\n  constructor(\n    id: string,\n    position: Vector,\n    prerequisites: string[],\n    height = 4\n  ) {\n    super(id, position, undefined, prerequisites);\n\n    this.connectionPoint = Vector.add(position, new Vector(0, -1.8));\n\n    this.headCollider = Rectangle.centerForm(\n      this.position.x,\n      this.position.y - 1.8,\n      0.6,\n      0.4\n    );\n    this.doorCollider = Rectangle.widthForm(\n      this.position.x - 0.5,\n      this.position.y - 2,\n      1,\n      height\n    );\n\n    this.fullHeight = height;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n\n    level.addWithoutDuplicate({\n      type: BlockEnum.SOLID,\n      rect: this.headCollider,\n    });\n    level.addWithoutDuplicate({\n      type: BlockEnum.SOLID,\n      rect: this.doorCollider,\n    });\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const motion =\n      ((this.fullHeight * deltaTime) / OPEN_CLOSE_DURATION) *\n      (this.prereqsActive ? -1 : 1);\n\n    this.doorCollider.y2 = clamp(\n      this.doorCollider.y2 + motion,\n      this.doorCollider.y1,\n      this.doorCollider.y1 + this.fullHeight\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const h = this.doorCollider.height;\n    if (h > 0) {\n      canvas.setColor(\"black\");\n      canvas.fillRect(this.position.x - 0.5, this.position.y - 2, 1, h);\n\n      canvas.drawImage(\n        EntityImage,\n        120,\n        Math.max(40 - 10 * h, 20) - 10,\n        40,\n        Math.min(10 * h, 20),\n        this.position.x - 2,\n        this.position.y - 2 + Math.max(h - 2, 0),\n        4,\n        Math.min(h, 2)\n      );\n    }\n\n    canvas.drawImage(\n      EntityImage,\n      this.prereqsActive ? 140 : 128,\n      0,\n      12,\n      6,\n      this.position.x - 6 / PIXELS_PER_TILE,\n      this.position.y - 2,\n      12 / PIXELS_PER_TILE,\n      6 / PIXELS_PER_TILE\n    );\n  }\n\n  drawForMap(canvas: Canvas): void {\n    canvas.setColor(\"black\");\n\n    this.doorCollider.draw(canvas);\n  }\n}\n", "import { UI_CANVAS_HEIGHT } from \"../constants/ScreenConstants\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nexport const OPEN_DURATION = 0.4;\nexport const CLOSE_DURATION = 0.25;\n\nexport const PUZZLE_WINDOW_WIDTH = (7 / 9) * UI_CANVAS_HEIGHT;\n\nexport const SOLVED_BACKGROUND = \"#00ff62dd\";\nexport const DEFAULT_BACKGROUND = \"#0096ffdd\";\n\nexport const GROUP_SOLVED_BACKGROUND = \"#00cc22\";\nexport const GROUP_DEFAULT_BACKGROUND = \"#0060dd\";\n\nexport const N_CIRCLE_LAYOUT = [\n  [new Circle(new Vector(0, 0), 0.33)],\n  [new Circle(new Vector(0, 0), 0.33)],\n  [new Circle(new Vector(0, 0.4), 0.33), new Circle(new Vector(0, -0.4), 0.33)],\n  [\n    new Circle(new Vector(-0.42, 0.4), 0.33),\n    new Circle(new Vector(0.42, 0.4), 0.33),\n    new Circle(new Vector(0, -0.4), 0.33),\n  ],\n  [\n    new Circle(new Vector(0.4, 0.4), 0.33),\n    new Circle(new Vector(0.4, -0.4), 0.33),\n    new Circle(new Vector(-0.4, 0.4), 0.33),\n    new Circle(new Vector(-0.4, -0.4), 0.33),\n  ],\n  [\n    new Circle(new Vector(0, 0.3), 0.28),\n    new Circle(new Vector(0.64, 0.3), 0.28),\n    new Circle(new Vector(-0.64, 0.3), 0.28),\n    new Circle(new Vector(-0.32, -0.3), 0.28),\n    new Circle(new Vector(0.32, -0.3), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0.6), 0.28),\n    new Circle(new Vector(0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.32, 0), 0.28),\n    new Circle(new Vector(0.32, 0), 0.28),\n    new Circle(new Vector(0, -0.6), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0), 0.28),\n    new Circle(new Vector(0.64, 0), 0.28),\n    new Circle(new Vector(-0.64, 0), 0.28),\n    new Circle(new Vector(-0.32, -0.6), 0.28),\n    new Circle(new Vector(0.32, -0.6), 0.28),\n    new Circle(new Vector(-0.32, 0.6), 0.28),\n    new Circle(new Vector(0.32, 0.6), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0.6), 0.28),\n    new Circle(new Vector(0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.32, 0), 0.28),\n    new Circle(new Vector(0.32, 0), 0.28),\n    new Circle(new Vector(0, -0.6), 0.28),\n    new Circle(new Vector(0.64, -0.6), 0.28),\n    new Circle(new Vector(-0.64, -0.6), 0.28),\n  ],\n];\n\nexport const N_SQUARE_LAYOUT = [\n  [Rectangle.centerForm(0, 0, 0.33, 0.33)],\n  [Rectangle.centerForm(0, 0, 0.33, 0.33)],\n  [\n    Rectangle.centerForm(0, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(0, 0.4, 0.33, 0.33),\n  ],\n  [\n    Rectangle.centerForm(0, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(-0.4, 0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, 0.4, 0.33, 0.33),\n  ],\n  [\n    Rectangle.centerForm(-0.4, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(-0.4, 0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, 0.4, 0.33, 0.33),\n  ],\n];\n\nconst k = 0.12;\nconst s = (1.6 - 4*k) / 5;\nconst t0 = s/2 + k/2;\nconst t1 = 3 * t0;\n\nexport const ICON_SHAPES: Record<string, (Rectangle | Circle)[]> = {\n  calendar: [\n    // new Rectangle(-0.8, -0.5, 0.8, 0.5),\n    // top seg\n    Rectangle.widthForm(-0.8, -0.55, 1.6, 0.2),\n    Rectangle.widthForm(-0.8, -0.3, 1.6, 0.2),\n    // bottom seg\n    Rectangle.widthForm(-0.8, 0.2, 1.6, 0.5),\n    // vert segs\n    Rectangle.widthForm(-0.8, -0.3, 0.2, 1),\n    Rectangle.widthForm(-0.3, -0.3, 0.15, 1),\n    Rectangle.widthForm(0.15, -0.3, 0.15, 1),\n    Rectangle.widthForm(0.6, -0.3, 0.2, 1),\n    // ring clips\n    Rectangle.centerForm(-t1, -0.6, k/2, 0.1),\n    Rectangle.centerForm(-t0, -0.6, k/2, 0.1),\n    Rectangle.centerForm(t0, -0.6, k/2, 0.1),\n    Rectangle.centerForm(t1, -0.6, k/2, 0.1),\n  ],\n  plus: [\n    Rectangle.centerForm(0, 0, 0.1, 0.8),\n    Rectangle.centerForm(0, 0, 0.8, 0.1),\n  ],\n  minus: [\n    Rectangle.centerForm(0, 0, 0.8, 0.1),\n  ],\n};\n", "import { Rectangle } from \"../math/Shapes\";\nimport { PUZZLE_WINDOW_WIDTH } from \"./constants\";\nimport { PositionGetter } from \"./types\";\n\nconst CACHE: Record<string, Rectangle[][]> = {};\n\nconst cacheKey = (rows: number, cols: number, leftCol: boolean) =>\n  `${rows}-${cols}-${leftCol}`;\n\nconst produceObject = (\n  rows: number,\n  cols: number,\n  leftCol: boolean\n): Rectangle[][] => {\n  const WIDE_EDGE = 0.7;\n  const BOTTOM_ROW = 0.5;\n  const LEFT_COL = leftCol ? 1 : 0.5;\n  const CELL_SIZE_FROM_COLS = Math.floor(\n    PUZZLE_WINDOW_WIDTH / (cols + WIDE_EDGE + LEFT_COL)\n  );\n  const CELL_SIZE_FROM_ROWS = Math.floor(\n    PUZZLE_WINDOW_WIDTH / (rows + WIDE_EDGE + BOTTOM_ROW)\n  );\n  const CELL_SIZE = Math.min(CELL_SIZE_FROM_COLS, CELL_SIZE_FROM_ROWS);\n  const BOTTOM_SIZE = Math.floor(CELL_SIZE * BOTTOM_ROW);\n  const LEFT_SIZE = Math.floor(CELL_SIZE * LEFT_COL);\n  const WIDE_SIZE = Math.min(\n    PUZZLE_WINDOW_WIDTH - CELL_SIZE * cols - LEFT_SIZE,\n    PUZZLE_WINDOW_WIDTH - CELL_SIZE * rows - BOTTOM_SIZE\n  );\n\n  const FULL_HEIGHT = WIDE_SIZE + BOTTOM_SIZE + rows * CELL_SIZE;\n  const FULL_WIDTH = WIDE_SIZE + LEFT_SIZE + cols * CELL_SIZE;\n\n  const TOP_EDGE = Math.max((FULL_WIDTH - FULL_HEIGHT) / 2, 0);\n  const LEFT_EDGE = Math.max((FULL_HEIGHT - FULL_WIDTH) / 2, 0);\n\n  let lastX = LEFT_EDGE + LEFT_SIZE;\n  const xSpacing = [[LEFT_EDGE, lastX]];\n\n  for (let i = 0; i < cols; i++) {\n    xSpacing.push([lastX, lastX + CELL_SIZE]);\n    lastX += CELL_SIZE;\n  }\n\n  xSpacing.push([lastX, lastX + WIDE_SIZE]);\n\n  let lastY = TOP_EDGE + WIDE_SIZE;\n  const ySpacing = [[TOP_EDGE, lastY]];\n\n  for (let i = 0; i < rows; i++) {\n    ySpacing.push([lastY, lastY + CELL_SIZE]);\n    lastY += CELL_SIZE;\n  }\n\n  ySpacing.push([lastY, lastY + BOTTOM_SIZE]);\n\n  const matrix = [];\n\n  for (const [y1, y2] of ySpacing) {\n    const thisRow = [];\n    for (const [x1, x2] of xSpacing) {\n      thisRow.push(new Rectangle(x1, y1, x2, y2));\n    }\n\n    matrix.push(thisRow);\n  }\n\n  return matrix;\n};\n\nconst getObject = (rows: number, cols: number, leftCol: boolean) => {\n  const key = cacheKey(rows, cols, leftCol);\n  if (!(key in CACHE)) {\n    CACHE[key] = produceObject(rows, cols, leftCol);\n  }\n\n  return CACHE[key];\n};\n\nexport const positionGetter = (\n  rows: number,\n  cols: number,\n  leftCol?: boolean\n): PositionGetter => {\n  const matrix = getObject(rows, cols, !!leftCol);\n\n  // Indexed from [-1 to ROWS][-1 to COLS]\n  return (row: number | \"end\", col: number | \"end\") => {\n    return matrix[row === \"end\" ? rows + 1 : row + 1][\n      col === \"end\" ? cols + 1 : col + 1\n    ];\n  };\n};\n", "import {\n  UI_PIXEL_WIDTH,\n  UI_CANVAS_HEIGHT,\n  UI_CANVAS_WIDTH,\n} from \"../constants/ScreenConstants\";\nimport { ClickEvent, InputEvent, InputState } from \"../InputManager\";\nimport { clamp } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nimport {\n  CLOSE_DURATION,\n  DEFAULT_BACKGROUND,\n  OPEN_DURATION,\n  PUZZLE_WINDOW_WIDTH,\n  SOLVED_BACKGROUND,\n} from \"./constants\";\nimport { positionGetter } from \"./PuzzleSpaceManager\";\nimport { PuzzleValidator } from \"./validation/PuzzleValidation\";\nimport {\n  CellValue,\n  PositionGetter,\n  PuzzleCellMap,\n  PuzzleGrid,\n  PuzzleValues,\n} from \"./types\";\nimport { SimpleScreen } from \"../apps/SimpleScreen\";\nimport { EditorScreen } from \"../apps/EditorScreen\";\n\nconst PARTIAL_RADIUS = 0.4;\n\ntype DragState = \"enabling\" | \"emptying\" | \"disabling\" | undefined;\ntype DragKind = \"left\" | \"right\" | undefined;\n\ninterface Element {\n  row: number;\n  col: number;\n  shape: Rectangle;\n  isHovered: boolean;\n}\n\ntype CellGroup = [number, number][];\n\nexport interface PuzzleConfig {\n  combinedGroups?: CellGroup[];\n}\n\nconst SPACE_DEBUG_DRAW = false;\n\nexport class Puzzle {\n  // Basic info\n  id: string;\n  rows: number;\n  cols: number;\n\n  // Open state\n  openCloseStatus: number;\n  isOpen: boolean;\n\n  // Puzzle display & state info\n  grid: PuzzleGrid;\n  values: PuzzleValues;\n  cellMap: PuzzleCellMap;\n  elements: Element[];\n  positionGetter: PositionGetter;\n  miniElements: Element[];\n\n  // Validation & completion\n  validator: PuzzleValidator;\n  isSolved: boolean;\n  hasBeenSolvedEver: boolean;\n\n  // Interaction\n  dragState: DragState;\n  dragKind: DragKind;\n\n  constructor(\n    id: string,\n    rows: number,\n    columns: number,\n    validator: PuzzleValidator,\n    config: PuzzleConfig = {}\n  ) {\n    this.id = id;\n    this.openCloseStatus = 0;\n    this.isOpen = false;\n    this.rows = rows;\n    this.cols = columns;\n\n    this.validator = validator;\n    this.isSolved = false;\n    this.hasBeenSolvedEver = false;\n\n    let incId = 0;\n\n    this.positionGetter = positionGetter(\n      rows,\n      columns,\n      validator.validationItems.some((item) => item.drawnOnLeft)\n    );\n\n    this.grid = [];\n\n    // Initialise grid\n    for (let row = 0; row < rows; row++) {\n      const currentRow = [];\n\n      for (let col = 0; col < columns; col++) {\n        incId++;\n        const cell = {\n          row,\n          column: col,\n          id: incId,\n        };\n        currentRow.push(cell);\n      }\n\n      this.grid.push(currentRow);\n    }\n\n    // Combine provided groups with an id\n    if (config.combinedGroups) {\n      for (const group of config.combinedGroups) {\n        incId++;\n        const groupId = incId;\n        group.forEach(([row, column]) => {\n          this.grid[row][column].id = groupId;\n        });\n      }\n    }\n\n    this.values = {};\n    this.cellMap = {};\n\n    // Initialise values & cell map\n    for (const cell of this.grid.flat()) {\n      this.values[cell.id] = null;\n      this.cellMap[cell.id] =\n        cell.id in this.cellMap ? this.cellMap[cell.id].concat([cell]) : [cell];\n    }\n\n    this.elements = [];\n    this.miniElements = [];\n\n    // Construct elements\n    for (const id in this.cellMap) {\n      const cells = this.cellMap[id];\n\n      this.elements.push({\n        row: cells[0].row,\n        col: cells[0].column,\n        shape: Rectangle.merged(\n          cells.map(({ row, column }) => this.positionGetter(row, column))\n        ).inset(UI_PIXEL_WIDTH),\n        isHovered: false,\n      });\n      this.miniElements.push({\n        row: cells[0].row,\n        col: cells[0].column,\n        shape: Rectangle.merged(\n          cells.map(({ row, column }) => Rectangle.widthForm(column, row, 1, 1))\n        ),\n        isHovered: false,\n      });\n    }\n  }\n\n  open(status = 0) {\n    if (this.isOpen) {\n      return;\n    }\n\n    this.isOpen = true;\n    this.openCloseStatus = status;\n  }\n\n  close(status?: number) {\n    this.isOpen = false;\n\n    if (status !== undefined) {\n      this.openCloseStatus = status;\n    }\n  }\n\n  canvasWidth: number = 0;\n  canvasHeight: number = 0;\n\n  uiPosition(screenManager?: ScreenManager | SimpleScreen | EditorScreen) {\n    // Function with f(0) = 1, f(1) = 0, f\"(1) = 0\n    // Feel free to replace this with any other function moving those\n    // parameters.\n    const pos = Math.pow(1 - this.openCloseStatus, 2);\n\n    if (screenManager) {\n      this.canvasWidth = screenManager.uiCanvas.width;\n      this.canvasHeight = screenManager.uiCanvas.height;\n    }\n\n    const slideInOffset = new Vector(0, UI_CANVAS_HEIGHT * pos);\n    const puzzleScreenOffset = new Vector(\n      (this.canvasWidth - PUZZLE_WINDOW_WIDTH) / 2,\n      (this.canvasHeight - PUZZLE_WINDOW_WIDTH) / 2\n    );\n    return Vector.add(slideInOffset, puzzleScreenOffset);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager | SimpleScreen | EditorScreen, hideMonitorLeg?: boolean) {\n    const canvas = screenManager.uiCanvas;\n\n    canvas.clear();\n\n    if (this.openCloseStatus === 0) {\n      return;\n    }\n\n    const offset = this.uiPosition(screenManager);\n\n    canvas.translate(offset.x, offset.y);\n\n    // Draw screen background\n    canvas.setColor(this.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND);\n    canvas.fillRect(0, 0, PUZZLE_WINDOW_WIDTH, PUZZLE_WINDOW_WIDTH);\n\n    // Monitor outline color\n    canvas.setColor(\"#222222\");\n\n    if (!hideMonitorLeg) {\n      // Draw monitor leg\n      canvas.fillRect(\n        PUZZLE_WINDOW_WIDTH / 4,\n        PUZZLE_WINDOW_WIDTH,\n        PUZZLE_WINDOW_WIDTH / 2,\n        PUZZLE_WINDOW_WIDTH\n      );\n    }\n\n    // Draw monitor outline\n    canvas.setLineWidth(UI_PIXEL_WIDTH * 8);\n    canvas.setLineDash([]);\n    canvas.strokeRectInset(\n      0,\n      0,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH,\n      -UI_PIXEL_WIDTH * 4\n    );\n\n    // Draw screen outline\n    canvas.setColor(\"#ffffff64\");\n    canvas.setLineWidth(UI_PIXEL_WIDTH);\n\n    canvas.strokeRectInset(\n      0,\n      0,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH,\n      UI_PIXEL_WIDTH / 2\n    );\n\n    if (SPACE_DEBUG_DRAW) {\n      canvas.setColor(\"red\");\n      canvas.setLineDash([]);\n      for (let i = -1; i <= this.rows; i++) {\n        for (let j = -1; j <= this.cols; j++) {\n          this.positionGetter(i, j).stroke(canvas);\n        }\n      }\n    }\n\n    // Draw squares\n    for (const element of this.elements) {\n      if (element.isHovered) {\n        canvas.setColor(\"white\");\n      } else {\n        canvas.setColor(\"#ffffff64\");\n      }\n      canvas.setLineDash([]);\n      element.shape.stroke(canvas, UI_PIXEL_WIDTH / 2);\n\n      const cellState = this.getElementState(element);\n      const mid = element.shape.midpoint;\n      const radius =\n        Math.min(element.shape.width, element.shape.height) * PARTIAL_RADIUS;\n      if (cellState) {\n        canvas.setColor(\"white\");\n        canvas.fillEllipse(mid.x, mid.y, radius, radius);\n      } else if (cellState === false) {\n        // Might be null, so need exact check\n        canvas.setColor(\"#ffffff64\");\n        canvas.setLineDash([UI_PIXEL_WIDTH * 2, UI_PIXEL_WIDTH * 2]);\n        canvas.strokeEllipse(mid.x, mid.y, radius, radius);\n      }\n    }\n\n    this.validator.draw(canvas, this.positionGetter);\n\n    canvas.translate(-offset.x, -offset.y);\n  }\n\n  getRowColState(row: number, column: number): CellValue {\n    const cell = this.grid[row][column];\n    return this.values[cell.id];\n  }\n\n  getElementState(element: Element): CellValue {\n    return this.getRowColState(element.row, element.col);\n  }\n\n  setElementState(element: Element, value: CellValue) {\n    const cell = this.grid[element.row][element.col];\n    if (value !== this.values[cell.id]) {\n      this.values[cell.id] = value;\n      this.onStateChange();\n    }\n  }\n\n  resolveClick(element: Element, left: boolean, right: boolean) {\n    const elementState = this.getElementState(element);\n    if (this.dragKind === undefined) {\n      return;\n    } else if (this.dragKind === \"left\" && !left) {\n      this.dragKind = undefined;\n      this.dragState = undefined;\n    } else if (this.dragKind === \"right\" && !right) {\n      this.dragKind = undefined;\n      this.dragState = undefined;\n    }\n\n    if (this.dragKind === \"left\") {\n      if (this.dragState === undefined) {\n        const current = elementState;\n        if (current !== true) {\n          this.dragState = \"enabling\";\n        } else {\n          this.dragState = \"emptying\";\n        }\n      }\n\n      if (this.dragState === \"enabling\") {\n        if (elementState !== false) {\n          this.setElementState(element, true);\n        }\n      } else if (this.dragState === \"emptying\") {\n        if (elementState !== false) {\n          this.setElementState(element, null);\n        }\n      }\n    } else if (this.dragKind === \"right\") {\n      if (this.dragState === undefined) {\n        const current = elementState;\n        if (current !== false) {\n          this.dragState = \"disabling\";\n        } else {\n          this.dragState = \"emptying\";\n        }\n      }\n\n      if (this.dragState === \"disabling\") {\n        if (elementState !== true) {\n          this.setElementState(element, false);\n        }\n      } else if (this.dragState === \"emptying\") {\n        if (elementState !== true) {\n          this.setElementState(element, null);\n        }\n      }\n    }\n  }\n\n  findPositionElement(position: Vector): Element | undefined {\n    let foundElement: Element | undefined = undefined;\n    for (const element of this.elements) {\n      element.isHovered = element.shape.intersectsPoint(position);\n      if (element.isHovered) {\n        foundElement = element;\n      }\n    }\n    return foundElement;\n  }\n\n  update(deltaTime: number, inputState: InputState) {\n    if (this.isOpen && this.openCloseStatus < 1) {\n      this.openCloseStatus += deltaTime / OPEN_DURATION;\n    } else if (!this.isOpen && this.openCloseStatus > 0) {\n      this.openCloseStatus -= deltaTime / CLOSE_DURATION;\n    }\n\n    this.openCloseStatus = clamp(this.openCloseStatus, 0, 1);\n\n    if (inputState && this.openCloseStatus === 1) {\n      const position = Vector.diff(inputState.mousePosition, this.uiPosition());\n\n      const foundElement = this.findPositionElement(position);\n\n      if (foundElement) {\n        this.resolveClick(\n          foundElement,\n          inputState.isLeftClicking(),\n          inputState.isRightClicking()\n        );\n      }\n    } else {\n      this.dragState = undefined;\n    }\n  }\n\n  onStateChange() {\n    this.isSolved = this.validator.isValid(this.grid, this.values);\n    if (this.isSolved) {\n      this.hasBeenSolvedEver = true;\n    }\n  }\n\n  onInput(input: InputEvent) {\n    if (input.isClick()) {\n      const click = input as ClickEvent;\n      const clickPosition = Vector.diff(click.position, this.uiPosition());\n\n      this.dragKind = click.isRightClick() ? \"right\" : \"left\";\n      this.dragState = undefined;\n\n      const foundElement = this.findPositionElement(clickPosition);\n\n      if (foundElement) {\n        this.resolveClick(\n          foundElement,\n          this.dragKind === \"left\",\n          this.dragKind === \"right\"\n        );\n      }\n    }\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\n\nexport class PuzzleValidator {\n  validationItems: ValidationItem[];\n\n  leftAreas: Rectangle[] | undefined;\n\n  constructor(validationItems: ValidationItem[]) {\n    this.validationItems = validationItems;\n  }\n\n  isValid(grid: PuzzleGrid, values: PuzzleValues) {\n    this.validationItems.forEach((item) => {\n      item.validate(grid, values);\n    });\n\n    return this.validationItems.every((item) => item.isValid);\n  }\n\n  getLeftArea(index: number, total: number, positionGetter: PositionGetter) {\n    if (this.leftAreas) {\n      return this.leftAreas[index];\n    }\n    // TODO Draw this better when there are more global rules than fits\n    const leftColumn = Rectangle.merged([\n      positionGetter(-1, -1),\n      positionGetter(\"end\", -1),\n    ]);\n\n    const width = leftColumn.width;\n    const top = leftColumn.midpoint.y - width * (total + 0.1 * (total - 1));\n    this.leftAreas = [];\n    for (let i = 0; i < total; i++) {\n      this.leftAreas.push(\n        Rectangle.widthForm(leftColumn.x1, top + i * width * 1.1, width, width)\n      );\n    }\n\n    return this.leftAreas[index];\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter, ...args: unknown[]) {\n    this.validationItems.forEach((item) => {\n      if (!item.drawnOnLeft) {\n        item.draw(canvas, positionGetter, ...args);\n      }\n    });\n\n    const globals = this.validationItems.filter((item) => item.drawnOnLeft);\n\n    globals.forEach((item, index) => {\n      item.draw(\n        canvas,\n        this.getLeftArea(index, globals.length, positionGetter)\n      );\n    });\n  }\n}\n\nexport class ValidationItem {\n  isValid: boolean;\n  drawnOnLeft: boolean;\n\n  constructor() {\n    this.isValid = false;\n    this.drawnOnLeft = false;\n  }\n\n  validate(_grid: PuzzleGrid, _values: PuzzleValues) {\n    // Do nothing...\n  }\n\n  draw(_canvas: Canvas, ..._args: unknown[]) {\n    // Do nothing...\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { Vector } from \"../../math/Vector\";\n\nimport { N_CIRCLE_LAYOUT, SOLVED_BACKGROUND } from \"../constants\";\nimport { ValidationItem } from \"./PuzzleValidation\";\nimport { PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\n\nexport class CellValidation extends ValidationItem {\n  row: number;\n  column: number;\n\n  constructor(row: number, column: number) {\n    super();\n    this.row = row;\n    this.column = column;\n  }\n}\n\nexport class ForcedCellValidation extends CellValidation {\n  mustBeOn: boolean;\n\n  constructor(row: number, column: number, mustBeOn: boolean) {\n    super(row, column);\n    this.mustBeOn = mustBeOn;\n\n    this.isValid = !mustBeOn;\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues) {\n    const cell = grid[this.row][this.column];\n\n    this.isValid = !!values[cell.id] === !!this.mustBeOn;\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const rect = positionGetter(this.row, this.column);\n\n    const width = Math.min(rect.width, rect.height);\n\n    const center = new Vector(rect.x2 - width * 0.15, rect.y1 + width * 0.15);\n\n    if (this.mustBeOn) {\n      canvas.fillEllipse(center.x, center.y, width * 0.1, width * 0.1);\n    } else {\n      canvas.setLineWidth(width * 0.05);\n      canvas.setLineDash([]);\n      canvas.strokeEllipse(center.x, center.y, width * 0.075, width * 0.075);\n    }\n  }\n}\n\nexport class CountInAreaValidation extends CellValidation {\n  desiredCount: number;\n  isCellColoured: boolean;\n\n  constructor(row: number, column: number, desiredCount: number) {\n    super(row, column);\n\n    this.desiredCount = desiredCount;\n    this.isValid = desiredCount === 0;\n    this.isCellColoured = false;\n  }\n\n  *iterateArea(grid: PuzzleGrid) {\n    for (\n      let row = Math.max(this.row - 1, 0);\n      row <= Math.min(this.row + 1, grid.length - 1);\n      row++\n    ) {\n      for (\n        let col = Math.max(this.column - 1, 0);\n        col <= Math.min(this.column + 1, grid[row].length - 1);\n        col++\n      ) {\n        yield [row, col];\n      }\n    }\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues) {\n    let count = 0;\n\n    const seenIds = new Set();\n\n    for (const [row, col] of this.iterateArea(grid)) {\n      const cell = grid[row][col];\n      if (!!values[cell.id] && !seenIds.has(cell.id)) {\n        count++;\n        seenIds.add(cell.id);\n      }\n    }\n\n    this.isValid = count === this.desiredCount;\n    this.isCellColoured = !!values[grid[this.row][this.column].id];\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(this.isCellColoured ? SOLVED_BACKGROUND : \"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const rect = positionGetter(this.row, this.column);\n\n    const width = Math.min(rect.width, rect.height) * 0.25;\n\n    const center = rect.midpoint;\n\n    for (const circle of N_CIRCLE_LAYOUT[this.desiredCount]) {\n      const position = Vector.add(center, Vector.scale(circle.position, width));\n\n      if (this.desiredCount === 0) {\n        canvas.setLineWidth(circle.radius * width * 0.5);\n        canvas.strokeEllipse(\n          position.x,\n          position.y,\n          circle.radius * width * 0.75,\n          circle.radius * width * 0.75\n        );\n      } else {\n        canvas.fillEllipse(\n          position.x,\n          position.y,\n          circle.radius * width,\n          circle.radius * width\n        );\n      }\n    }\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { Circle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\n\nimport { N_CIRCLE_LAYOUT, N_SQUARE_LAYOUT } from \"../constants\";\nimport { ValidationItem } from \"./PuzzleValidation\";\nimport { CellValue, PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\n\nconst rotRight = (vector: Vector) => new Vector(-vector.y, vector.x);\n\nclass EdgeValidationItem extends ValidationItem {\n  isRow: boolean;\n  index: number;\n\n  constructor(isRow: boolean, index: number) {\n    super();\n    this.isRow = isRow;\n    this.index = index;\n\n    this.isValid = false;\n  }\n\n  getRelevantRow(grid: PuzzleGrid, valueMap: PuzzleValues): CellValue[] {\n    const cells = this.isRow\n      ? grid[this.index]\n      : grid.map((row) => row[this.index]);\n\n    const [values] = cells.reduce<[CellValue[], number]>(\n      ([valuesSoFar, lastId], cell) => [\n        cell.id === lastId\n          ? valuesSoFar\n          : valuesSoFar.concat([valueMap[cell.id]]),\n        cell.id,\n      ],\n      [[], -1]\n    );\n\n    return values;\n  }\n\n  validateRow(_row: CellValue[]): boolean {\n    throw new TypeError(\"Cannot validate as a generic EdgeValidationItem\");\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues) {\n    const row = this.getRelevantRow(grid, values);\n\n    this.isValid = this.validateRow(row);\n  }\n\n  drawInCell(\n    _canvas: Canvas,\n    _center: Vector,\n    _scaleBy: number,\n    _isSideways: boolean\n  ) {\n    throw new TypeError(\"Cannot draw a generic EdgeValidationItem\");\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    if (this.isRow) {\n      const cell = positionGetter(this.index, \"end\");\n\n      this.drawInCell(canvas, cell.midpoint, cell.width / 2, true);\n    } else {\n      const cell = positionGetter(-1, this.index);\n\n      this.drawInCell(canvas, cell.midpoint, cell.height / 2, false);\n    }\n  }\n}\n\nexport class EdgeCountValidationItem extends EdgeValidationItem {\n  count: number;\n\n  constructor(isRow: boolean, index: number, count: number) {\n    super(isRow, index);\n    this.count = count;\n\n    this.isValid = count === 0;\n  }\n\n  validateRow(row: CellValue[]) {\n    const count = row.reduce((soFar, item) => (item ? soFar + 1 : soFar), 0);\n\n    return count === this.count;\n  }\n\n  drawInCell(\n    canvas: Canvas,\n    center: Vector,\n    scaleBy: number,\n    isSideways: boolean\n  ) {\n    const transformCircle = isSideways\n      ? (circle: Circle) => new Circle(rotRight(circle.position), circle.radius)\n      : (v: Circle) => v;\n\n    for (let circle of N_CIRCLE_LAYOUT[this.count]) {\n      circle = transformCircle(circle);\n      const position = Vector.add(\n        center,\n        Vector.scale(circle.position, scaleBy)\n      );\n\n      if (this.count === 0) {\n        canvas.setLineDash([]);\n        canvas.setLineWidth(circle.radius * scaleBy * 0.5);\n        canvas.strokeEllipse(\n          position.x,\n          position.y,\n          circle.radius * scaleBy * 0.75,\n          circle.radius * scaleBy * 0.75\n        );\n      } else {\n        canvas.fillEllipse(\n          position.x,\n          position.y,\n          circle.radius * scaleBy,\n          circle.radius * scaleBy\n        );\n      }\n    }\n  }\n}\n\nexport class EdgeGroupsValidationItem extends EdgeCountValidationItem {\n  validateRow(row: CellValue[]) {\n    const [numGroups] = row.reduce(\n      ([soFar, inGroup], item) =>\n        item && !inGroup\n          ? // Start of new group\n            [soFar + 1, true]\n          : // Continue, updating inGroup based on current item state\n            [soFar, !!item],\n      [0, false]\n    );\n\n    return numGroups === this.count;\n  }\n\n  drawSquare(canvas: Canvas, position: Vector, width: number) {\n    canvas.fillRect(\n      position.x - width / 2,\n      position.y - width / 2,\n      width,\n      width\n    );\n  }\n\n  drawInCell(\n    canvas: Canvas,\n    center: Vector,\n    scaleBy: number,\n    isSideways: boolean\n  ) {\n    const moveCenter = (pos: Vector) => (isSideways ? rotRight(pos) : pos);\n\n    for (const square of N_SQUARE_LAYOUT[this.count]) {\n      const position = Vector.add(\n        center,\n        Vector.scale(moveCenter(square.midpoint), scaleBy)\n      );\n      const width = square.width * scaleBy;\n\n      this.drawSquare(canvas, position, width);\n    }\n  }\n}\n\nexport class EdgeBlankGroupsValidationItem extends EdgeGroupsValidationItem {\n  constructor(isRow: boolean, index: number, count: number) {\n    super(isRow, index, count);\n\n    this.isValid = count === 1;\n  }\n\n  validateRow(row: CellValue[]) {\n    const [numGroups] = row.reduce(\n      ([soFar, inGroup], item) =>\n        !item && inGroup\n          ? // Start of new group\n            [soFar + 1, false]\n          : // Continue, updating inGroup based on current item state\n            [soFar, !!item],\n      [0, true]\n    );\n\n    return numGroups === this.count;\n  }\n\n  drawSquare(canvas: Canvas, position: Vector, width: number) {\n    canvas.setLineDash([]);\n    canvas.setLineWidth(width * 0.25);\n    canvas.strokeRectInset(position.x, position.y, 0, 0, -width * 0.4);\n  }\n}\n\nexport class EdgeNoTripleValidationItem extends EdgeValidationItem {\n  constructor(isRow: boolean, index: number) {\n    super(isRow, index);\n\n    // Valid by default if no triple\n    this.isValid = true;\n  }\n\n  validateRow(row: CellValue[]) {\n    let count = 0;\n    for (const value of row) {\n      if (value) {\n        count += 1;\n      } else {\n        count = 0;\n      }\n      if (count >= 3) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  drawInCell(\n    canvas: Canvas,\n    center: Vector,\n    scaleBy: number,\n    isSideways: boolean\n  ) {\n    canvas.setLineWidth(scaleBy * 0.1);\n    canvas.setLineDash([]);\n\n    canvas.fillEllipse(center.x, center.y, 0.22 * scaleBy, 0.22 * scaleBy);\n    const center2 = Vector.add(\n      center,\n      Vector.scale(\n        isSideways ? new Vector(-0.5, 0) : new Vector(0, 0.5),\n        scaleBy\n      )\n    );\n    canvas.fillEllipse(center2.x, center2.y, 0.22 * scaleBy, 0.22 * scaleBy);\n    const center3 = Vector.add(center, Vector.diff(center, center2));\n\n    const radius = scaleBy * 0.22;\n    canvas.drawLine(\n      center3.x - radius,\n      center3.y - radius,\n      center3.x + radius,\n      center3.y + radius\n    );\n    canvas.drawLine(\n      center3.x - radius,\n      center3.y + radius,\n      center3.x + radius,\n      center3.y - radius\n    );\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { PIXEL_WIDTH } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { PuzzleGrid, PuzzleValues } from \"../types\";\nimport { ValidationItem } from \"./PuzzleValidation\";\n\nclass GlobalValidationItem extends ValidationItem {\n  constructor() {\n    super();\n    this.drawnOnLeft = true;\n  }\n\n  draw(canvas: Canvas, rectangle: Rectangle) {}\n}\n\nexport class GlobalCountValidationItem extends GlobalValidationItem {\n  desiredCount: number;\n  currentCount: number;\n\n  constructor(count: number) {\n    super();\n    this.desiredCount = count;\n    this.currentCount = 0;\n  }\n\n  validate(_grid: PuzzleGrid, values: PuzzleValues) {\n    this.currentCount = 0;\n    for (const val of Object.values<boolean | null>(values)) {\n      if (val) {\n        this.currentCount++;\n      }\n    }\n\n    this.isValid = this.currentCount === this.desiredCount;\n  }\n\n  drawNumber(canvas: Canvas, rectangle: Rectangle, number: number) {\n    // TODO Draw numbers better, this is bad\n    const center = rectangle.midpoint;\n    const w = Math.min(rectangle.height, rectangle.width);\n    const squareSize = Math.ceil(Math.sqrt(number));\n    const radius = w / squareSize;\n    const l = center.x - ((squareSize - 1) * radius) / 2;\n    const t = center.y - ((squareSize - 1) * radius) / 2;\n\n    if (number === 0) {\n      canvas.setLineWidth(PIXEL_WIDTH);\n      canvas.strokeEllipse(center.x, center.y, w * 0.4, w * 0.4);\n    }\n\n    for (let row = 0; row < squareSize; row++) {\n      for (let col = 0; col < squareSize; col++) {\n        const ind = row * squareSize + col;\n        if (ind < number) {\n          canvas.fillEllipse(\n            l + col * radius,\n            t + row * radius,\n            radius * 0.4,\n            radius * 0.4\n          );\n        }\n      }\n    }\n  }\n\n  draw(canvas: Canvas, cell: Rectangle) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n    // const cell = positionGetter(0, -1).inset(PIXEL_WIDTH * 2);\n\n    const halfWidth = cell.width / 2;\n    const halfHeight = cell.height / 2;\n\n    const midpoint = cell.midpoint;\n\n    this.drawNumber(\n      canvas,\n      Rectangle.widthForm(cell.x1, cell.y1, halfWidth, halfHeight),\n      this.currentCount\n    );\n    canvas.setLineWidth(PIXEL_WIDTH);\n    canvas.drawLine(\n      midpoint.x - halfWidth * 0.67,\n      midpoint.y + halfHeight * 0.67,\n      midpoint.x + halfWidth * 0.67,\n      midpoint.y - halfHeight * 0.67\n    );\n    this.drawNumber(\n      canvas,\n      Rectangle.widthForm(midpoint.x, midpoint.y, halfWidth, halfHeight),\n      this.desiredCount\n    );\n  }\n}\n\nexport class GlobalContinentValidationItem extends GlobalValidationItem {\n  constructor() {\n    super();\n    this.isValid = true;\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues): void {\n    const SIGNAL_VALUE = 1;\n\n    // Make copy of grid\n    const copiedGrid: (boolean | typeof SIGNAL_VALUE)[][] = [];\n    for (const row of grid) {\n      const copiedRow = [];\n      for (const cell of row) {\n        copiedRow.push(!!values[cell.id]);\n      }\n      copiedGrid.push(copiedRow);\n    }\n\n    const queue: [number, number][] = [];\n\n    for (let row = 0; row < copiedGrid.length; row++) {\n      for (let col = 0; col < copiedGrid[row].length; col++) {\n        if (copiedGrid[row][col]) {\n          queue.push([row, col]);\n          // Break out of all\n          row = copiedGrid.length;\n          break;\n        }\n      }\n    }\n\n    while (queue.length > 0) {\n      const [row, col] = queue.pop()!;\n\n      // Cell already visited or empty\n      if (copiedGrid[row][col] === SIGNAL_VALUE || !copiedGrid[row][col]) {\n        continue;\n      }\n\n      copiedGrid[row][col] = SIGNAL_VALUE;\n      if (row > 0) {\n        queue.push([row - 1, col]);\n      }\n      if (col > 0) {\n        queue.push([row, col - 1]);\n      }\n      if (row + 1 < copiedGrid.length) {\n        queue.push([row + 1, col]);\n      }\n      if (col + 1 < copiedGrid[row].length) {\n        queue.push([row, col + 1]);\n      }\n    }\n\n    this.isValid = true;\n\n    for (let row = 0; row < copiedGrid.length; row++) {\n      for (let col = 0; col < copiedGrid[row].length; col++) {\n        if (copiedGrid[row][col] && copiedGrid[row][col] !== SIGNAL_VALUE) {\n          this.isValid = false;\n          // Immediately terminate\n          row = copiedGrid.length;\n          break;\n        }\n      }\n    }\n  }\n\n  draw(canvas: Canvas, rectangle: Rectangle): void {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const center = rectangle.midpoint;\n    const minDim = Math.min(rectangle.width, rectangle.height) / 2;\n    canvas.fillEllipse(center.x, center.y, minDim * 0.8, minDim * 0.8);\n  }\n}\n", "import { CountInAreaValidation, ForcedCellValidation } from \"./CellValidation\";\nimport {\n  EdgeBlankGroupsValidationItem,\n  EdgeCountValidationItem,\n  EdgeGroupsValidationItem,\n  EdgeNoTripleValidationItem,\n} from \"./EdgeValidation\";\nimport { GlobalContinentValidationItem, GlobalCountValidationItem } from \"./GlobalValidation\";\nimport { PuzzleValidator, ValidationItem } from \"./PuzzleValidation\";\n\nexport class PuzzleValidatorFactory {\n  validationItems: ValidationItem[];\n\n  constructor() {\n    this.validationItems = [];\n  }\n\n  addForcedCellValidator(row: number, column: number, mustBeOn: boolean) {\n    this.validationItems.push(new ForcedCellValidation(row, column, mustBeOn));\n    return this;\n  }\n\n  addCountAreaValidator(row: number, column: number, count: number) {\n    this.validationItems.push(new CountInAreaValidation(row, column, count));\n    return this;\n  }\n\n  addEdgeValidators(\n    nums: (number | null)[],\n    isRow: boolean,\n    ValidationItemType = EdgeCountValidationItem\n  ) {\n    nums.forEach((num, index) => {\n      if (typeof num !== \"number\") {\n        return;\n      }\n\n      this.validationItems.push(new ValidationItemType(isRow, index, num));\n    });\n  }\n\n  addColumnCounts(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false);\n    return this;\n  }\n\n  addRowCounts(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true);\n    return this;\n  }\n\n  addColumnGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false, EdgeGroupsValidationItem);\n    return this;\n  }\n\n  addRowGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true, EdgeGroupsValidationItem);\n    return this;\n  }\n\n  addColumnBlankGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false, EdgeBlankGroupsValidationItem);\n    return this;\n  }\n\n  addRowBlankGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true, EdgeBlankGroupsValidationItem);\n    return this;\n  }\n\n  addColumnNoTriple(yeses: boolean[]) {\n    yeses.forEach((bool, index) => {\n      if (!bool) {\n        return;\n      }\n\n      this.validationItems.push(new EdgeNoTripleValidationItem(false, index));\n    });\n    return this;\n  }\n\n  addRowNoTriple(yeses: boolean[]) {\n    yeses.forEach((bool, index) => {\n      if (!bool) {\n        return;\n      }\n\n      this.validationItems.push(new EdgeNoTripleValidationItem(true, index));\n    });\n    return this;\n  }\n\n  setGlobalCount(count: number) {\n    this.validationItems.push(new GlobalCountValidationItem(count));\n    return this;\n  }\n\n  addContinentRule() {\n    this.validationItems.push(new GlobalContinentValidationItem());\n    return this;\n  }\n\n  create() {\n    return new PuzzleValidator(this.validationItems);\n  }\n}\n", "import { Puzzle, PuzzleConfig } from \"./Puzzle\";\nimport { PuzzleValidatorFactory } from \"./validation/PuzzleValidatorFactory\";\n\nexport interface PuzzleRules {\n  rows: number;\n  cols: number;\n\n  columnCounts?: (number | null)[];\n  rowCounts?: (number | null)[];\n\n  columnGroups?: (number | null)[];\n  rowGroups?: (number | null)[];\n\n  columnBlankGroups?: (number | null)[];\n  rowBlankGroups?: (number | null)[];\n\n  columnNoTriple?: boolean[];\n  rowNoTriple?: boolean[];\n\n  forcedCells?: { row: number; col: number; on: boolean }[];\n  countAreas?: { row: number; col: number; count: number }[];\n\n  globalCount?: number;\n  continent?: boolean;\n\n  config?: PuzzleConfig;\n}\n\nexport const initPuzzle = (id: string, options: PuzzleRules) => {\n  const { rows, cols, config } = options;\n\n  const rules = new PuzzleValidatorFactory();\n\n  if (options.columnCounts) {\n    rules.addColumnCounts(options.columnCounts);\n  }\n  if (options.rowCounts) {\n    rules.addRowCounts(options.rowCounts);\n  }\n  if (options.columnGroups) {\n    rules.addColumnGroups(options.columnGroups);\n  }\n  if (options.rowGroups) {\n    rules.addRowGroups(options.rowGroups);\n  }\n  if (options.columnBlankGroups) {\n    rules.addColumnBlankGroups(options.columnBlankGroups);\n  }\n  if (options.rowBlankGroups) {\n    rules.addRowBlankGroups(options.rowBlankGroups);\n  }\n  if (options.columnNoTriple) {\n    rules.addColumnNoTriple(options.columnNoTriple);\n  }\n  if (options.rowNoTriple) {\n    rules.addRowNoTriple(options.rowNoTriple);\n  }\n  if (options.forcedCells) {\n    options.forcedCells.forEach((cell) => {\n      rules.addForcedCellValidator(cell.row, cell.col, cell.on);\n    });\n  }\n  if (options.countAreas) {\n    options.countAreas.forEach((cell) => {\n      rules.addCountAreaValidator(cell.row, cell.col, cell.count);\n    });\n  }\n  if (options.globalCount) {\n    rules.setGlobalCount(options.globalCount);\n  }\n  if (options.continent) {\n    rules.addContinentRule();\n  }\n\n  return new Puzzle(id, rows, cols, rules.create(), config);\n};\n", "import { DataLoader } from \"../level/DataLoader\";\nimport { Puzzle } from \"./Puzzle\";\nimport { PuzzleRules, initPuzzle } from \"./PuzzleFactory\";\n\nfunction makePuzzle(id: string): Puzzle {\n  const rules = DataLoader.puzzles;\n  if (id in rules) {\n    return initPuzzle(id, rules[id]);\n  }\n\n  console.warn(`Cannot find puzzle with id: ${id}`);\n\n  return initPuzzle(id, {\n    rows: 1,\n    cols: 1,\n    rowCounts: [1],\n    columnCounts: [1],\n  });\n}\n\nclass PuzzleManagerInstance {\n  puzzleMap: Record<string, Puzzle>;\n\n  constructor() {\n    this.puzzleMap = {};\n  }\n\n  loadPuzzle(id: string): Puzzle {\n    return makePuzzle(id);\n  }\n\n  getPuzzle(id: string) {\n    if (id in this.puzzleMap) {\n      return this.puzzleMap[id];\n    }\n\n    const puzzle = this.loadPuzzle(id);\n    this.puzzleMap[id] = puzzle;\n\n    return puzzle;\n  }\n\n  insertPuzzle(id: string, rules: PuzzleRules): Puzzle {\n    if (id in this.puzzleMap) {\n      return this.puzzleMap[id];\n    }\n\n    const puzzle = initPuzzle(id, rules);\n    this.puzzleMap[id] = puzzle;\n\n    return puzzle;\n  }\n\n  instantiate(rules: PuzzleRules): Puzzle {\n    return initPuzzle(\"placeholder\", rules);\n  }\n}\n\nexport const PuzzleManager = new PuzzleManagerInstance();\n", "import { Canvas } from \"../../Canvas\";\nimport { EntityImage } from \"../../constants/Image\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { LevelEvent, OpenMapEvent, ToPortalEvent } from \"../LevelEvent\";\nimport { Player } from \"../Player\";\nimport { Interactible } from \"./Interactible\";\n\n\nexport class PortalInteractible extends Interactible {\n  level: Level | undefined;\n\n  constructor(id: string, position: Vector, prereqs: string[]) {\n    super(\n      id,\n      position,\n      Rectangle.centerForm(position.x, position.y, 4, 4),\n      prereqs\n    );\n\n    this.connectionPoint = new Vector(position.x, position.y + 3.5);\n\n    this.showAsMapIcon = false;\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    canvas.drawImage(\n      EntityImage,\n      this.prereqsActive ? 80 : 0,\n      40,\n      80,\n      80,\n      this.position.x - 4,\n      this.position.y - 4,\n      8,\n      8\n    );\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    if (!this.level) {\n      this.level = level;\n    }\n\n    if (this.prereqsActive) {\n      this.showAsMapIcon = true;\n    }\n\n    super.update(player, deltaTime, level);\n  }\n\n  drawAsMapIcon(canvas: Canvas, level: Level) {\n    const primaryColor = level.interactingWith === this ? \"#08f\" : \"red\";\n\n    canvas.setColor(\"black\");\n    canvas.fillDiamond(0, 0, 7.5, 10.5);\n    canvas.setColor(primaryColor);\n    canvas.fillDiamond(0, 0, 6, 9);\n  }\n\n  onInteract(): void | LevelEvent | undefined {\n    if (this.level) {\n      return new OpenMapEvent(this, this.level);\n    }\n  }\n\n  clickedOnMap(): void | LevelEvent | undefined {\n    if (this.level) {\n      return new ToPortalEvent(this, this.level);\n    }\n  }\n}\n", "import { PlayMode } from \"../game-modes/PlayMode\";\nimport { PortalInteractible } from \"./interactibles/PortalInteractible\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { Level } from \"./Level\";\n\nexport class LevelEvent {\n  constructor() {}\n\n  isExitEvent() {\n    return false;\n  }\n\n  isOpenPuzzleEvent(): this is OpenPuzzleEvent {\n    return false;\n  }\n\n  isClosePuzzleEvent(): this is ClosePuzzleEvent {\n    return false;\n  }\n\n  isOpenMapEvent(): this is OpenMapEvent {\n    return false;\n  }\n\n  process(_playMode: PlayMode) {}\n}\n\nexport class ExitEvent extends LevelEvent {\n  exitTrigger: ExitTrigger;\n\n  constructor(exitTrigger: ExitTrigger) {\n    super();\n    this.exitTrigger = exitTrigger;\n  }\n\n  isExitEvent() {\n    return true;\n  }\n}\n\nexport class OpenPuzzleEvent extends LevelEvent {\n  puzzleId: string;\n\n  constructor(puzzleId: string) {\n    super();\n    this.puzzleId = puzzleId;\n  }\n\n  isOpenPuzzleEvent() {\n    return true;\n  }\n}\n\nexport class ClosePuzzleEvent extends LevelEvent {\n  puzzleId: string;\n\n  constructor(puzzleId: string) {\n    super();\n    this.puzzleId = puzzleId;\n  }\n\n  isClosePuzzleEvent() {\n    return true;\n  }\n}\n\nexport class OpenMapEvent extends LevelEvent {\n  fromPortal: PortalInteractible;\n  fromLevel: Level;\n\n  constructor(portal: PortalInteractible, level: Level) {\n    super();\n\n    this.fromPortal = portal;\n    this.fromLevel = level;\n  }\n\n  isOpenMapEvent() {\n    return true;\n  }\n}\n\nexport class ToPortalEvent extends LevelEvent {\n  toPortal: PortalInteractible;\n  toLevel: Level;\n\n  constructor(portal: PortalInteractible, level: Level) {\n    super();\n\n    this.toPortal = portal;\n    this.toLevel = level;\n  }\n\n  process(playMode: PlayMode): void {\n    const currentPortal = playMode.currentLevel.interactingWith;\n    if (currentPortal && currentPortal instanceof PortalInteractible) {\n      playMode.currentLevel.interactingWith = undefined;\n    }\n\n    playMode.goToPortal(this.toLevel, this.toPortal);\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport {\n  DEFAULT_BACKGROUND,\n  SOLVED_BACKGROUND,\n} from \"../../puzzle-manager/constants\";\nimport { Puzzle } from \"../../puzzle-manager/Puzzle\";\nimport { PuzzleManager } from \"../../puzzle-manager/PuzzleManager\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\n\nimport { OpenPuzzleEvent } from \"../LevelEvent\";\n\nimport { Interactible } from \"./Interactible\";\n\ninterface Config {\n  isFlipped?: boolean;\n}\n\nconst SCREEN_W = 1;\n\nconst DRAW_CIRCLES = false;\n\nexport class PuzzleInteractible extends Interactible {\n  puzzleId: string;\n  private _puzzle: Puzzle | undefined;\n  config: Config;\n\n  constructor(\n    id: string,\n    position: Vector,\n    area: Rectangle,\n    prereqs: string[],\n    puzzleId: string,\n    config: Config\n  ) {\n    super(id, position, area, prereqs);\n\n    this.puzzleId = puzzleId;\n    this.connectionPoint = Vector.add(position, new Vector(0, 1.2));\n    this.outputPoint = Vector.add(\n      position,\n      new Vector(config.isFlipped ? -1 : 1, -1.15)\n    );\n    this.config = config;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n    this._puzzle = PuzzleManager.getPuzzle(this.puzzleId);\n  }\n\n  // This only works after PuzzleManager instantiation and an onStart call\n  get puzzle(): Puzzle {\n    return this._puzzle!;\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const PIXEL_SCALE = 1 / PIXELS_PER_TILE;\n\n    // Draw monitor leg\n    canvas.setColorRGB(0, 0, 0);\n    canvas.fillRect(\n      this.position.x - SCREEN_W / 2,\n      this.position.y + SCREEN_W,\n      SCREEN_W,\n      1\n    );\n\n    canvas.setLineWidth(PIXEL_SCALE);\n\n    // Draw hover outline\n    if (this.isAreaActive) {\n      canvas.setColorRGB(255, 255, 255, 128);\n      canvas.strokeRectInset(\n        this.position.x,\n        this.position.y,\n        0,\n        0,\n        -SCREEN_W - PIXEL_SCALE * 1.5\n      );\n    }\n\n    // Draw monitor outline\n    canvas.setColorRGB(0, 0, 0);\n    canvas.strokeRectInset(\n      this.position.x,\n      this.position.y,\n      0,\n      0,\n      -SCREEN_W - PIXEL_SCALE / 2\n    );\n\n    // Draw light area\n    const isFlippedMul = this.config.isFlipped ? -1 : 1;\n    canvas.fillRect(\n      this.position.x +\n        isFlippedMul * (SCREEN_W - PIXEL_SCALE) -\n        2 * PIXEL_SCALE,\n      this.position.y - SCREEN_W - 4 * PIXEL_SCALE,\n      4 * PIXEL_SCALE,\n      4 * PIXEL_SCALE\n    );\n\n    if (this.puzzle.hasBeenSolvedEver) {\n      this.isEnabled = true;\n      canvas.setColor(\"white\");\n      canvas.fillRect(\n        this.position.x + isFlippedMul * (SCREEN_W - PIXEL_SCALE) - PIXEL_SCALE,\n        this.position.y - SCREEN_W - 3 * PIXEL_SCALE,\n        PIXEL_SCALE * 2,\n        PIXEL_SCALE * 2\n      );\n    }\n\n    if (this.prereqsActive) {\n      // Draw screen\n      canvas.setColor(\n        this.puzzle.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND\n      );\n      canvas.fillRect(\n        this.position.x - SCREEN_W,\n        this.position.y - SCREEN_W,\n        SCREEN_W * 2,\n        SCREEN_W * 2\n      );\n    }\n\n    this.drawGrid(canvas);\n  }\n\n  drawGrid(canvas: Canvas) {\n    const offset = new Vector(\n      this.position.x - SCREEN_W,\n      this.position.y - SCREEN_W\n    );\n\n    canvas.translate(offset.x, offset.y);\n\n    canvas.setColor(\"white\");\n\n    // Draw current selection\n    const grid = this.puzzle.grid;\n    const SCREEN_PIXEL =\n      (SCREEN_W * 2) / (3 * Math.max(grid.length, grid[0].length) + 1);\n    const SCR_WIDTH = SCREEN_PIXEL * (3 * grid[0].length + 1);\n    const SCR_HEIGHT = SCREEN_PIXEL * (3 * grid.length + 1);\n\n    const TOP_PAD = Math.max(0, (SCR_WIDTH - SCR_HEIGHT) / 2);\n    const LEFT_PAD = Math.max(0, (SCR_HEIGHT - SCR_WIDTH) / 2);\n\n    this.puzzle.miniElements.forEach(({ row, col, shape }) => {\n      if (this.puzzle.values[grid[row][col].id]) {\n        const x0 = LEFT_PAD + SCREEN_PIXEL * (3 * shape.x1 + 1);\n        const y0 = TOP_PAD + SCREEN_PIXEL * (3 * shape.y1 + 1);\n        const w = SCREEN_PIXEL * (3 * shape.width - 1);\n        const h = SCREEN_PIXEL * (3 * shape.height - 1);\n        if (DRAW_CIRCLES) {\n          canvas.fillEllipse(x0 + w / 2, y0 + h / 2, w / 2, h / 2);\n        } else {\n          canvas.fillRect(x0, y0, w, h);\n        }\n      }\n    });\n\n    canvas.translate(-offset.x, -offset.y);\n  }\n\n  drawForMap(canvas: Canvas) {\n    const isSolved = !!this._puzzle?.hasBeenSolvedEver;\n    canvas.setColor(\n      isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND\n    );\n    canvas.fillRect(this.position.x - 1, this.position.y - 1, 2, 2);\n    canvas.setColor(\"#222222\");\n    canvas.setLineWidth(0.2);\n    canvas.setLineDash([]);\n    // Outline\n    canvas.strokeRectInset(this.position.x, this.position.y, 0, 0, -1.1);\n    // Leg\n    canvas.fillRect(this.position.x - 0.5, this.position.y + 1.1, 1, 0.9);\n  }\n\n  onInteract() {\n    return new OpenPuzzleEvent(this.puzzleId);\n  }\n}\n", "import { EntityImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nexport class SwitchInteractible extends Interactible {\n  constructor(\n    id: string,\n    position: Vector,\n    area: Rectangle,\n    prerequisites: string[]\n  ) {\n    super(id, position, area, prerequisites);\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    if (this.isEnabled) {\n      this.isAreaActive = false;\n    } else {\n      super.update(player, deltaTime, level);\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const PIXEL_SCALE = 1 / PIXELS_PER_TILE;\n\n    // Draw hover outline\n    if (this.isAreaActive) {\n      canvas.setColorRGB(255, 255, 255, 128);\n      canvas.setLineWidth(PIXEL_SCALE);\n      canvas.setLineDash([]);\n      canvas.strokeRectInset(\n        this.position.x - PIXEL_SCALE * 3,\n        this.position.y - PIXEL_SCALE * 4,\n        PIXEL_SCALE * 6,\n        PIXEL_SCALE * 8,\n        -PIXEL_SCALE * 1.5\n      );\n    }\n\n    canvas.drawImage(\n      EntityImage,\n      this.isEnabled ? 80 : 40,\n      0,\n      PIXELS_PER_TILE * 4,\n      PIXELS_PER_TILE * 4,\n      this.position.x - 2,\n      this.position.y - 2,\n      4,\n      4\n    );\n  }\n\n  onInteract() {\n    this.isEnabled = true;\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { EntityImage, TileImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { BlockEnum } from \"../BlockTypes\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nconst mockTrigger = {\n  intersectsPoint: () => false,\n  stroke: () => null,\n};\n\nconst OPEN_CLOSE_DUR = 0.3;\n\ninterface Config {\n  isFlipped?: boolean;\n  hasLedge?: boolean;\n  isSingle?: boolean;\n}\n\nexport class TrapdoorInteractible extends Interactible {\n  hasLeft: boolean;\n  hasRight: boolean;\n  hasLedge: boolean;\n\n  leftHead: Rectangle;\n  rightHead: Rectangle;\n  leftDoor: Rectangle;\n  rightDoor: Rectangle;\n\n  ledge: Rectangle;\n\n  fullWidth: number;\n  doorWidth: number;\n\n  constructor(\n    id: string,\n    position: Vector,\n    prerequisites: string[],\n    width = 4,\n    config: Config = {}\n  ) {\n    super(id, position, undefined, prerequisites);\n\n    this.connectionPoint = Vector.add(\n      position,\n      new Vector((config.isFlipped ? 1 : -1) * (width / 2 - 0.9), 0.3)\n    );\n\n    const isDouble = !config.isSingle;\n\n    this.hasLeft = isDouble || !config.isFlipped;\n    this.hasRight = isDouble || !!config.isFlipped;\n\n    this.hasLedge = !!config.hasLedge;\n\n    this.leftHead = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      1.2,\n      0.8\n    );\n    this.rightHead = Rectangle.widthForm(\n      this.position.x + width / 2 - 1.2,\n      this.position.y,\n      1.2,\n      0.8\n    );\n    this.leftDoor = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      this.hasRight ? width / 2 : width,\n      0.6\n    );\n    this.rightDoor = Rectangle.widthForm(\n      this.position.x - (this.hasLeft ? 0 : width / 2),\n      this.position.y,\n      this.hasLeft ? width / 2 : width,\n      0.6\n    );\n\n    this.ledge = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      width,\n      0.2\n    );\n\n    this.fullWidth = width / 2;\n    this.doorWidth = this.hasLeft && this.hasRight ? width / 2 : width;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n\n    if (this.hasLeft) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.leftHead,\n      });\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.leftDoor,\n      });\n    }\n    if (this.hasRight) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.rightHead,\n      });\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.rightDoor,\n      });\n    }\n\n    if (this.hasLedge) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.LEDGE,\n        rect: this.ledge,\n      });\n    }\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const motion = (deltaTime / OPEN_CLOSE_DUR) * (this.prereqsActive ? -1 : 1);\n\n    this.leftDoor.x2 = clamp(\n      this.leftDoor.x2 + motion,\n      this.leftDoor.x1,\n      this.leftDoor.x1 + this.doorWidth\n    );\n\n    this.rightDoor.x1 = clamp(\n      this.rightDoor.x1 - motion,\n      this.rightDoor.x2 - this.doorWidth,\n      this.rightDoor.x2\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (this.hasLedge) {\n      for (let x = this.ledge.x1; x < this.ledge.x2; x++) {\n        canvas.drawImage(\n          TileImage,\n          PIXELS_PER_TILE,\n          0,\n          PIXELS_PER_TILE,\n          PIXELS_PER_TILE,\n          x,\n          this.ledge.y1,\n          1,\n          1\n        );\n      }\n    }\n\n    if (this.hasLeft) {\n      const w = this.leftDoor.width;\n      if (w > 0) {\n        canvas.setColor(\"black\");\n        this.leftDoor.draw(canvas);\n        canvas.drawImage(\n          EntityImage,\n          160 + Math.max(40 - 10 * w, 20) - 10,\n          10,\n          Math.min(10 * w, 20),\n          10,\n          Math.max(this.leftDoor.x1, this.leftDoor.x2 - 2),\n          this.position.y,\n          Math.min(w, 2),\n          1\n        );\n      }\n\n      canvas.drawImage(\n        EntityImage,\n        this.prereqsActive ? 180 : 160,\n        0,\n        12,\n        8,\n        this.leftHead.x1,\n        this.leftHead.y1,\n        this.leftHead.width,\n        this.leftHead.height\n      );\n    }\n    if (this.hasRight) {\n      const w = this.rightDoor.width;\n      if (w > 0) {\n        canvas.setColor(\"black\");\n        this.rightDoor.draw(canvas);\n        canvas.drawImage(\n          EntityImage,\n          170,\n          30,\n          Math.min(10 * w, 20),\n          10,\n          this.rightDoor.x1,\n          this.position.y,\n          Math.min(w, 2),\n          1\n        );\n      }\n\n      canvas.drawImage(\n        EntityImage,\n        this.prereqsActive ? 188 : 168,\n        20,\n        12,\n        8,\n        this.rightHead.x1,\n        this.rightHead.y1,\n        this.rightHead.width,\n        this.rightHead.height\n      );\n    }\n  }\n\n  drawForMap(canvas: Canvas): void {\n    canvas.setColor(\"black\");\n\n    if (this.hasLeft) {\n      this.leftDoor.draw(canvas);\n    }\n    if (this.hasRight) {\n      this.rightDoor.draw(canvas);\n    }\n  }\n}\n", "const HEX = 16;\nconst ZERO = \"0\";\n\n/**\n * A function to convert a number to a zero-padded hex string.\n * @param {number} number The number to be converted\n * @param {number} digits The expected length (for zero-padding purposes)\n */\nexport const toHex = (number: number, digits: number) => {\n  return number.toString(HEX).padStart(digits, ZERO);\n};\n\nexport const rgbaColor = (\n  red: number,\n  green: number,\n  blue: number,\n  alpha = 255\n) => {\n  return `#${toHex(red, 2)}${toHex(green, 2)}${toHex(blue, 2)}${toHex(\n    alpha,\n    2\n  )}`;\n};\n\nexport const hslaColor = (\n  hue: number,\n  saturation: number,\n  lightness: number,\n  alpha = 1\n) => {\n  return `hsla(${hue},${Math.floor(saturation * 100)}%,${Math.floor(\n    lightness * 100\n  )}%,${alpha})`;\n};\n\nconst rgbToHue = (r: number, g: number, b: number): number => {\n  let h = 0;\n\n  const min = Math.min(r, g, b);\n  const max = Math.max(r, g, b);\n\n  if (max === r) {\n    h = (g - b) / (max - min);\n  }\n  if (max === g) {\n    h = 2 + (b - r) / (max - min);\n  }\n  if (max === b) {\n    h = 4 + (r - g) / (max - min);\n  }\n  if (isNaN(h)) {\n    h = 0;\n  }\n  h = h * 60;\n  if (h < 0) {\n    h = h + 360;\n  }\n  return h;\n};\n\nconst fromHex = (hexColor: string): [number, number, number] => {\n  return [\n    parseInt(hexColor.slice(1, 3), 16),\n    parseInt(hexColor.slice(3, 5), 16),\n    parseInt(hexColor.slice(5, 7), 16)\n  ];\n};\n\nexport const hexToHue = (hexColor: string) => {\n  const [r, g, b] = fromHex(hexColor);\n  return rgbToHue(r, g, b);\n};\n", "import { Canvas } from \"../../Canvas\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { rgbaColor } from \"../../utils/Color\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Entity } from \"./Entity\";\n\nconst UNCOVER_DURATION = 1;\n\ninterface Config {\n  coverIsTrigger?: boolean;\n  canReCover?: boolean;\n}\n\nexport class CoverEntity extends Entity {\n  coverArea: Rectangle;\n  extraCovers: Rectangle[];\n  triggerArea: Rectangle;\n\n  coverIsTrigger: boolean;\n  canReCover: boolean;\n  isUncovered: boolean;\n\n  revealState: number;\n\n  lastPlayerPos: Vector | undefined;\n\n  constructor(\n    id: string,\n    coverArea: Rectangle,\n    extraCovers: Rectangle[],\n    triggerArea: Rectangle,\n    config: Config = {}\n  ) {\n    super(id);\n\n    this.coverArea = coverArea;\n    this.extraCovers = extraCovers;\n    this.triggerArea = triggerArea;\n\n    this.coverIsTrigger = !!config.coverIsTrigger;\n    this.canReCover = !!config.canReCover;\n\n    this.isUncovered = false;\n    this.revealState = 0;\n  }\n\n  playerCollidesCover(player: Player) {\n    return (\n      this.coverArea.intersectsPoint(player.position) ||\n      this.extraCovers.some((cover) => cover.intersectsPoint(player.position))\n    );\n  }\n\n  isPlayerTriggering(player: Player) {\n    return (\n      this.triggerArea.intersectsPoint(player.position) ||\n      (this.coverIsTrigger && this.playerCollidesCover(player))\n    );\n  }\n\n  isOpen(player: Player) {\n    if (!this.canReCover) {\n      if (this.isUncovered) {\n        return true;\n      } else {\n        this.isUncovered = this.isPlayerTriggering(player);\n        return this.isUncovered;\n      }\n    } else {\n      return this.isPlayerTriggering(player);\n    }\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const isOpen = this.isOpen(player);\n\n    this.revealState = clamp(\n      this.revealState + (isOpen ? 1 : -1) * (deltaTime / UNCOVER_DURATION),\n      0,\n      1\n    );\n\n    this.lastPlayerPos = player.position;\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    // Nothing to draw if fully revealed\n    if (this.revealState === 1) {\n      return;\n    }\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (this.revealState === 0) {\n      canvas.setColor(\"black\");\n    } else {\n      const size = this.coverArea.width + this.coverArea.height;\n\n      const fadeRange = size * 0.2;\n      const pos = this.lastPlayerPos\n        ? Vector.lerp(\n            this.lastPlayerPos,\n            this.coverArea.midpoint,\n            this.revealState\n          )\n        : this.coverArea.midpoint;\n\n      const rOut = (size + fadeRange) * this.revealState;\n      const gradient = canvas.createRadialGradient(\n        pos.x,\n        pos.y,\n        Math.max(0, rOut - fadeRange / 2),\n        pos.x,\n        pos.y,\n        rOut + fadeRange / 2\n      );\n      gradient.addColorStop(0, rgbaColor(0, 0, 0, 0));\n      gradient.addColorStop(1, rgbaColor(0, 0, 0, 255));\n\n      canvas.setColor(gradient);\n    }\n\n    this.coverArea.draw(canvas);\n    this.extraCovers.forEach((cover) => cover.draw(canvas));\n  }\n\n  drawForMap(canvas: Canvas) {\n    if (this.revealState !== 1) {\n      canvas.setColor(\"black\");\n      for (const rect of this.extraCovers.concat(this.coverArea)) {\n        rect.draw(canvas, 0.05);\n      }\n    }\n  }\n}\n", "import { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { Player } from \"./Player\";\n\nexport class ExitTrigger {\n  collider: Rectangle;\n  key: string;\n  nextLevelCollider: Rectangle;\n\n  constructor(collider: Rectangle, key: string, nextLevelCollider: Rectangle) {\n    this.collider = collider;\n    this.key = key;\n    this.nextLevelCollider = nextLevelCollider || collider;\n  }\n\n  hasEntered(player: Player) {\n    return this.collider.intersectsPoint(player.position);\n  }\n\n  translatePlayerToNext(player: Player) {\n    return Vector.diff(\n      player.position,\n      new Vector(this.nextLevelCollider.x1, this.nextLevelCollider.y1)\n    );\n  }\n}\n", "const Up = Symbol(\"Up\");\nconst Down = Symbol(\"Down\");\nconst Left = Symbol(\"Left\");\nconst Right = Symbol(\"Right\");\nconst Jump = Symbol(\"Jump\");\nconst Interact = Symbol(\"Interact\");\nconst Escape = Symbol(\"Escape\");\nconst Map = Symbol(\"Map\");\n\n// TODO Convert this to an enum\nexport const Input = {\n  Down,\n  Escape,\n  Interact,\n  Jump,\n  Left,\n  Right,\n  Up,\n  Map,\n};\n", "import { Input } from \"./constants/Keys\";\nimport {\n  UI_CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_WIDTH,\n  IS_MOBILE,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nconst KEY_MAP: Record<string, Key> = {\n  \" \": Input.Jump,\n  escape: Input.Escape,\n  esc: Input.Escape,\n  Escape: Input.Escape,\n  Esc: Input.Escape,\n  w: Input.Up,\n  a: Input.Left,\n  s: Input.Down,\n  d: Input.Right,\n  e: Input.Interact,\n  m: Input.Map,\n};\n\ntype ValueOf<T> = T[keyof T];\n\ntype Key = ValueOf<typeof Input>;\n\ntype KeyMap = Record<Key, boolean>;\n\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return window.TouchEvent && event instanceof TouchEvent;\n}\n\nexport class InputState {\n  keyMap: KeyMap;\n  mousePosition: Vector;\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  constructor(\n    keyMap: KeyMap,\n    mousePosition: Vector,\n    leftClicking: boolean = false,\n    rightClicking: boolean = false\n  ) {\n    this.keyMap = keyMap;\n    this.mousePosition = mousePosition;\n    this.leftClicking = leftClicking;\n    this.rightClicking = rightClicking;\n  }\n\n  /**\n   * Check the current value for the horizontal axis input.\n   * @return {number} a value from -1 to 1.\n   */\n  getHorizontalAxis() {\n    return +!!this.keyMap[Input.Right] - +!!this.keyMap[Input.Left];\n  }\n\n  getVerticalAxis() {\n    return +!!this.keyMap[Input.Down] - +!!this.keyMap[Input.Up];\n  }\n\n  /**\n   * Checks whether an input is currently pressed.\n   * @param {Input} input\n   */\n  isPressed(input: Key) {\n    return !!this.keyMap[input];\n  }\n\n  isLeftClicking() {\n    return this.leftClicking;\n  }\n\n  isRightClicking() {\n    return this.rightClicking;\n  }\n\n  static empty() {\n    return new InputState({}, new Vector(0, 0));\n  }\n}\n\nexport class InputEvent {\n  constructor() {}\n\n  isForKey(_key: Key) {\n    return false;\n  }\n\n  isClick() {\n    return false;\n  }\n\n  isScroll() {\n    return false;\n  }\n}\n\nexport class KeyPressEvent extends InputEvent {\n  input: Key;\n\n  constructor(input: Key) {\n    super();\n    this.input = input;\n  }\n\n  isForKey(key: Key) {\n    return key === this.input;\n  }\n}\n\nexport class ClickEvent extends InputEvent {\n  position: Vector;\n  isRight: boolean;\n\n  constructor(position: Vector, isRightClick: boolean) {\n    super();\n    this.position = position;\n    this.isRight = isRightClick;\n  }\n\n  isClick() {\n    return true;\n  }\n\n  isRightClick() {\n    return this.isRight;\n  }\n}\n\nexport class ScrollEvent extends InputEvent {\n  delta: number;\n  discrete: boolean;\n\n  constructor(delta: number, discrete?: boolean) {\n    super();\n    this.delta = delta;\n    this.discrete = !!discrete;\n  }\n\n  isScroll() {\n    return true;\n  }\n}\n\nexport class InputManager {\n  listener: (inputEvent: InputEvent) => void;\n\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  isButtonDown: KeyMap;\n  mousePosition: Vector;\n\n  canvas: HTMLCanvasElement;\n\n  constructor(listener: (inputEvent: InputEvent) => void) {\n    this.leftClicking = false;\n    this.rightClicking = false;\n\n    this.isButtonDown = {};\n    this.listener = listener;\n    this.mousePosition = new Vector(0, 0);\n\n    this.canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  }\n\n  setListener(listener: (inputEvent: InputEvent) => void) {\n    this.listener = listener;\n  }\n\n  /**\n   * Set up event listeners.\n   */\n  init() {\n    const onKeyEvent = (symbol: Key) => {\n      if (this.listener) {\n        this.listener(new KeyPressEvent(symbol));\n      }\n    };\n\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.repeat) {\n        return;\n      }\n      const symbol = KEY_MAP[e.key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = true;\n      onKeyEvent(symbol);\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const symbol = KEY_MAP[e.key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = false;\n    });\n\n    this.canvas.addEventListener(IS_MOBILE ? \"touchmove\" : \"mousemove\", (event) => {\n      this.mousePosition = this.toCanvasPosition(event);\n    });\n\n    this.canvas.addEventListener(IS_MOBILE ? \"touchstart\" : \"mousedown\", (event) => {\n      if (IS_MOBILE) {\n        event.preventDefault();\n      }\n      this.mousePosition = this.toCanvasPosition(event);\n\n      const isLeft = isTouchEvent(event) || (event instanceof MouseEvent && event.button === 0);\n      const isRight = event instanceof MouseEvent && event.button === 2;\n\n      if (isLeft) {\n        this.listener?.(new ClickEvent(this.mousePosition, false));\n        this.leftClicking = true;\n      } else if (isRight) {\n        this.listener?.(new ClickEvent(this.mousePosition, true));\n        this.rightClicking = true;\n      }\n    });\n\n    this.canvas.addEventListener(IS_MOBILE ? \"touchend\" : \"mouseup\", (event) => {\n      const isLeft = isTouchEvent(event) || (event instanceof MouseEvent && event.button === 0);\n      const isRight = event instanceof MouseEvent && event.button === 2;\n\n      if (isLeft) {\n        this.leftClicking = false;\n      } else if (isRight) {\n        this.rightClicking = false;\n      }\n    });\n\n    this.canvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n\n    // Stop current clicks on mouse leave\n    this.canvas.addEventListener(IS_MOBILE ? \"touchend\" : \"mouseleave\", () => {\n      this.leftClicking = false;\n      this.rightClicking = false;\n    });\n\n    this.canvas.addEventListener(\"wheel\", (event) => {\n      this.listener?.(new ScrollEvent(event.deltaY));\n    });\n\n    const wireButton = (id: string, input: Key | (() => InputEvent)) => {\n      const btn = document.getElementById(id);\n\n      if (!btn) {\n        return;\n      }\n\n      btn.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n\n        if (typeof input === \"function\") {\n          this.listener?.(input());\n        } else {\n          this.isButtonDown[input] = true;\n\n          onKeyEvent(input);\n        }\n      });\n\n      btn.addEventListener(\"touchcancel\", (e) => {\n        e.preventDefault();\n        if (typeof input === \"function\") {\n          // Do nothing\n        } else {\n          this.isButtonDown[input] = false;\n        }\n      });\n\n      btn.addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        if (typeof input === \"function\") {\n          // Do nothing\n        } else {\n          this.isButtonDown[input] = false;\n        }\n      });\n    };\n\n    wireButton(\"left\", Input.Left);\n    wireButton(\"right\", Input.Right);\n    wireButton(\"jump\", Input.Jump);\n    wireButton(\"down\", Input.Down);\n    wireButton(\"map\", Input.Map);\n    wireButton(\"exit\", Input.Escape);\n    wireButton(\"zoom-in\", () => new ScrollEvent(1, true));\n    wireButton(\"zoom-out\", () => new ScrollEvent(-1, true));\n  }\n\n  toCanvasPosition(event: MouseEvent | TouchEvent) {\n    const e = isTouchEvent(event)\n      ? (event.touches.item(0) || { clientX: 0, clientY: 0 })\n      : event;\n    return Vector.scale(\n      new Vector(\n        e.clientX - this.canvas.offsetLeft + window.scrollX,\n        e.clientY - this.canvas.offsetTop + window.scrollY\n      ),\n      ((this.canvas.width / this.canvas.clientWidth) * UI_CANVAS_WIDTH) /\n        ON_SCREEN_CANVAS_WIDTH\n    );\n  }\n\n  /**\n   * @return {InputState} The current state of inputs\n   */\n  getInputState() {\n    return new InputState(\n      this.isButtonDown,\n      this.mousePosition,\n      this.leftClicking,\n      this.rightClicking\n    );\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport {\n  HORIZONTAL_TILES,\n  PIXELS_PER_TILE,\n  PIXEL_WIDTH,\n  VERTICAL_TILES,\n} from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { hexToHue, hslaColor } from \"../../utils/Color\";\n\ntype DrawAction = (canvas: Canvas, width: number, height: number) => void;\n\nexport class BackgroundArtist {\n  width: number;\n  height: number;\n\n  hue: number;\n\n  constructor(width: number, height: number, bgColor: string) {\n    this.width = width;\n    this.height = height;\n\n    this.hue = hexToHue(bgColor);\n  }\n\n  lerpFactor(index: number, screenManager: ScreenManager) {\n    return (index + 1) / screenManager.parallax.length;\n  }\n\n  *iterateArea(\n    width: number,\n    height: number,\n    xStep: number,\n    yStep: number\n  ): Generator<[number, number, Rectangle]> {\n    let col = 0;\n    for (let x = 0; x < width; x += xStep) {\n      let row = 0;\n      for (let y = 0; y < height; y += yStep) {\n        yield [row, col, Rectangle.widthForm(x, y, xStep, yStep)];\n        row++;\n      }\n      col++;\n    }\n  }\n\n  prepareCanvas(\n    screenManager: ScreenManager,\n    index: number,\n    backColor: Vector,\n    foreColor: Vector,\n    action: DrawAction\n  ) {\n    const factor = this.lerpFactor(index, screenManager);\n    const scale = PIXELS_PER_TILE * PIXEL_WIDTH;\n    const minSize = new Vector(\n      HORIZONTAL_TILES * scale,\n      VERTICAL_TILES * scale\n    );\n    const fullSize = new Vector(this.width * scale, this.height * scale);\n\n    const size = Vector.lerp(minSize, fullSize, factor);\n    const canvas = screenManager.parallax[index];\n\n    const color = Vector.lerp(backColor, foreColor, factor);\n\n    canvas.setColor(hslaColor(this.hue, color.x, color.y));\n\n    action(canvas, size.x, size.y);\n  }\n\n  getBackgroundHSL(): [number, Vector] {\n    return [this.hue, new Vector(0.14, 0.64)];\n  }\n\n  getBackgroundColor() {\n    const [hue, { x: saturation, y: lightness }] = this.getBackgroundHSL();\n\n    return hslaColor(hue, saturation, lightness);\n  }\n\n  draw(screenManager: ScreenManager) {\n    const backgroundColor = new Vector(0.14, 0.64);\n    const foregroundColor = new Vector(0.3, 0.24);\n\n    screenManager.background.setColor(\n      hslaColor(this.hue, backgroundColor.x, backgroundColor.y)\n    );\n    screenManager.background.fillRect(\n      0,\n      0,\n      screenManager.background.width,\n      screenManager.background.height\n    );\n\n    for (const canvas of screenManager.parallax) {\n      canvas.clear();\n    }\n\n    // Thick horizontal and vertical beams\n    this.prepareCanvas(\n      screenManager,\n      0,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          70,\n          height\n        )) {\n          if (Math.random() > 0.95) {\n            rect.draw(canvas);\n          }\n        }\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          width,\n          70\n        )) {\n          if (Math.random() > 0.95) {\n            rect.draw(canvas);\n          }\n        }\n      }\n    );\n\n    // Structural vertical beams\n    this.prepareCanvas(\n      screenManager,\n      1,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          120,\n          height\n        )) {\n          if (Math.random() > 0.9) {\n            const thickWidth = 20;\n            canvas.setLineWidth(thickWidth * 2);\n            canvas.drawLine(rect.x1, rect.y1, rect.x1, rect.y2);\n            canvas.drawLine(rect.x2, rect.y1, rect.x2, rect.y2);\n\n            const beamWidth = 10;\n            canvas.setLineWidth(beamWidth * 2);\n            const yOffset = Math.floor(Math.random() * 240);\n            for (const [_row2, _col2, rect2] of this.iterateArea(\n              1,\n              height,\n              1,\n              240\n            )) {\n              const y = rect2.y1 + yOffset;\n              canvas.drawLine(rect.x1, y, rect.x2, y);\n              const radius = 20;\n              canvas.outerCircleCorner(\n                rect.x2 - thickWidth - radius,\n                y - beamWidth - radius,\n                20,\n                0\n              );\n              canvas.outerCircleCorner(\n                rect.x1 + thickWidth + radius,\n                y - beamWidth - radius,\n                20,\n                Math.PI / 2\n              );\n              canvas.outerCircleCorner(\n                rect.x1 + thickWidth + radius,\n                y + beamWidth + radius,\n                20,\n                Math.PI\n              );\n              canvas.outerCircleCorner(\n                rect.x2 - thickWidth - radius,\n                y + beamWidth + radius,\n                20,\n                (Math.PI * 3) / 2\n              );\n            }\n          }\n        }\n      }\n    );\n\n    // Boxes\n    this.prepareCanvas(\n      screenManager,\n      2,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        const xs = [],\n          ys = [];\n        for (let i = 0; i < width; i += 800) {\n          xs.push(Math.random() * width);\n        }\n        for (let i = 0; i < height; i += 600) {\n          ys.push(Math.random() * height);\n        }\n\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          50,\n          50\n        )) {\n          if (\n            xs.some((x) => rect.xInRange(x)) ||\n            ys.some((y) => rect.yInRange(y))\n          ) {\n            canvas.setLineWidth(12);\n            rect.stroke(canvas);\n            canvas.setLineWidth(6);\n            if (Math.random() > 0.2) {\n              canvas.drawLine(rect.x1, rect.y1, rect.x2, rect.y2);\n            }\n            if (Math.random() > 0.2) {\n              canvas.drawLine(rect.x2, rect.y1, rect.x1, rect.y2);\n            }\n          }\n        }\n      }\n    );\n\n    // Lots of narrow pipes\n    this.prepareCanvas(\n      screenManager,\n      3,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          30,\n          height\n        )) {\n          if (Math.random() > 0.92) {\n            rect.draw(canvas);\n          }\n        }\n      }\n    );\n  }\n\n  updateCameras(screenManager: ScreenManager) {\n    const back = new Vector(0, 0);\n    const front = screenManager.camera;\n    screenManager.parallax.forEach((_, index) => {\n      screenManager.parallaxCameras[index] = Vector.lerp(\n        back,\n        front,\n        this.lerpFactor(index, screenManager)\n      );\n    });\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { TileImage } from \"../constants/Image\";\nimport { Input } from \"../constants/Keys\";\nimport {\n  CANVAS_HEIGHT,\n  CANVAS_WIDTH,\n  HORIZONTAL_TILES,\n  PIXELS_PER_TILE,\n  PIXEL_WIDTH,\n  UI_PIXEL_WIDTH,\n  VERTICAL_TILES,\n} from \"../constants/ScreenConstants\";\nimport { ClickEvent, InputEvent, InputState } from \"../InputManager\";\nimport { clamp } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nimport { Entity } from \"./entity/Entity\";\n\nimport { BlockEnum } from \"./BlockTypes\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport {\n  ClosePuzzleEvent,\n  ExitEvent,\n  LevelEvent,\n  OpenPuzzleEvent,\n} from \"./LevelEvent\";\nimport { Interactible } from \"./interactibles/Interactible\";\nimport { Player } from \"./Player\";\nimport { PlayMode } from \"../game-modes/PlayMode\";\nimport { BackgroundArtist } from \"./background/BackgroundArtist\";\nimport { PUZZLE_WINDOW_WIDTH } from \"../puzzle-manager/constants\";\n\nconst SCALE_FACTOR = CANVAS_WIDTH / HORIZONTAL_TILES;\n\nconst ON_SCREEN_RECTANGLE = Rectangle.centerForm(\n  CANVAS_WIDTH / 2,\n  CANVAS_HEIGHT / 2,\n  PUZZLE_WINDOW_WIDTH / 2 + UI_PIXEL_WIDTH * 8,\n  PUZZLE_WINDOW_WIDTH / 2 + UI_PIXEL_WIDTH * 8\n);\n\nexport interface Object {\n  type: BlockEnum;\n  rect: Rectangle;\n}\n\nexport class Level {\n  key: string;\n  levelGrid: BlockEnum[][];\n  width: number;\n  height: number;\n\n  player: Player;\n\n  objects: Object[];\n  exitTriggers: ExitTrigger[];\n  interactibles: Interactible[];\n  entities: Entity[];\n\n  camera: Vector;\n  interactingWith: Interactible | undefined;\n\n  backgroundArtist: BackgroundArtist;\n  drawnStatic: boolean;\n  playModeManager: PlayMode | undefined;\n\n  worldPosition: Vector;\n\n  visited: boolean;\n\n  constructor(\n    key: string,\n    width: number,\n    height: number,\n    color: string,\n    levelGrid: BlockEnum[][],\n    objects: Object[],\n    player: Player,\n    exitTriggers: ExitTrigger[],\n    interactibles: Interactible[],\n    entities: Entity[],\n    worldPosition: Vector\n  ) {\n    this.key = key;\n    this.levelGrid = levelGrid;\n    this.objects = objects;\n    this.player = player;\n    this.exitTriggers = exitTriggers;\n    this.interactibles = interactibles;\n    this.entities = entities;\n\n    this.width = width;\n    this.height = height;\n\n    this.camera = this.getIdealCamera();\n    this.interactingWith = undefined;\n\n    this.backgroundArtist = new BackgroundArtist(width, height, color);\n    this.drawnStatic = false;\n    this.playModeManager = undefined;\n\n    this.worldPosition = worldPosition;\n\n    this.visited = false;\n  }\n\n  start(playModeManager: PlayMode) {\n    this.onAwaken();\n\n    this.interactingWith = undefined;\n    this.playModeManager = playModeManager;\n    this.interactibles.forEach((i) => i.onStart(this));\n    this.entities.forEach((e) => e.onStart(this));\n\n    this.visited = true;\n    this.camera = this.getIdealCamera();\n  }\n\n  onAwaken() {\n    this.drawnStatic = false;\n    this.interactibles.forEach((i) => i.onAwaken());\n    this.entities.forEach((e) => e.onAwaken());\n  }\n\n  addWithoutDuplicate(object: Object) {\n    if (!this.objects.find(({ rect }) => rect === object.rect)) {\n      this.objects.push(object);\n    }\n  }\n\n  emitEvent(event: LevelEvent) {\n    // TODO: Either guarantee that this is available or create a queue to send\n    // these events once it does become available.\n    if (this.playModeManager) {\n      this.playModeManager.onLevelEvent(event);\n    }\n  }\n\n  feedPlayerInfo(previousPlayer: Player, previousExit: ExitTrigger) {\n    if (previousExit.key !== this.key) {\n      console.error(\"Exit key mis-match\");\n    }\n    const position = previousExit.translatePlayerToNext(previousPlayer);\n\n    this.player.position.x = position.x;\n    this.player.position.y = position.y;\n\n    this.player.velocity = previousPlayer.velocity.copy();\n\n    this.camera = this.getIdealCamera();\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    // Update player\n    this.player.update(\n      deltaTime,\n      this.isPlayerActive() ? inputState : InputState.empty(),\n      this\n    );\n\n    // Update interactibles\n    this.interactibles.forEach((interactible) => {\n      interactible.update(this.player, deltaTime, this);\n    });\n    if (!this.interactingWith?.isAreaActive) {\n      this.closeCurrentPuzzle();\n    }\n\n    // Update entities\n    this.entities.forEach((entity) => {\n      entity.update(this.player, deltaTime, this);\n    });\n\n    if (!this.interactingWith) {\n      this.updateCamera(deltaTime);\n    }\n\n    this.updateExits();\n  }\n\n  isPlayerActive() {\n    return !this.interactingWith;\n  }\n\n  closeCurrentPuzzle() {\n    // Don't close unnecessarily\n    if (this.interactingWith) {\n      this.emitEvent(new ClosePuzzleEvent(this.interactingWith.id));\n\n      this.interactingWith = undefined;\n    }\n  }\n\n  screenToWorldPos(position: Vector) {\n    return Vector.add(\n      Vector.scale(position, 1 / (PIXEL_WIDTH * PIXELS_PER_TILE)),\n      this.camera\n    );\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (this.isPlayerActive()) {\n      this.player.onInput(input);\n    }\n\n    const isClick = input.isClick() && !(input as ClickEvent).isRightClick();\n    const isInteractKey = input.isForKey(Input.Interact);\n\n    if (isClick || isInteractKey) {\n      if (this.interactingWith) {\n        const shouldClose =\n          isInteractKey || !ON_SCREEN_RECTANGLE.intersectsPoint((input as ClickEvent).position);\n\n        if (shouldClose) {\n          this.closeCurrentPuzzle();\n        }\n      } else {\n        const relevant = this.interactibles.find((i) => i.isAreaActive);\n\n        if (relevant) {\n          const shouldOpen = isInteractKey\n            || (relevant.triggerArea?.intersectsPoint(\n              this.screenToWorldPos((input as ClickEvent).position)\n            ));\n\n          if (shouldOpen) {\n            const event = relevant.onInteract();\n\n            if (event) {\n              if (event.isOpenPuzzleEvent() || event.isOpenMapEvent()) {\n                this.interactingWith = relevant;\n                this.emitEvent(event);\n              }\n            }\n          }\n        }\n      }\n    } else if (input.isForKey(Input.Escape)) {\n      this.closeCurrentPuzzle();\n    }\n  }\n\n  /**\n   * Check if the player should exit.\n   * @returns The trigger key.\n   */\n  updateExits() {\n    const triggeredExit = this.exitTriggers.find((trigger) =>\n      trigger.hasEntered(this.player)\n    );\n\n    if (triggeredExit) {\n      this.emitEvent(new ExitEvent(triggeredExit));\n    }\n  }\n\n  clampCamera(camera: Vector) {\n    const clampedToPlayer = new Vector(\n      clamp(\n        camera.x,\n        this.player.position.x - HORIZONTAL_TILES + 1,\n        this.player.position.x - 1\n      ),\n      clamp(\n        camera.y,\n        this.player.position.y - VERTICAL_TILES + 1,\n        this.player.position.y - 1\n      )\n    );\n    const clampedToLevel = new Vector(\n      clamp(clampedToPlayer.x, 0, this.width - HORIZONTAL_TILES),\n      clamp(clampedToPlayer.y, 0, this.height - VERTICAL_TILES)\n    );\n\n    return clampedToLevel;\n  }\n\n  getNaiveCamera(position = this.player.position) {\n    return new Vector(\n      position.x - HORIZONTAL_TILES / 2,\n      position.y - VERTICAL_TILES / 2\n    );\n  }\n\n  getIdealCamera(position = this.player.position) {\n    return this.clampCamera(this.getNaiveCamera(position));\n  }\n\n  updateCamera(deltaTime: number) {\n    this.camera = this.clampCamera(\n      Vector.lerp(\n        this.camera,\n        this.getNaiveCamera(\n          Vector.add(\n            this.player.position,\n            new Vector(this.player.velocity.x * 0.3, 0)\n          )\n        ),\n        deltaTime * 2\n      )\n    );\n  }\n\n  withSetupCanvas(canvas: Canvas, action: (canvas: Canvas) => void) {\n    canvas.saveTransform();\n    canvas.scale(SCALE_FACTOR, SCALE_FACTOR);\n    action(canvas);\n    canvas.restoreTransform();\n  }\n\n  drawForMap(canvas: Canvas) {\n    canvas.setColor(this.backgroundArtist.getBackgroundColor());\n    canvas.fillRect(0, 0, this.width, this.height);\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        const blockType = this.levelGrid[row][col];\n\n        if (blockType === BlockEnum.SOLID) {\n          canvas.setColor(\"black\");\n          canvas.fillRect(col - 0.05, row - 0.05, 1.1, 1.1);\n        } else if (blockType === BlockEnum.LEDGE) {\n          canvas.setColor(\"black\");\n          canvas.fillRect(col - 0.05, row - 0.05, 1.1, 0.2);\n        }\n      }\n    }\n\n    for (const interactible of this.interactibles) {\n      interactible.drawForMap(canvas);\n    }\n\n    for (const entity of this.entities) {\n      entity.drawForMap(canvas);\n    }\n  }\n\n  /**\n   * Draw the current level.\n   * @param {ScreenManager} screenManager The screen to draw on\n   */\n  draw(screenManager: ScreenManager) {\n    if (!this.drawnStatic) {\n      // Draw background\n      this.backgroundArtist.draw(screenManager);\n\n      this.withSetupCanvas(screenManager.staticWorldCanvas, (canvas) => {\n        canvas.clear();\n\n        canvas.setColor(\"black\");\n        for (let row = 0; row < this.height; row++) {\n          for (let col = 0; col < this.width; col++) {\n            const blockType = this.levelGrid[row][col];\n\n            if (blockType) {\n              canvas.drawImage(\n                TileImage,\n                (blockType - 1) * PIXELS_PER_TILE,\n                0,\n                PIXELS_PER_TILE,\n                PIXELS_PER_TILE,\n                col,\n                row,\n                1,\n                1\n              );\n            }\n          }\n        }\n      });\n\n      screenManager.uiCanvas.clear();\n\n      this.drawnStatic = true;\n    }\n\n    this.withSetupCanvas(screenManager.dynamicWorldCanvas, (canvas) => {\n      canvas.clear();\n\n      this.withSetupCanvas(screenManager.behindGroundCanvas, () => {\n        screenManager.behindGroundCanvas.clear();\n\n        // Draw interactibles\n        this.interactibles.forEach((interactible) => {\n          interactible.draw(screenManager);\n        });\n\n        // Draw player\n        this.player.draw(canvas);\n\n        // Draw entities\n        this.entities.forEach((entity) => {\n          entity.draw(screenManager);\n        });\n      });\n    });\n\n    screenManager.setCamera(\n      new Vector(\n        Math.floor(this.camera.x * SCALE_FACTOR),\n        Math.floor(this.camera.y * SCALE_FACTOR)\n      )\n    );\n\n    this.backgroundArtist.updateCameras(screenManager);\n  }\n}\n", "import { Rectangle } from \"../math/Shapes\";\n\n/**\n * They say premature optimization is the root of all evil.\n *\n * Oh no.\n */\n\nclass RectPoolClass {\n  grid: Rectangle[][];\n  shortGrid: Rectangle[][];\n\n  constructor() {\n    this.grid = [];\n    this.shortGrid = [];\n  }\n\n  innerGet(row: number, col: number, isShort: boolean, grid: Rectangle[][]) {\n    if (!(row in grid)) {\n      grid[row] = [];\n    }\n    if (!(col in grid[row])) {\n      grid[row][col] = Rectangle.widthForm(col, row, 1, isShort ? 0.2 : 1);\n    }\n\n    return grid[row][col];\n  }\n\n  get(row: number, col: number, isShort = false) {\n    return this.innerGet(\n      row,\n      col,\n      isShort,\n      isShort ? this.shortGrid : this.grid\n    );\n  }\n}\n\n// Woo! Singleton pattern again...\nexport const RectPool = new RectPoolClass();\n", "import { Canvas } from \"../Canvas\";\nimport { Input } from \"../constants/Keys\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { clamp, sign } from \"../math/Common\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { BlockEnum, BlockType } from \"./BlockTypes\";\nimport { Level } from \"./Level\";\n\nimport { RectPool } from \"./RectPool\";\n\nconst PLAYER_RADIUS = 0.8;\n\n// Running parameters\nconst PLAYER_MAX_SPEED = 16;\nconst PLAYER_ACCEL = PLAYER_MAX_SPEED / 0.3;\nconst PLAYER_DECEL = 2 * PLAYER_ACCEL;\nconst TURN_SPEED = 1.8 * PLAYER_ACCEL;\n\n// Jump speed parameters\nconst JUMP_HEIGHT = 4;\nconst JUMP_DURATION = 0.6;\nconst PARAM_A = (4 * JUMP_HEIGHT) / JUMP_DURATION;\nconst JUMP_INITIAL_SPEED = PARAM_A;\nconst GRAVITY = (2 * PARAM_A) / JUMP_DURATION;\n\n// Jump assist parameters\nconst COYOTE_TIME = 0.1;\n\n// Climbing parameters\nconst CLIMB_MAX_SPEED = PLAYER_MAX_SPEED * 0.5;\n\nfunction isDefined<T>(value: T | undefined): value is T {\n  return !!value;\n}\n\nenum PlayerState {\n  GROUND,\n  CLIMB,\n  AIR,\n}\n\nexport class Player {\n  position: Vector;\n  velocity: Vector;\n  collider: Circle;\n\n  isDropping: boolean;\n\n  wantsToJump: boolean;\n  contactingAnyLedge: boolean;\n  inAirFor: number;\n\n  state: PlayerState;\n\n  constructor(position: Vector) {\n    this.position = position;\n    this.collider = new Circle(position, PLAYER_RADIUS);\n\n    this.velocity = new Vector(0, 0);\n\n    this.isDropping = false;\n\n    this.wantsToJump = false;\n    this.contactingAnyLedge = false;\n    this.inAirFor = 1;\n\n    this.state = PlayerState.AIR;\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (input.isForKey(Input.Jump)) {\n      this.wantsToJump = true;\n    }\n  }\n\n  collideWithBlock(type: BlockEnum, rect: Rectangle, deltaTime: number) {\n    const isActiveLedge =\n      !this.isDropping &&\n      type === BlockEnum.LEDGE &&\n      this.velocity.y >= 0 &&\n      this.position.y < rect.y1;\n\n    const intersects = this.collider.intersectsRectangle(rect);\n\n    if (intersects && type === BlockEnum.LEDGE) {\n      this.contactingAnyLedge = true;\n      if (this.velocity.y < 0 && this.position.y >= rect.y1) {\n        this.isDropping = true;\n      }\n    }\n\n    if (BlockType.isSolid(type) || isActiveLedge) {\n      if (intersects) {\n        const collidingBy = rect.uncollideCircle(this.collider);\n\n        this.velocity.add(Vector.scale(collidingBy, 1 / deltaTime));\n        // Horizontal rebound\n        if (collidingBy.x > 0 && collidingBy.y === 0) {\n          this.velocity.x = Math.max(0, this.velocity.x);\n        } else if (collidingBy.x < 0 && collidingBy.y === 0) {\n          this.velocity.x = Math.min(0, this.velocity.x);\n        }\n        // Vertical rebound\n        if (collidingBy.y > 0 && collidingBy.x === 0) {\n          this.velocity.y = Math.max(0, this.velocity.y);\n        } else if (collidingBy.y < 0 && collidingBy.x === 0) {\n          this.velocity.y = Math.min(0, this.velocity.y);\n        }\n        this.position.add(collidingBy);\n      }\n      return this.collider.intersectsRectangle(rect);\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   * @param {Level} level The level that the player is in.\n   */\n  update(deltaTime: number, inputState: InputState, level: Level) {\n    const getCellAt = (x: number, y: number): BlockEnum | undefined => {\n      return level.levelGrid[Math.floor(y)]?.[Math.floor(x)];\n    };\n    const getRectAt = (x: number, y: number) => {\n      const type = getCellAt(x, y);\n      if (type) {\n        return {\n          type: getCellAt(x, y),\n          rect: RectPool.get(\n            Math.floor(y),\n            Math.floor(x),\n            type === BlockEnum.LEDGE\n          ),\n        };\n      }\n    };\n\n    // Process horizontal input\n    const inputX = inputState.getHorizontalAxis();\n    const inputY = inputState.getVerticalAxis();\n    const acceleration = new Vector(inputX * PLAYER_ACCEL, 0);\n\n    if (inputState.isPressed(Input.Down) && this.state !== PlayerState.CLIMB) {\n      this.isDropping = true;\n    }\n\n    // Check grounded\n    const playerBottom = this.position.y + this.collider.radius;\n    const cellBelow = getCellAt(this.position.x, playerBottom);\n    const groundingCellBelow = this.isDropping\n      ? BlockType.isSolid(cellBelow)\n      : BlockType.isGrounding(cellBelow);\n\n    const gridCellWithin = getCellAt(this.position.x, this.position.y);\n    const groundedOnGridCell =\n      groundingCellBelow && playerBottom === Math.floor(playerBottom);\n\n    const isGrounded =\n      groundedOnGridCell ||\n      level.objects.some(\n        ({ type, rect }) =>\n          (this.isDropping\n            ? BlockType.isSolid(type)\n            : BlockType.isGrounding(type)) && this.collider.isKissingBelow(rect)\n      );\n\n    const hasLeftLadder =\n      this.state === PlayerState.CLIMB && gridCellWithin !== BlockEnum.LADDER;\n\n    // Calculate immediate overrides\n    if (gridCellWithin === BlockEnum.LADDER && inputY !== 0) {\n      this.state = PlayerState.CLIMB;\n    } else if (isGrounded) {\n      this.state = PlayerState.GROUND;\n    } else if (!gridCellWithin || hasLeftLadder) {\n      // If just leaving ladder and holding up\n      if (hasLeftLadder && inputY < 0) {\n        this.wantsToJump = true;\n      }\n      this.state = PlayerState.AIR;\n    }\n\n    const updateSpeed = (input: number, vCurr: number, decel: number) => {\n      if (sign(input)) {\n        // Turn speed\n        if (sign(input) !== sign(vCurr)) {\n          return -TURN_SPEED * sign(vCurr);\n        }\n      } else {\n        return -Math.min(Math.abs(vCurr / deltaTime), decel) * sign(vCurr);\n      }\n\n      return 0;\n    };\n\n    // General motion\n    if (this.state === PlayerState.GROUND) {\n      this.inAirFor = 0;\n\n      acceleration.x += updateSpeed(inputX, this.velocity.x, PLAYER_DECEL);\n\n      this.velocity.y = 0;\n    } else if (this.state === PlayerState.CLIMB) {\n      this.inAirFor = 0;\n      acceleration.y = inputState.getVerticalAxis() * PLAYER_ACCEL;\n\n      acceleration.x += updateSpeed(inputX, this.velocity.x, PLAYER_DECEL);\n      acceleration.y += updateSpeed(inputY, this.velocity.y, PLAYER_DECEL);\n    } else {\n      // Gravity\n      this.inAirFor += deltaTime;\n      if (gridCellWithin === BlockEnum.VENT) {\n        const ventMultiplier = this.velocity.y > 0 ? 0 : 1.1;\n        acceleration.y -= GRAVITY * ventMultiplier;\n      } else {\n        acceleration.y += GRAVITY;\n      }\n    }\n\n    // Coyote jump\n    if (this.inAirFor < COYOTE_TIME && this.wantsToJump) {\n      this.wantsToJump = false;\n      this.velocity.y = -JUMP_INITIAL_SPEED;\n      this.state = PlayerState.AIR;\n    }\n\n    this.velocity.add(Vector.scale(acceleration, deltaTime));\n    if (this.state === PlayerState.CLIMB) {\n      this.velocity.x = clamp(\n        this.velocity.x,\n        -CLIMB_MAX_SPEED,\n        CLIMB_MAX_SPEED\n      );\n      this.velocity.y = clamp(\n        this.velocity.y,\n        -CLIMB_MAX_SPEED,\n        CLIMB_MAX_SPEED\n      );\n    } else {\n      this.velocity.x = clamp(\n        this.velocity.x,\n        -PLAYER_MAX_SPEED,\n        PLAYER_MAX_SPEED\n      );\n    }\n\n    const step = Vector.scale(this.velocity, deltaTime);\n\n    step.x = clamp(step.x, -PLAYER_RADIUS, PLAYER_RADIUS);\n    step.y = clamp(step.y, -PLAYER_RADIUS, PLAYER_RADIUS);\n\n    this.position.add(step);\n\n    const { x, y } = this.position;\n\n    // Re-ordered to prioritise collisions with closer blocks first\n    const nearbyBlocks = [\n      getRectAt(x, y),\n      getRectAt(x, y + 1),\n      getRectAt(x, y - 1),\n      getRectAt(x - 1, y),\n      getRectAt(x + 1, y),\n      getRectAt(x - 1, y - 1),\n      getRectAt(x + 1, y - 1),\n      getRectAt(x - 1, y + 1),\n      getRectAt(x + 1, y + 1),\n    ].filter(isDefined);\n\n    this.contactingAnyLedge = false;\n\n    nearbyBlocks.concat(level.objects).forEach(({ type, rect }) => {\n      this.collideWithBlock(type!, rect, deltaTime);\n    });\n\n    this.isDropping = this.isDropping && this.contactingAnyLedge;\n  }\n\n  /**\n   * Draw the player on the canvas\n   * @param {Canvas} canvas The canvas to draw on\n   */\n  draw(canvas: Canvas) {\n    canvas.setColor(\"white\");\n\n    this.collider.draw(canvas);\n  }\n}\n", "import { Vector } from \"../math/Vector\";\nimport { BlockEnum } from \"./BlockTypes\";\nimport { Entity } from \"./entity/Entity\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { Interactible } from \"./interactibles/Interactible\";\n\nimport { Level, Object } from \"./Level\";\nimport { Player } from \"./Player\";\n\nexport class LevelFactory {\n  key: string;\n  iid: string;\n  width: number;\n  height: number;\n  levelGrid: BlockEnum[][];\n  objects: Object[];\n  playerPosition: Vector;\n  exitTriggers: ExitTrigger[];\n  interactibles: Interactible[];\n  entities: Entity[];\n  worldPosition: Vector;\n  bgColor: string;\n\n  constructor(key: string, iid: string, width: number, height: number, color: string) {\n    this.key = key;\n    this.iid = iid;\n    this.width = width;\n    this.height = height;\n    this.bgColor = color;\n    this.levelGrid = [];\n    this.objects = [];\n    this.playerPosition = new Vector(16, 9);\n    this.exitTriggers = [];\n    this.interactibles = [];\n    this.entities = [];\n\n    this.worldPosition = new Vector(0, 0);\n  }\n\n  addObjects(objects: Object[]) {\n    this.objects = this.objects.concat(objects);\n    return this;\n  }\n\n  addExits(exits: ExitTrigger[]) {\n    this.exitTriggers = this.exitTriggers.concat(exits);\n    return this;\n  }\n\n  addInteractibles(is: Interactible[]) {\n    this.interactibles = this.interactibles.concat(is);\n    return this;\n  }\n\n  addEntities(es: Entity[]) {\n    this.entities = this.entities.concat(es);\n    return this;\n  }\n\n  setPlayerPos(pos: Vector) {\n    this.playerPosition = pos;\n    return this;\n  }\n\n  setLevelGrid(grid: BlockEnum[][]) {\n    this.levelGrid = grid;\n  }\n\n  makeGridSpace() {\n    this.levelGrid = [];\n\n    for (let row = 0; row < this.height; row++) {\n      this.levelGrid.push([]);\n    }\n  }\n\n  setWorldPosition(vec: Vector) {\n    this.worldPosition = vec;\n  }\n\n  setCell(row: number, col: number, blockType: BlockEnum) {\n    this.levelGrid[row][col] = blockType;\n  }\n\n  create() {\n    return new Level(\n      this.key,\n      this.width,\n      this.height,\n      this.bgColor,\n      this.levelGrid,\n      this.objects,\n      new Player(this.playerPosition),\n      this.exitTriggers,\n      this.interactibles,\n      this.entities,\n      this.worldPosition\n    );\n  }\n}\n", "import { DecorationImage } from \"../../constants/Image\";\nimport { IS_MOBILE, PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Entity } from \"./Entity\";\n\nexport class DecorationEntity extends Entity {\n  position: Vector;\n  width: number;\n  height: number;\n  tilesetPosition: Vector;\n  tilesetWidth: number;\n  tilesetHeight: number;\n  scaling: boolean;\n  hasMobileAlt: boolean;\n\n  constructor(\n    id: string,\n    position: Vector,\n    width: number,\n    height: number,\n    tilesetPosition: Vector,\n    tilesetWidth: number,\n    tilesetHeight: number,\n    tags: string[]\n  ) {\n    super(id);\n    this.position = position;\n    this.width = width;\n    this.height = height;\n    this.tilesetPosition = tilesetPosition;\n    this.tilesetWidth = tilesetWidth;\n    this.tilesetHeight = tilesetHeight;\n    this.scaling = tags.includes(\"Scaling\");\n    this.hasMobileAlt = tags.includes(\"Mobile_alt\");\n  }\n\n  draw(screenManager: ScreenManager) {\n    const canvas = screenManager.behindGroundCanvas;\n\n    if (this.scaling) {\n      // Scale Y only for now\n\n      // Draw top\n      canvas.drawImage(\n        DecorationImage,\n        this.tilesetPosition.x,\n        this.tilesetPosition.y,\n        this.tilesetWidth,\n        PIXELS_PER_TILE, // this.tilesetHeight,\n        this.position.x,\n        this.position.y,\n        this.width,\n        1 // this.height\n      );\n      // Draw bottom\n      canvas.drawImage(\n        DecorationImage,\n        this.tilesetPosition.x,\n        this.tilesetPosition.y + this.tilesetHeight - PIXELS_PER_TILE,\n        this.tilesetWidth,\n        PIXELS_PER_TILE, // this.tilesetHeight,\n        this.position.x,\n        this.position.y + this.height - 1,\n        this.width,\n        1 // this.height\n      );\n      const bottom = this.position.y + this.height - 1;\n      const repeatingYSpace = this.tilesetHeight / PIXELS_PER_TILE - 2;\n      for (let y = this.position.y + 1; y < this.position.y + this.height - 1; y += repeatingYSpace) {\n        const h = Math.min(bottom - y, repeatingYSpace);\n        canvas.drawImage(\n          DecorationImage,\n          this.tilesetPosition.x,\n          this.tilesetPosition.y + PIXELS_PER_TILE,\n          this.tilesetWidth,\n          h * PIXELS_PER_TILE,\n          this.position.x,\n          y,\n          this.width,\n          h\n        );\n      }\n      // // Draw stretched middle\n      // canvas.drawImage(\n      //   DecorationImage,\n      //   this.tilesetPosition.x,\n      //   this.tilesetPosition.y + PIXELS_PER_TILE,\n      //   this.tilesetWidth,\n      //   this.tilesetHeight - 2 * PIXELS_PER_TILE,\n      //   this.position.x,\n      //   this.position.y + 1,\n      //   this.width,\n      //   this.height - 2\n      // );\n    } else {\n      canvas.drawImage(\n        DecorationImage,\n        this.tilesetPosition.x,\n        this.tilesetPosition.y + (this.hasMobileAlt && IS_MOBILE ? this.tilesetHeight : 0),\n        this.tilesetWidth,\n        this.tilesetHeight,\n        this.position.x,\n        this.position.y,\n        this.width,\n        this.height\n      );\n    }\n  }\n}\n", "import { Vector } from \"../../math/Vector\";\nimport { Puzzle } from \"../../puzzle-manager/Puzzle\";\nimport { PuzzleManager } from \"../../puzzle-manager/PuzzleManager\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\n\nimport { OpenPuzzleEvent } from \"../LevelEvent\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nexport class NodeInteractible extends Interactible {\n  puzzleId: string;\n  puzzle: Puzzle | undefined;\n\n  constructor(\n    id: string,\n    position: Vector,\n    prereqs: string[],\n    puzzleId: string\n  ) {\n    super(id, position, undefined, prereqs);\n\n    this.puzzleId = puzzleId;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n    if (this.puzzleId) {\n      this.puzzle = PuzzleManager.getPuzzle(this.puzzleId);\n    }\n  }\n\n  update(player: Player, deltaTime: number, level: Level): void {\n    super.update(player, deltaTime, level);\n    if (!this.isEnabled) {\n      if (this.puzzle) {\n        this.isEnabled = this.puzzle.hasBeenSolvedEver && this.prereqsActive;\n      } else {\n        this.isEnabled = this.prereqsActive;\n      }\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n  }\n\n  onInteract() {\n    return new OpenPuzzleEvent(this.puzzleId);\n  }\n}\n", "import { PIXELS_PER_TILE } from \"../constants/ScreenConstants\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { DoorInteractible } from \"./interactibles/DoorInteractible\";\nimport { PuzzleInteractible } from \"./interactibles/PuzzleInteractible\";\nimport { SwitchInteractible } from \"./interactibles/SwitchInteractible\";\nimport { TrapdoorInteractible } from \"./interactibles/TrapdoorInteractible\";\nimport { CoverEntity } from \"./entity/CoverEntity\";\n\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { LevelFactory } from \"./LevelFactory\";\nimport { Level } from \"./Level\";\nimport { PuzzleRules } from \"../puzzle-manager/PuzzleFactory\";\nimport { DecorationEntity } from \"./entity/DecorationEntity\";\nimport { NodeInteractible } from \"./interactibles/NodeInteractible\";\nimport { PortalInteractible } from \"./interactibles/PortalInteractible\";\nimport { Grouping } from \"../types\";\nimport { PuzzleManager } from \"../puzzle-manager/PuzzleManager\";\n\nconst LEVEL_DATA_URL = \"/data/world.json\";\nconst PUZZLE_DATA_URL = \"/data/puzzles.json\";\n\ninterface EntityRef {\n  entityIid: string;\n}\n\ninterface FieldData {\n  __identifier: string;\n  __value: string | boolean | string[] | EntityRef | EntityRef[];\n}\n\ninterface EntityData {\n  __identifier: string;\n  iid: string;\n  fieldInstances: FieldData[];\n  __grid: [number, number];\n  px: [number, number];\n  width: number;\n  height: number;\n  __tags: string[];\n  __tile: { x: number; y: number; w: number; h: number };\n}\n\ninterface GridCell {\n  px: [number, number];\n  src: [number, number];\n}\n\ninterface LayerData {\n  __identifier: string;\n  gridTiles: GridCell[];\n  entityInstances: EntityData[];\n}\n\ninterface LevelData {\n  identifier: string;\n  iid: string;\n  pxWid: number;\n  pxHei: number;\n  worldX: number;\n  worldY: number;\n\n  __bgColor: string;\n  __neighbours: { levelIid: string }[];\n\n  layerInstances: LayerData[];\n}\n\ninterface WorldData {\n  levels: LevelData[];\n}\n\nfunction loadJson<T>(file: string): Promise<T> {\n  return fetch(file).then((data) => data.json());\n}\n\nfunction find<T extends { __identifier: string }>(list: T[], iden: string) {\n  return list.find((item) => item.__identifier === iden);\n}\n\nfunction findByIid<T extends { iid: string }>(list: T[], iid?: string) {\n  return list.find((item) => item.iid === iid);\n}\n\nfunction findLayer(level: LevelData, key: string) {\n  return find(level.layerInstances, key);\n}\n\nfunction pxToTile(num: number) {\n  return Math.floor(num / PIXELS_PER_TILE);\n}\n\nfunction toTile(num: number) {\n  return num / PIXELS_PER_TILE;\n}\n\nfunction srcToBlockType(src: [number, number]) {\n  return pxToTile(src[0]) + 1;\n}\n\nfunction getField<T>(entity: EntityData, fieldKey: string): T | undefined {\n  return find(entity.fieldInstances, fieldKey)?.__value as T | undefined;\n}\n\nfunction getPrereqs(entity: EntityData) {\n  const raw = getField<EntityRef[]>(entity, \"prerequisites\") || [];\n  return raw.map((ref) => ref.entityIid);\n}\n\nfunction getInteractibleTrigger(entity: EntityData, entities: EntityData[]) {\n  const triggerId = getField<EntityRef>(entity, \"triggerArea\")?.entityIid;\n  const triggerArea = triggerId ? findByIid(entities, triggerId) : undefined;\n\n  return triggerArea\n    ? rectOfEntity(triggerArea)\n    : Rectangle.aroundPoint(\n        new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2),\n        2,\n        2\n      );\n}\n\nfunction entityToPos(entity: EntityData) {\n  return Vector.scale(new Vector(...entity.px), 1 / PIXELS_PER_TILE);\n}\n\nfunction createPuzzle(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  const key = getField<string>(entity, \"key\");\n  if (!key) {\n    console.warn(\"Puzzle with no key!\");\n  }\n  const center = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  const config = {\n    isFlipped: getField<boolean>(entity, \"isFlipped\"),\n  };\n\n  return new PuzzleInteractible(\n    id,\n    center,\n    getInteractibleTrigger(entity, entities),\n    getPrereqs(entity),\n    key!,\n    config\n  );\n}\n\nfunction createSwitch(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Switch with no key!\");\n  }\n  const center = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  return new SwitchInteractible(\n    id,\n    center,\n    getInteractibleTrigger(entity, entities),\n    getPrereqs(entity)\n  );\n}\n\nfunction createDoor(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Door with no key!\");\n  }\n  const door = Vector.add(entityToPos(entity), new Vector(2, 2));\n  return new DoorInteractible(\n    id,\n    door,\n    getPrereqs(entity),\n    pxToTile(entity.height)\n  );\n}\n\nfunction createTrapdoor(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Trapdoor with no key!\");\n  }\n  const pos = entityToPos(entity);\n  const config = {\n    isFlipped: getField<boolean>(entity, \"isFlipped\"),\n    hasLedge: getField<boolean>(entity, \"hasLedge\"),\n    isSingle: getField<boolean>(entity, \"isSingle\"),\n  };\n  return new TrapdoorInteractible(\n    id,\n    pos,\n    getPrereqs(entity),\n    pxToTile(entity.width),\n    config\n  );\n}\n\nconst rectOfEntity = (entity: EntityData) => {\n  return Rectangle.widthForm(\n    toTile(entity.px[0]),\n    toTile(entity.px[1]),\n    pxToTile(entity.width),\n    pxToTile(entity.height)\n  );\n};\n\nfunction isDefined<T>(value: T | undefined): value is T {\n  return !!value;\n}\n\nfunction createCoverEntity(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"CoverEntity with no key!\");\n  }\n  const triggerId = getField<EntityRef>(entity, \"triggerArea\")?.entityIid;\n  const trigger = findByIid(entities, triggerId) || entity;\n\n  const extraField = getField<EntityRef[]>(entity, \"extraCover\") || [];\n  const extraCovers = extraField\n    .map((ref) => findByIid(entities, ref.entityIid))\n    .filter(isDefined)\n    .map(rectOfEntity);\n\n  const config = {\n    coverIsTrigger: getField<boolean>(entity, \"coverIsTrigger\"),\n    canReCover: getField<boolean>(entity, \"canReCover\"),\n  };\n\n  return new CoverEntity(\n    id,\n    rectOfEntity(entity),\n    extraCovers,\n    rectOfEntity(trigger),\n    config\n  );\n}\n\nfunction createDecoration(entity: EntityData) {\n  return new DecorationEntity(\n    entity.iid,\n    entityToPos(entity),\n    pxToTile(entity.width),\n    pxToTile(entity.height),\n    new Vector(entity.__tile.x, entity.__tile.y),\n    entity.__tile.w,\n    entity.__tile.h,\n    entity.__tags\n  );\n}\n\nfunction createNode(entity: EntityData) {\n  const id = entity.iid;\n  const key = getField<string>(entity, \"key\");\n  const prereqs = getPrereqs(entity);\n  if (!key && !prereqs.length) {\n    console.warn(\"Node with no key or prerequisites!\");\n  }\n\n  return new NodeInteractible(\n    id,\n    rectOfEntity(entity).midpoint,\n    prereqs,\n    key!\n  );\n}\n\nfunction createPortal(entity: EntityData) {\n  const id = entity.iid;\n\n  return new PortalInteractible(\n    id,\n    new Vector(toTile(entity.px[0]), toTile(entity.px[1])),\n    getPrereqs(entity)\n  );\n}\n\nfunction firstPass(level: LevelData): LevelFactory {\n  const factory = new LevelFactory(\n    level.identifier,\n    level.iid,\n    pxToTile(level.pxWid),\n    pxToTile(level.pxHei),\n    level.__bgColor\n  );\n  factory.makeGridSpace();\n  const solidLayer = findLayer(level, \"Solid\")!;\n  for (const cell of solidLayer.gridTiles) {\n    const col = pxToTile(cell.px[0]);\n    const row = pxToTile(cell.px[1]);\n    const blockType = srcToBlockType(cell.src);\n\n    factory.setCell(row, col, blockType);\n  }\n\n  let setStartPos = false;\n  const entityLayer = findLayer(level, \"EntityLayer\")!;\n\n  const entities = entityLayer.entityInstances;\n  entities.forEach((entity) => {\n    switch (entity.__identifier) {\n      case \"Util\":\n        break;\n      case \"PlayerStart\":\n        factory.setPlayerPos(new Vector(entity.__grid[0], entity.__grid[1]));\n        setStartPos = true;\n        break;\n      case \"PuzzleScreen\":\n        const key = getField<string>(entity, \"key\");\n        if (!key) {\n          console.warn(\"Puzzle with unknown id in:\", level.identifier);\n        }\n        factory.addInteractibles([createPuzzle(entity, entities)]);\n        break;\n      case \"Switch\":\n        factory.addInteractibles([createSwitch(entity, entities)]);\n        break;\n      case \"Door\":\n        factory.addInteractibles([createDoor(entity)]);\n        break;\n      case \"Trapdoor\":\n        factory.addInteractibles([createTrapdoor(entity)]);\n        break;\n      case \"CoverEntity\":\n        factory.addEntities([createCoverEntity(entity, entities)]);\n        break;\n      case \"Node\":\n        factory.addInteractibles([createNode(entity)]);\n        break;\n      case \"Portal\":\n        factory.addInteractibles([createPortal(entity)]);\n        break;\n      default:\n        console.warn(\"Processing unknown entity type:\", entity.__identifier);\n    }\n  });\n\n  const decors = findLayer(level, \"Decorations\")?.entityInstances;\n  if (decors) {\n    factory.addEntities(decors.map(createDecoration));\n  }\n\n  if (!setStartPos) {\n    console.warn(`Level ${level.identifier} is missing a PlayerStart`);\n  }\n\n  factory.setWorldPosition(\n    new Vector(pxToTile(level.worldX), pxToTile(level.worldY))\n  );\n\n  return factory;\n}\n\nfunction secondPass(level: LevelData, others: Record<string, LevelFactory>) {\n  const factory = others[level.iid];\n  for (const neighbourInfo of level.__neighbours) {\n    const nId = neighbourInfo.levelIid;\n    const neighbour = others[nId];\n    const topLeft = Vector.diff(neighbour.worldPosition, factory.worldPosition);\n    const nextCollider = Rectangle.widthForm(\n      topLeft.x,\n      topLeft.y,\n      neighbour.width,\n      neighbour.height\n    );\n    factory.addExits([\n      new ExitTrigger(nextCollider, neighbour.key, nextCollider),\n    ]);\n  }\n\n  return factory.create();\n}\n\ninterface RawPuzzles {\n  puzzlesGrouping: any[],\n  puzzlesByLevel: {\n    [levelName: string]: {\n      [groupName: string]: Record<string, PuzzleRules>;\n    };\n  };\n}\n\nfunction buildGrouping(items: any): Grouping {\n  if (typeof items === \"string\") {\n    return {\n      isLeaf: true,\n      puzzle: PuzzleManager.getPuzzle(items),\n      isAllSolved: false,\n    };\n  } else if (Array.isArray(items)) {\n    return {\n      isLeaf: false,\n      isAllSolved: false,\n      children: items.map(buildGrouping),\n    };\n  } else if (typeof items === \"object\") {\n    const isLeaf = typeof items.children === \"string\";\n    if (isLeaf) {\n      return {\n        isLeaf,\n        puzzle: PuzzleManager.getPuzzle(items.children),\n        isAllSolved: false,\n        display: items.icon,\n      };\n    } else {\n      return {\n        isLeaf,\n        isAllSolved: false,\n        children: items.children.map(buildGrouping),\n        display: items.icon,\n      };\n    }\n  }\n\n  throw Error(`Building grouping from invalid items: ${JSON.stringify(items)}`);\n}\n\nexport class DataLoader {\n  static hasLoaded = false;\n  static data: WorldData | null = null;\n  static levelMap: Record<string, Level> = {};\n  static puzzles: Record<string, PuzzleRules> = {};\n  static keyGrouping: Grouping;\n\n  static async fetchPuzzles() {\n    const rawPuzzles = await loadJson<RawPuzzles>(PUZZLE_DATA_URL);\n\n    const { puzzlesByLevel, puzzlesGrouping } = rawPuzzles;\n    const allPuzzles: Record<string, PuzzleRules> = {};\n\n    for (const level of Object.values(puzzlesByLevel)) {\n      for (const group of Object.values(level)) {\n        Object.assign(allPuzzles, group);\n      }\n    }\n\n    DataLoader.puzzles = allPuzzles;\n\n    for (const puzzleId of Object.keys(allPuzzles)) {\n      PuzzleManager.insertPuzzle(puzzleId, allPuzzles[puzzleId]);\n    }\n\n    // .puzzles is available enough for PuzzleManager to work\n    this.keyGrouping = buildGrouping(puzzlesGrouping);\n  }\n\n  static async fetchWorld() {\n    const data = await loadJson<WorldData>(LEVEL_DATA_URL);\n    DataLoader.data = data;\n\n    const basicMap: Record<string, LevelFactory> = {};\n\n    data.levels.forEach((level) => {\n      const basicData = firstPass(level);\n      basicMap[basicData.iid] = basicData;\n      basicMap[basicData.key] = basicData;\n    });\n\n    data.levels.forEach((rawLevel) => {\n      const level = secondPass(rawLevel, basicMap);\n      DataLoader.levelMap[level.key] = level;\n    });\n  }\n\n  static async start() {\n    await Promise.all([DataLoader.fetchPuzzles(), DataLoader.fetchWorld()]);\n  }\n\n  static getLevel(key: string) {\n    return DataLoader.levelMap[key];\n  }\n}\n", "import { InputEvent, InputManager } from \"./InputManager\";\nimport { GameModeManagerEssentials, ScreenManagerEssentials } from \"./types\";\n\nconst MAX_FRAME_TIME = 1 / 20;\n\n/**\n * The head owner of everything.\n */\nexport class AppCore<Screen extends ScreenManagerEssentials> {\n  screenManager: Screen;\n  gameModeManager: GameModeManagerEssentials<Screen>;\n  inputManager: InputManager;\n\n  lastFrameTime: number;\n\n  constructor(screenManager: Screen, gameModeManager: GameModeManagerEssentials<Screen>, inputManager: InputManager) {\n    this.screenManager = screenManager;\n    this.gameModeManager = gameModeManager;\n    this.inputManager = inputManager;\n\n    this.inputManager.setListener((input) => this.onInput(input));\n\n    this.lastFrameTime = performance.now();\n  }\n\n  start() {\n    this.inputManager.init();\n    this.lastFrameTime = performance.now();\n    requestAnimationFrame(() => this.mainLoop());\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.gameModeManager.onInput(input);\n  }\n\n  mainLoop() {\n    const now = performance.now();\n    const deltaTime = Math.min(\n      (now - this.lastFrameTime) / 1000,\n      MAX_FRAME_TIME\n    );\n    // Do stuff\n    this.gameModeManager.update(deltaTime, this.inputManager.getInputState());\n    this.gameModeManager.draw(this.screenManager);\n    this.screenManager.drawToScreen();\n\n    // Loop\n    requestAnimationFrame(() => this.mainLoop());\n    this.lastFrameTime = now;\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { Puzzle } from \"../puzzle-manager/Puzzle\";\n\nexport function distributeGrid(container: Rectangle, rows: number, columns: number, margin = 0.2): Rectangle[][] {\n  const spaceWidth = container.width;\n  const spaceHeight = container.height;\n\n  function spaceForN(n: number) {\n    return (1 + margin) * n - margin;\n  }\n\n  function offsetForN(n: number) {\n    return n * (1 + margin);\n  }\n\n  const boxSize = Math.min(spaceWidth / spaceForN(columns), spaceHeight / spaceForN(rows));\n\n  const innerContainer = Rectangle.centerForm(\n    container.midpoint.x,\n    container.midpoint.y,\n    (boxSize * spaceForN(columns)) / 2,\n    (boxSize * spaceForN(rows)) / 2,\n  );\n\n  const grid = [];\n\n  for (let i = 0; i < rows; i++) {\n    const row = [];\n    for (let j = 0; j < columns; j++) {\n      row.push(Rectangle.widthForm(\n        boxSize * offsetForN(j) + innerContainer.x1,\n        boxSize * offsetForN(i) + innerContainer.y1,\n        boxSize,\n        boxSize,\n      ));\n    }\n    grid.push(row);\n  }\n\n  return grid;\n}\n\nexport function distributeShapesSquare(container: Rectangle, numPuzzles: number, margin: number): Rectangle[] {\n  const cols = Math.ceil(Math.sqrt(numPuzzles));\n  const rows = Math.ceil(numPuzzles / cols);\n\n  return distributeGrid(container, rows, cols, margin).flat().slice(0, numPuzzles);\n}\n\nexport function distributeRectangles(container: Rectangle, numPuzzles: number, margin = 0.5): Rectangle[] {\n  const scale = Math.floor(Math.sqrt(numPuzzles));\n\n  const rows = Math.ceil(numPuzzles / scale);\n  const columns = scale;\n\n  const spaceWidth = container.width;\n  const spaceHeight = container.height;\n\n  function spaceForN(n: number) {\n    return (1 + margin) * n - margin;\n  }\n\n  function offsetForN(n: number) {\n    return n * (1 + margin);\n  }\n\n  const boxSize = Math.min(spaceWidth / spaceForN(columns), spaceHeight / spaceForN(rows));\n\n  const innerContainer = Rectangle.centerForm(\n    container.midpoint.x,\n    container.midpoint.y,\n    (boxSize * spaceForN(columns)) / 2,\n    (boxSize * spaceForN(rows)) / 2,\n  );\n\n  const shapes = [];\n\n  for (let i = 0; i < numPuzzles; i++) {\n    const row = Math.floor(i / columns);\n    const column = i % columns;\n\n    shapes.push(Rectangle.widthForm(\n      boxSize * offsetForN(column) + innerContainer.x1,\n      boxSize * offsetForN(row) + innerContainer.y1,\n      boxSize,\n      boxSize,\n    ));\n  }\n\n  return shapes;\n}\n\nexport function drawInnerPuzzle(canvas: Canvas, box: Rectangle, puzzle: Puzzle) {\n  const SCREEN_W = box.width / 2;\n\n  const offset = new Vector(\n    box.midpoint.x - SCREEN_W,\n    box.midpoint.y - SCREEN_W\n  );\n\n  canvas.translate(offset.x, offset.y);\n\n  canvas.setColor(\"white\");\n\n\n  // Draw current selection\n  const grid = puzzle.grid;\n  const SCREEN_PIXEL =\n    (SCREEN_W * 2) / (3 * Math.max(grid.length, grid[0].length) + 1);\n  const SCR_WIDTH = SCREEN_PIXEL * (3 * grid[0].length + 1);\n  const SCR_HEIGHT = SCREEN_PIXEL * (3 * grid.length + 1);\n\n  const TOP_PAD = Math.max(0, (SCR_WIDTH - SCR_HEIGHT) / 2);\n  const LEFT_PAD = Math.max(0, (SCR_HEIGHT - SCR_WIDTH) / 2);\n\n  puzzle.miniElements.forEach(({ row, col, shape }) => {\n    if (puzzle.values[grid[row][col].id]) {\n      const x0 = LEFT_PAD + SCREEN_PIXEL * (3 * shape.x1 + 1);\n      const y0 = TOP_PAD + SCREEN_PIXEL * (3 * shape.y1 + 1);\n      const w = SCREEN_PIXEL * (3 * shape.width - 1);\n      const h = SCREEN_PIXEL * (3 * shape.height - 1);\n      canvas.fillRect(x0, y0, w, h);\n    }\n  });\n\n  canvas.translate(-offset.x, -offset.y);\n}\n", "import { Canvas } from \"../Canvas\";\nimport { ClickEvent, InputEvent, InputState } from \"../InputManager\";\n\nimport { SimpleGameManager } from \"../apps/SimpleGameManager\";\nimport { SimpleScreen } from \"../apps/SimpleScreen\";\nimport { SQUARE_CANVAS_SIZE, UI_PIXEL_WIDTH } from \"../constants/ScreenConstants\";\nimport { DataLoader } from \"../level/DataLoader\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport {\n  DEFAULT_BACKGROUND,\n  GROUP_DEFAULT_BACKGROUND,\n  GROUP_SOLVED_BACKGROUND,\n  ICON_SHAPES,\n  N_CIRCLE_LAYOUT,\n  N_SQUARE_LAYOUT,\n  PUZZLE_WINDOW_WIDTH,\n  SOLVED_BACKGROUND,\n} from \"../puzzle-manager/constants\";\nimport { PuzzleManager } from \"../puzzle-manager/PuzzleManager\";\nimport { Puzzle } from \"../puzzle-manager/Puzzle\";\nimport { Grouping, Mode } from \"../types\";\n\nimport { distributeRectangles, drawInnerPuzzle } from \"./utils\";\n\nfunction zip<A, B>(as: A[], bs: B[]): [A, B][] {\n  return as.map((a, index) => [a, bs[index]]);\n}\n\ninterface OptionCore {\n  isHovered: boolean;\n  box: Rectangle;\n}\n\ninterface LeafOption extends OptionCore {\n  puzzle: Puzzle;\n  display?: string;\n}\n\ninterface BackOption extends OptionCore {\n  action: \"back\";\n}\n\ninterface SubgroupOption extends OptionCore {\n  action: \"subgroup\";\n  innerGrouping: Grouping;\n  childRects: Rectangle[];\n  display?: string;\n}\n\ntype PuzzleOption = LeafOption | BackOption | SubgroupOption;\n\nfunction isLeaf(option: PuzzleOption): option is LeafOption {\n  return \"puzzle\" in option;\n}\n\nfunction isBack(option: PuzzleOption): option is BackOption {\n  return \"action\" in option && option.action === \"back\";\n}\n\nfunction isSubgroup(option: PuzzleOption): option is SubgroupOption {\n  return \"action\" in option && option.action === \"subgroup\";\n}\n\nconst ON_SCREEN_RECTANGLE = Rectangle.centerForm(\n  SQUARE_CANVAS_SIZE / 2,\n  SQUARE_CANVAS_SIZE / 2,\n  PUZZLE_WINDOW_WIDTH / 2,\n  PUZZLE_WINDOW_WIDTH / 2,\n);\n\nfunction placeGrouping(grouping: Grouping, hasBackOption: boolean): PuzzleOption[] {\n  if (!grouping.children?.length || grouping.isLeaf) {\n    throw Error(\"Drawing leaf to the screen\");\n  }\n\n  const rectangles = distributeRectangles(ON_SCREEN_RECTANGLE, grouping.children.length);\n\n  const options: PuzzleOption[] = [];\n\n  for (const [child, rect] of zip(grouping.children, rectangles)) {\n    if (child.isLeaf) {\n      options.push({\n        box: rect,\n        isHovered: false,\n        puzzle: child.puzzle!,\n        display: child.display,\n      });\n    } else {\n      options.push({\n        box: rect,\n        isHovered: false,\n        action: 'subgroup',\n        innerGrouping: child,\n        childRects: distributeRectangles(rect.inset(rect.width / 10), child.children?.length ?? 0),\n        display: child.display,\n      });\n    }\n  }\n\n  if (hasBackOption) {\n    options.push({\n      box: new Rectangle(\n        0,\n        0,\n        (SQUARE_CANVAS_SIZE - PUZZLE_WINDOW_WIDTH) / 2,\n        (SQUARE_CANVAS_SIZE - PUZZLE_WINDOW_WIDTH) / 2,\n      ),\n      isHovered: false,\n      action: 'back',\n    });\n  }\n\n  return options;\n}\n\nexport class PuzzleMode implements Mode<SimpleScreen> {\n  gameModeManager: SimpleGameManager;\n  puzzleManager: typeof PuzzleManager;\n\n  currentPuzzle: Puzzle | undefined;\n\n  shapes: PuzzleOption[];\n\n  viewDirty: boolean = true;\n\n  overallGrouping: Grouping;\n  groupStack: Grouping[];\n\n  constructor(gameModeManager: SimpleGameManager) {\n    this.gameModeManager = gameModeManager;\n\n    this.puzzleManager = PuzzleManager;\n\n    this.overallGrouping = DataLoader.keyGrouping;\n\n    this.groupStack = [this.overallGrouping];\n\n    this.shapes = placeGrouping(this.overallGrouping, false);\n  }\n\n  onStart() {\n    // Do nothing\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {object} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    if (this.currentPuzzle) {\n      this.currentPuzzle.update(deltaTime, inputState);\n    } else {\n      for (const shape of this.shapes) {\n        const isHovered = shape.box.intersectsPoint(inputState.mousePosition);\n        if (isHovered !== shape.isHovered) {\n          this.viewDirty = true;\n          shape.isHovered = isHovered;\n        }\n      }\n    }\n  }\n\n  dismissCurrentPuzzle() {\n    if (!this.currentPuzzle) {\n      return;\n    }\n\n    this.viewDirty = true;\n\n    for (const stackLevel of this.groupStack.slice().reverse()) {\n      let allGood = true;\n      for (const child of stackLevel.children ?? []) {\n        if (child.isAllSolved || (child.puzzle?.isSolved)) {\n          //\n        } else {\n          allGood = false;\n        }\n      }\n      if (allGood) {\n        stackLevel.isAllSolved = true;\n      } else {\n        break;\n      }\n    }\n\n    this.currentPuzzle = undefined;\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (this.currentPuzzle) {\n      if (input.isClick()) {\n        const click = input as ClickEvent;\n        if (!ON_SCREEN_RECTANGLE.intersectsPoint(click.position)) {\n          this.dismissCurrentPuzzle();\n          return;\n        }\n      }\n      this.currentPuzzle.onInput(input);\n    } else {\n      if (input.isClick()) {\n        const click = input as ClickEvent;\n        for (const shape of this.shapes) {\n          if (shape.box.intersectsPoint(click.position)) {\n            if (isBack(shape) && this.groupStack.length > 1) {\n              this.goBackOneLevel();\n              return;\n            } else if (isSubgroup(shape)) {\n              this.groupStack.push(shape.innerGrouping);\n              this.shapes = placeGrouping(shape.innerGrouping, true);\n              this.viewDirty = true;\n              return;\n            } else if (isLeaf(shape)) {\n              this.currentPuzzle = shape.puzzle;\n              this.currentPuzzle.open(1);\n              return;\n            }\n          }\n        }\n        if (!ON_SCREEN_RECTANGLE.intersectsPoint(click.position)) {\n          this.goBackOneLevel();\n          return;\n        }\n      }\n    }\n  }\n\n  clickedOutside() {\n    if (this.currentPuzzle) {\n      this.dismissCurrentPuzzle();\n    } else {\n      this.goBackOneLevel();\n    }\n  }\n\n  goBackOneLevel() {\n    if (this.groupStack.length <= 1) {\n      return;\n    }\n\n    this.groupStack.splice(this.groupStack.length - 1, 1);\n    this.shapes = placeGrouping(this.groupStack[this.groupStack.length - 1], this.groupStack.length > 1);\n    this.viewDirty = true;\n  }\n\n  drawDisplayOption(uiCanvas: Canvas, box: Rectangle, display: string): boolean {\n    if (display in ICON_SHAPES) {\n      const shapes = ICON_SHAPES[display];\n\n      uiCanvas.setColor(\"white\");\n      for (const shape of shapes) {\n        if (shape instanceof Circle) {\n          const pos = Vector.add(\n            box.midpoint,\n            Vector.scale(shape.position, box.width / 2),\n          );\n          const newCircle = new Circle(pos, shape.radius * box.width / 2);\n          newCircle.draw(uiCanvas);\n        } else if (shape instanceof Rectangle) {\n          const pos = Vector.add(\n            box.midpoint,\n            Vector.scale(shape.midpoint, box.width / 2),\n          );\n          const newSquare = Rectangle.centerForm(pos.x, pos.y, shape.width * box.width / 4, shape.height * box.width / 4);\n\n          newSquare.draw(uiCanvas);\n        }\n      }\n\n      return true;\n    }\n    if (display.match(/circle\\-\\d+/)) {\n      const n = parseInt(display.slice(7), 10);\n\n      if (0 <= n && n <= 8) {\n        uiCanvas.setColor(\"white\");\n        for (const circle of N_CIRCLE_LAYOUT[n]) {\n          const pos = Vector.add(\n            box.midpoint,\n            Vector.scale(circle.position, box.width / 2),\n          );\n          const newCircle = new Circle(pos, circle.radius * box.width / 2);\n          if (n === 0) {\n            uiCanvas.setLineWidth(circle.radius * box.width / 2);\n            uiCanvas.strokeEllipse(\n              box.midpoint.x,\n              box.midpoint.y,\n              circle.radius * box.width * 0.75,\n              circle.radius * box.width * 0.75\n            );\n          } else {\n            newCircle.draw(uiCanvas);\n          }\n        }\n        return true;\n      }\n    } else if (display.match(/square\\-\\d+/)) {\n      const n = parseInt(display.slice(7), 10);\n\n      if (0 <= n && n <= 8) {\n        uiCanvas.setColor(\"white\");\n        for (const square of N_SQUARE_LAYOUT[n]) {\n          const pos = Vector.add(\n            box.midpoint,\n            Vector.scale(square.midpoint, box.width / 2),\n          );\n          const newSquare = Rectangle.centerForm(pos.x, pos.y, square.width * box.width / 4, square.width * box.width / 4);\n\n          newSquare.draw(uiCanvas);\n        }\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  drawGroupShapeContents(uiCanvas: Canvas, shape: SubgroupOption) {\n    if (shape.display) {\n      const drawn = this.drawDisplayOption(uiCanvas, shape.box, shape.display);\n\n      if (drawn) {\n        return;\n      }\n    }\n\n    for (const [rect, child] of zip(shape.childRects, shape.innerGrouping.children!)) {\n      uiCanvas.setColor(\n        child.isLeaf\n          ? child.puzzle?.isSolved\n            ? SOLVED_BACKGROUND\n            : DEFAULT_BACKGROUND\n          : child.isAllSolved\n            ? SOLVED_BACKGROUND\n            : DEFAULT_BACKGROUND,\n      );\n      rect.draw(uiCanvas);\n    }\n  }\n\n  drawPuzzleShapeContents(uiCanvas: Canvas, shape: LeafOption) {\n    if (shape.display) {\n      const drawn = this.drawDisplayOption(uiCanvas, shape.box, shape.display);\n\n      if (drawn) {\n        return;\n      }\n    }\n    drawInnerPuzzle(uiCanvas, shape.box, shape.puzzle);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: SimpleScreen) {\n    // Draw background\n    screenManager.background.setColor(\"black\");\n    screenManager.background.fillRect(\n      0,\n      0,\n      screenManager.background.width,\n      screenManager.background.height,\n    );\n\n    // Draw puzzle if there is one\n    if (this.currentPuzzle) {\n      this.currentPuzzle.draw(screenManager, true);\n    } else {\n      if (!this.viewDirty) {\n        return;\n      }\n\n      const uiCanvas = screenManager.uiCanvas;\n      uiCanvas.clear();\n\n      for (const shape of this.shapes) {\n        if (isLeaf(shape)) {\n          uiCanvas.setColor(shape.puzzle.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND);\n\n          shape.box.draw(uiCanvas);\n\n          this.drawPuzzleShapeContents(screenManager.uiCanvas, shape);\n        } else if (isBack(shape)) {\n          uiCanvas.setColor(\"white\");\n\n          shape.box.draw(uiCanvas);\n\n          uiCanvas.setColor(\"black\");\n          uiCanvas.setLineWidth(UI_PIXEL_WIDTH * 2);\n          uiCanvas.setLineDash([]);\n          const crossArea = shape.box.inset(shape.box.width / 5);\n          const crossMid = crossArea.midpoint;\n          uiCanvas.drawLine(crossArea.x1, crossMid.y, crossArea.x2, crossMid.y);\n          uiCanvas.drawLine(crossArea.x1, crossMid.y, crossMid.x, crossArea.y1);\n          uiCanvas.drawLine(crossArea.x1, crossMid.y, crossMid.x, crossArea.y2);\n          uiCanvas.fillDiamond(crossArea.x1, crossMid.y, UI_PIXEL_WIDTH * Math.SQRT2, UI_PIXEL_WIDTH * Math.SQRT2);\n        } else if (isSubgroup(shape)) {\n          uiCanvas.setColor(shape.innerGrouping.isAllSolved ? GROUP_SOLVED_BACKGROUND : GROUP_DEFAULT_BACKGROUND);\n\n          shape.box.draw(uiCanvas);\n\n          this.drawGroupShapeContents(uiCanvas, shape);\n        }\n\n        if (shape.isHovered) {\n          uiCanvas.setLineWidth(shape.box.width * 0.05);\n          uiCanvas.setColor(\"white\");\n          const outset = shape.box;\n          uiCanvas.setLineDash([]);\n          uiCanvas.strokeRect(outset.x1, outset.y1, outset.width, outset.height);\n        }\n      }\n\n      this.viewDirty = false;\n    }\n  }\n}\n", "import { PuzzleMode } from \"../game-modes/PuzzleMode\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { GameModeManagerEssentials, Mode } from \"../types\";\nimport { SimpleScreen } from \"./SimpleScreen\";\n\nexport class SimpleGameManager implements GameModeManagerEssentials<SimpleScreen> {\n  puzzleMode: PuzzleMode;\n  // mapMode: MapMode;\n\n  currentMode: Mode<SimpleScreen>;\n\n  constructor() {\n    this.puzzleMode = new PuzzleMode(this);\n\n    // Probably needs to initially be a menu mode eventually, or some dev-mode tooling\n    this.currentMode = this.puzzleMode;\n    this.puzzleMode.onStart();\n  }\n\n  /**\n   * Update the current gamemode.\n   * @param {number} deltaTime The time that has elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentMode.update(deltaTime, inputState);\n  }\n\n  switchToMode(mode: Mode<SimpleScreen>) {\n    this.currentMode = mode;\n    mode.onStart();\n  }\n\n  /**\n   * Process an input event\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    let consumed = false;\n    if (this.currentMode === this.puzzleMode) {\n      // if (input.isForKey(Input.Map)) {\n      //   consumed = true;\n      //   this.switchToMode(this.mapMode);\n      // }\n    // } else if (this.currentMode === this.mapMode) {\n    //   if (input.isForKey(Input.Escape) || input.isForKey(Input.Map)) {\n    //     consumed = false;\n    //     this.switchToMode(this.playMode);\n    //   }\n    }\n\n    if (!consumed) {\n      this.currentMode.onInput(input);\n    }\n  }\n\n  /**\n   * Draw the current gamemode.\n   * @param {ScreenManager} screenManager The screenManager object.\n   */\n  draw(screenManager: SimpleScreen) {\n    this.currentMode.draw(screenManager);\n  }\n}\n", "import { sign } from \"./math/Common\";\nimport { hslaColor, rgbaColor } from \"./utils/Color\";\n\nconst CTX = Symbol(\"ctx\");\nconst CANVAS = Symbol(\"canvas\");\n\nexport class Canvas {\n  [CANVAS]: HTMLCanvasElement;\n  [CTX]: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this[CANVAS] = canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      throw Error(\"Unable to get 2d context\");\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    this[CTX] = ctx;\n\n    this[CTX].fillStyle = \"black\";\n    this[CTX].strokeStyle = \"black\";\n\n    this.width = this[CANVAS].width;\n    this.height = this[CANVAS].height;\n  }\n\n  /**\n   * Fill a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  fillRect(x: number, y: number, width: number, height: number) {\n    this[CTX].fillRect(x, y, width, height);\n  }\n\n  clear() {\n    this[CTX].clearRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Draw the outline of a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  strokeRect(x: number, y: number, width: number, height: number) {\n    this[CTX].strokeRect(x, y, width, height);\n  }\n\n  strokeRectInset(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    inset: number\n  ) {\n    this.strokeRect(\n      x + inset,\n      y + inset,\n      width - inset * 2,\n      height - inset * 2\n    );\n  }\n\n  /**\n   * Fill an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  fillEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].fill();\n  }\n\n  fillTriangle(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y + height);\n    this[CTX].lineTo(x + width, y + height);\n    this[CTX].lineTo(x + width / 2, y);\n    this[CTX].fill();\n  }\n\n  /**\n   * Outline an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  strokeEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].stroke();\n  }\n\n  fillDiamond(x: number, y: number, xRadius: number, yRadius: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y - yRadius);\n    this[CTX].lineTo(x + xRadius, y);\n    this[CTX].lineTo(x, y + yRadius);\n    this[CTX].lineTo(x - xRadius, y);\n    this[CTX].lineTo(x, y - yRadius);\n    this[CTX].fill();\n  }\n\n  outerCircleCorner(x: number, y: number, radius: number, startAngle: number) {\n    this[CTX].beginPath();\n    this[CTX].arc(x, y, radius, startAngle, startAngle + Math.PI / 2);\n    const toPoint = startAngle + Math.PI / 4;\n    this[CTX].lineTo(\n      x + sign(Math.cos(toPoint)) * radius,\n      y + sign(Math.sin(toPoint)) * radius\n    );\n    this[CTX].fill();\n  }\n\n  /**\n   * Draw a line on the canvas.\n   * @param {number} x0 The start x position\n   * @param {number} y0 The start y position\n   * @param {number} x1 The end x position\n   * @param {number} y1 The start y position\n   */\n  drawLine(x0: number, y0: number, x1: number, y1: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].lineTo(x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Draw a quadratic bezier curve on the canvas.\n   * @param {*} x0 The starting x position\n   * @param {*} y0 The starting y position\n   * @param {*} x1 The ending x position\n   * @param {*} y1 The ending y position\n   * @param {*} xControl The control point x position\n   * @param {*} yControl The control point y position\n   */\n  drawQuadratic(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    xControl: number,\n    yControl: number\n  ) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].quadraticCurveTo(xControl, yControl, x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Scale the canvas.\n   * @param {number} xScale\n   * @param {number} yScale\n   */\n  scale(xScale: number, yScale: number) {\n    this[CTX].scale(xScale, yScale);\n  }\n\n  /**\n   * Translate the canvas.\n   * @param {number} xOffset\n   * @param {number} yOffset\n   */\n  translate(xOffset: number, yOffset: number) {\n    this[CTX].translate(xOffset, yOffset);\n  }\n\n  setLineWidth(width: number) {\n    this[CTX].lineWidth = width;\n  }\n\n  get lineWidth() {\n    return this[CTX].lineWidth;\n  }\n\n  setLineDash(pattern: number[]) {\n    this[CTX].setLineDash(pattern);\n  }\n\n  /**\n   * Set the colour to be used for drawing on the canvas.\n   * @param {string} colorString The name of the color to be used\n   */\n  setColor(colorString: CanvasRenderingContext2D[\"fillStyle\"]) {\n    if (colorString === this[CTX].fillStyle) {\n      return;\n    }\n\n    this[CTX].fillStyle = colorString;\n    this[CTX].strokeStyle = colorString;\n  }\n\n  /**\n   * Set the current color via RGB.\n   * @param {number} red Red value from 0-255\n   * @param {number} green Green value from 0-255\n   * @param {number} blue Blue value from 0-255\n   * @param {number | undefined} alpha Alpha value from 0-255\n   */\n  setColorRGB(red: number, green: number, blue: number, alpha = 255) {\n    this.setColor(rgbaColor(red, green, blue, alpha));\n  }\n\n  /**\n   * Set the current color with hue, saturation, lightness and alpha.\n   * @param {number} hue Hue value from 0-359\n   * @param {number} saturation Saturation value from 0-1\n   * @param {number} lightness Lightness value from 0-1\n   * @param {number | undefined} alpha Alpha value from 0-1\n   */\n  setColorHSLA(hue: number, saturation: number, lightness: number, alpha = 1) {\n    this.setColor(hslaColor(hue, saturation, lightness, alpha));\n  }\n\n  createGradient(x0: number, y0: number, x1: number, y1: number) {\n    return this[CTX].createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(\n    x0: number,\n    y0: number,\n    r0: number,\n    x1: number,\n    y1: number,\n    r1: number\n  ) {\n    return this[CTX].createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  saveTransform() {\n    this[CTX].save();\n  }\n\n  restoreTransform() {\n    this[CTX].restore();\n  }\n\n  /**\n   * Draw another image to this canvas\n   * @param {Canvas} imageSource\n   * @param {number} sourceX\n   * @param {number} sourceY\n   * @param {number} sourceWidth\n   * @param {number} sourceHeight\n   * @param {number} destinationX\n   * @param {number} destinationY\n   * @param {number} destinationWidth\n   * @param {nubmer} destinationHeight\n   */\n  drawImage(\n    imageSource: Canvas | HTMLImageElement,\n    sourceX: number,\n    sourceY: number,\n    sourceWidth: number,\n    sourceHeight: number,\n    destinationX: number,\n    destinationY: number,\n    destinationWidth: number,\n    destinationHeight: number\n  ) {\n    let image: CanvasImageSource;\n    if (imageSource instanceof Canvas) {\n      image = imageSource[CANVAS];\n    } else if (imageSource instanceof Image) {\n      if (!imageSource.complete) {\n        return;\n      }\n      image = imageSource;\n    } else {\n      throw Error(\"Drawing something unmanageable\");\n    }\n\n    this[CTX].drawImage(\n      image,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destinationX,\n      destinationY,\n      destinationWidth,\n      destinationHeight\n    );\n  }\n\n  /**\n   * Create a Canvas from an id.\n   * @param {string} id The id attribute of the HTMLCanvasElement\n   */\n  static fromId(id: string) {\n    const canvas = document.getElementById(id);\n\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Could not find canvas with id: \"${id}\"`);\n    }\n\n    return new Canvas(canvas);\n  }\n\n  /**\n   * Create a new HTMLCanvasElement and use that as the basis for a Canvas.\n   */\n  static fromScratch(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n\n    return new Canvas(canvas);\n  }\n}\n", "import { SQUARE_CANVAS_SIZE } from \"../constants/ScreenConstants\";\n\nimport { Canvas } from \"../Canvas\";\n\nconst REAL_CANVAS = Symbol(\"real-canvas\");\n\nfunction getRawCanvas(): HTMLCanvasElement {\n  const rawCanvas = document.getElementById(\"canvas\");\n\n  if (!(rawCanvas instanceof HTMLCanvasElement)) {\n    throw new Error(\"Could not find canvas\");\n  }\n\n  rawCanvas.width = SQUARE_CANVAS_SIZE;\n  rawCanvas.height = SQUARE_CANVAS_SIZE;\n\n  return rawCanvas;\n}\n\nexport class SimpleScreen {\n  [REAL_CANVAS]: Canvas;\n  background: Canvas;\n  uiCanvas: Canvas;\n\n  constructor() {\n    const screenCanvas = new Canvas(getRawCanvas());\n\n    if (!(screenCanvas instanceof Canvas)) {\n      throw Error(\"No canvas found!\");\n    }\n\n    this[REAL_CANVAS] = screenCanvas;\n\n    this.background = Canvas.fromScratch(SQUARE_CANVAS_SIZE, SQUARE_CANVAS_SIZE);\n    this.uiCanvas = Canvas.fromScratch(\n      SQUARE_CANVAS_SIZE,\n      SQUARE_CANVAS_SIZE\n    );\n  }\n\n  drawCanvas(\n    canvas: Canvas,\n    width = SQUARE_CANVAS_SIZE,\n    height = SQUARE_CANVAS_SIZE\n  ) {\n    this[REAL_CANVAS].drawImage(\n      canvas,\n      0,\n      0,\n      width,\n      height,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n  }\n\n  drawToScreen() {\n    this.drawCanvas(this.background);\n    this.drawCanvas(this.uiCanvas);\n  }\n\n  static instance = null;\n  static getInstance() {\n    if (this.instance) {\n      return this.instance;\n    }\n\n    return new SimpleScreen();\n  }\n}\n", "import { DataLoader } from \"../level/DataLoader\";\n\nimport { AppCore } from \"../AppCore\";\nimport { InputManager } from \"../InputManager\";\nimport { SimpleGameManager } from \"./SimpleGameManager\";\nimport { SimpleScreen } from \"./SimpleScreen\";\n\n/**\n * The function used to kick off the whole app.\n */\nconst main = () => {\n  const loading = DataLoader.start();\n\n  loading.then(() => {\n    const gameManager = new SimpleGameManager();\n    const app = new AppCore(new SimpleScreen(), gameManager, new InputManager(() => undefined));\n\n    app.start();\n\n    (window as any).app = app;\n\n    const main = document.getElementById(\"main\");\n    if (main) {\n      main.addEventListener(\"click\", (e) => {\n        if (e.target === main) {\n          gameManager.puzzleMode.clickedOutside();\n        }\n      });\n    }\n  });\n};\n\nwindow.onload = () => {\n  main();\n};\n"],
  "mappings": "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",
  "names": ["IS_MOBILE", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "SQUARE_CANVAS_SIZE", "UI_CANVAS_WIDTH", "UI_CANVAS_HEIGHT", "UI_PIXEL_WIDTH", "clamp", "x", "low", "high", "sign", "Vector", "x", "y", "vector", "factor", "otherVector", "a", "b", "xDiff", "yDiff", "v1", "v2", "t", "Circle", "position", "radius", "otherCircle", "radiusSum", "Vector", "point", "rectangle", "closestX", "clamp", "closestY", "canvas", "Rectangle", "x1", "y1", "x2", "y2", "x", "y", "otherRectangle", "circle", "p0", "pToCenter", "distFromCenter", "circleDistToMyCenter", "horizontalDistance", "verticalDistance", "sign", "outset", "inset", "insetBy", "width", "height", "halfWidth", "halfHeight", "rectangles", "rect", "TileImage", "EntityImage", "DecorationImage", "BlockType", "blockType", "Entity", "id", "_level", "_player", "_deltaTime", "_screenManager", "_canvas", "AREA_DEBUG", "Interactible", "Entity", "id", "position", "triggerArea", "prerequisites", "level", "player", "_deltaTime", "_level", "_a", "i", "screenManager", "canvas", "prereq", "xDiff", "Vector", "mid", "control", "OPEN_CLOSE_DURATION", "DoorInteractible", "Interactible", "id", "position", "prerequisites", "height", "Vector", "Rectangle", "level", "player", "deltaTime", "motion", "clamp", "screenManager", "canvas", "h", "EntityImage", "OPEN_DURATION", "CLOSE_DURATION", "PUZZLE_WINDOW_WIDTH", "UI_CANVAS_HEIGHT", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "GROUP_SOLVED_BACKGROUND", "GROUP_DEFAULT_BACKGROUND", "N_CIRCLE_LAYOUT", "Circle", "Vector", "N_SQUARE_LAYOUT", "Rectangle", "k", "s", "t0", "t1", "ICON_SHAPES", "CACHE", "cacheKey", "rows", "cols", "leftCol", "produceObject", "LEFT_COL", "CELL_SIZE_FROM_COLS", "PUZZLE_WINDOW_WIDTH", "CELL_SIZE_FROM_ROWS", "CELL_SIZE", "BOTTOM_SIZE", "LEFT_SIZE", "WIDE_SIZE", "FULL_HEIGHT", "FULL_WIDTH", "TOP_EDGE", "LEFT_EDGE", "lastX", "xSpacing", "i", "lastY", "ySpacing", "matrix", "y1", "y2", "thisRow", "x1", "x2", "Rectangle", "getObject", "key", "positionGetter", "row", "col", "PARTIAL_RADIUS", "SPACE_DEBUG_DRAW", "Puzzle", "id", "rows", "columns", "validator", "config", "incId", "positionGetter", "item", "row", "currentRow", "col", "cell", "group", "groupId", "column", "cells", "Rectangle", "UI_PIXEL_WIDTH", "status", "screenManager", "pos", "slideInOffset", "Vector", "UI_CANVAS_HEIGHT", "puzzleScreenOffset", "PUZZLE_WINDOW_WIDTH", "hideMonitorLeg", "canvas", "offset", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "i", "j", "element", "cellState", "mid", "radius", "value", "left", "right", "elementState", "position", "foundElement", "deltaTime", "inputState", "OPEN_DURATION", "CLOSE_DURATION", "clamp", "input", "click", "clickPosition", "PuzzleValidator", "validationItems", "grid", "values", "item", "index", "total", "positionGetter", "leftColumn", "Rectangle", "width", "top", "i", "canvas", "args", "globals", "ValidationItem", "_grid", "_values", "_canvas", "_args", "CellValidation", "ValidationItem", "row", "column", "ForcedCellValidation", "mustBeOn", "grid", "values", "cell", "canvas", "positionGetter", "rect", "width", "center", "Vector", "CountInAreaValidation", "desiredCount", "col", "count", "seenIds", "SOLVED_BACKGROUND", "circle", "N_CIRCLE_LAYOUT", "position", "rotRight", "vector", "Vector", "EdgeValidationItem", "ValidationItem", "isRow", "index", "grid", "valueMap", "cells", "row", "values", "valuesSoFar", "lastId", "cell", "_row", "_canvas", "_center", "_scaleBy", "_isSideways", "canvas", "positionGetter", "EdgeCountValidationItem", "count", "soFar", "item", "center", "scaleBy", "isSideways", "transformCircle", "circle", "Circle", "v", "N_CIRCLE_LAYOUT", "position", "EdgeGroupsValidationItem", "numGroups", "inGroup", "width", "moveCenter", "pos", "square", "N_SQUARE_LAYOUT", "EdgeBlankGroupsValidationItem", "EdgeNoTripleValidationItem", "value", "center2", "center3", "radius", "GlobalValidationItem", "ValidationItem", "canvas", "rectangle", "GlobalCountValidationItem", "count", "_grid", "values", "val", "number", "center", "w", "squareSize", "radius", "l", "t", "row", "col", "cell", "halfWidth", "halfHeight", "midpoint", "Rectangle", "GlobalContinentValidationItem", "grid", "copiedGrid", "copiedRow", "queue", "minDim", "PuzzleValidatorFactory", "row", "column", "mustBeOn", "ForcedCellValidation", "count", "CountInAreaValidation", "nums", "isRow", "ValidationItemType", "EdgeCountValidationItem", "num", "index", "EdgeGroupsValidationItem", "EdgeBlankGroupsValidationItem", "yeses", "bool", "EdgeNoTripleValidationItem", "GlobalCountValidationItem", "GlobalContinentValidationItem", "PuzzleValidator", "initPuzzle", "id", "options", "rows", "cols", "config", "rules", "PuzzleValidatorFactory", "cell", "Puzzle", "makePuzzle", "id", "rules", "DataLoader", "initPuzzle", "PuzzleManagerInstance", "puzzle", "PuzzleManager", "PortalInteractible", "Interactible", "id", "position", "prereqs", "Rectangle", "Vector", "screenManager", "EntityImage", "player", "deltaTime", "level", "canvas", "primaryColor", "OpenMapEvent", "ToPortalEvent", "LevelEvent", "_playMode", "ExitEvent", "exitTrigger", "OpenPuzzleEvent", "puzzleId", "ClosePuzzleEvent", "OpenMapEvent", "portal", "level", "ToPortalEvent", "playMode", "currentPortal", "PortalInteractible", "SCREEN_W", "DRAW_CIRCLES", "PuzzleInteractible", "Interactible", "id", "position", "area", "prereqs", "puzzleId", "config", "Vector", "level", "PuzzleManager", "screenManager", "canvas", "PIXEL_SCALE", "isFlippedMul", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "offset", "grid", "SCREEN_PIXEL", "SCR_WIDTH", "SCR_HEIGHT", "TOP_PAD", "LEFT_PAD", "row", "col", "shape", "x0", "y0", "w", "h", "_a", "isSolved", "OpenPuzzleEvent", "SwitchInteractible", "Interactible", "id", "position", "area", "prerequisites", "player", "deltaTime", "level", "screenManager", "canvas", "PIXEL_SCALE", "EntityImage", "OPEN_CLOSE_DUR", "TrapdoorInteractible", "Interactible", "id", "position", "prerequisites", "width", "config", "Vector", "isDouble", "Rectangle", "level", "player", "deltaTime", "motion", "clamp", "screenManager", "canvas", "x", "TileImage", "w", "EntityImage", "ZERO", "toHex", "number", "digits", "rgbaColor", "red", "green", "blue", "alpha", "hslaColor", "hue", "saturation", "lightness", "rgbToHue", "r", "g", "b", "h", "min", "max", "fromHex", "hexColor", "hexToHue", "UNCOVER_DURATION", "CoverEntity", "Entity", "id", "coverArea", "extraCovers", "triggerArea", "config", "player", "cover", "level", "deltaTime", "isOpen", "clamp", "screenManager", "canvas", "size", "fadeRange", "pos", "Vector", "rOut", "gradient", "rgbaColor", "rect", "ExitTrigger", "collider", "key", "nextLevelCollider", "player", "Vector", "Up", "Down", "Left", "Right", "Jump", "Interact", "Escape", "Map", "Input", "KEY_MAP", "Input", "isTouchEvent", "event", "InputState", "keyMap", "mousePosition", "leftClicking", "rightClicking", "input", "Vector", "InputEvent", "_key", "KeyPressEvent", "key", "ClickEvent", "position", "isRightClick", "ScrollEvent", "delta", "discrete", "InputManager", "listener", "onKeyEvent", "symbol", "e", "IS_MOBILE", "_a", "_b", "isLeft", "isRight", "wireButton", "id", "btn", "UI_CANVAS_WIDTH", "ON_SCREEN_CANVAS_WIDTH", "BackgroundArtist", "width", "height", "bgColor", "hexToHue", "index", "screenManager", "xStep", "yStep", "col", "x", "row", "y", "Rectangle", "backColor", "foreColor", "action", "factor", "scale", "minSize", "Vector", "fullSize", "size", "canvas", "color", "hslaColor", "hue", "saturation", "lightness", "backgroundColor", "foregroundColor", "_row", "_col", "rect", "beamWidth", "yOffset", "_row2", "_col2", "rect2", "radius", "xs", "ys", "i", "back", "front", "_", "SCALE_FACTOR", "ON_SCREEN_RECTANGLE", "Rectangle", "PUZZLE_WINDOW_WIDTH", "UI_PIXEL_WIDTH", "Level", "key", "width", "height", "color", "levelGrid", "objects", "player", "exitTriggers", "interactibles", "entities", "worldPosition", "BackgroundArtist", "playModeManager", "i", "e", "object", "rect", "event", "previousPlayer", "previousExit", "position", "deltaTime", "inputState", "_a", "InputState", "interactible", "entity", "ClosePuzzleEvent", "Vector", "input", "isClick", "isInteractKey", "Input", "relevant", "triggeredExit", "trigger", "ExitEvent", "camera", "clampedToPlayer", "clamp", "canvas", "action", "row", "col", "blockType", "screenManager", "TileImage", "RectPoolClass", "row", "col", "isShort", "grid", "Rectangle", "RectPool", "PLAYER_RADIUS", "PLAYER_MAX_SPEED", "PLAYER_ACCEL", "PLAYER_DECEL", "TURN_SPEED", "JUMP_HEIGHT", "JUMP_DURATION", "PARAM_A", "JUMP_INITIAL_SPEED", "GRAVITY", "COYOTE_TIME", "CLIMB_MAX_SPEED", "isDefined", "value", "Player", "position", "Circle", "PLAYER_RADIUS", "Vector", "input", "Input", "type", "rect", "deltaTime", "isActiveLedge", "intersects", "BlockType", "collidingBy", "inputState", "level", "getCellAt", "x", "y", "_a", "getRectAt", "RectPool", "inputX", "inputY", "acceleration", "PLAYER_ACCEL", "playerBottom", "cellBelow", "groundingCellBelow", "gridCellWithin", "isGrounded", "hasLeftLadder", "updateSpeed", "vCurr", "decel", "sign", "TURN_SPEED", "PLAYER_DECEL", "ventMultiplier", "GRAVITY", "COYOTE_TIME", "JUMP_INITIAL_SPEED", "clamp", "CLIMB_MAX_SPEED", "PLAYER_MAX_SPEED", "step", "nearbyBlocks", "isDefined", "canvas", "LevelFactory", "key", "iid", "width", "height", "color", "Vector", "objects", "exits", "is", "es", "pos", "grid", "row", "vec", "col", "blockType", "Level", "Player", "DecorationEntity", "Entity", "id", "position", "width", "height", "tilesetPosition", "tilesetWidth", "tilesetHeight", "tags", "screenManager", "canvas", "DecorationImage", "bottom", "repeatingYSpace", "y", "h", "IS_MOBILE", "NodeInteractible", "Interactible", "id", "position", "prereqs", "puzzleId", "level", "PuzzleManager", "player", "deltaTime", "screenManager", "OpenPuzzleEvent", "LEVEL_DATA_URL", "PUZZLE_DATA_URL", "loadJson", "file", "data", "find", "list", "iden", "item", "findByIid", "iid", "findLayer", "level", "key", "pxToTile", "num", "toTile", "srcToBlockType", "src", "getField", "entity", "fieldKey", "_a", "getPrereqs", "ref", "getInteractibleTrigger", "entities", "triggerId", "triggerArea", "rectOfEntity", "Rectangle", "Vector", "entityToPos", "createPuzzle", "id", "center", "config", "PuzzleInteractible", "createSwitch", "SwitchInteractible", "createDoor", "door", "DoorInteractible", "createTrapdoor", "pos", "TrapdoorInteractible", "isDefined", "value", "createCoverEntity", "trigger", "extraCovers", "CoverEntity", "createDecoration", "DecorationEntity", "createNode", "prereqs", "NodeInteractible", "createPortal", "PortalInteractible", "firstPass", "factory", "LevelFactory", "solidLayer", "cell", "col", "row", "blockType", "setStartPos", "decors", "secondPass", "others", "neighbourInfo", "nId", "neighbour", "topLeft", "nextCollider", "ExitTrigger", "buildGrouping", "items", "PuzzleManager", "isLeaf", "_DataLoader", "rawPuzzles", "puzzlesByLevel", "puzzlesGrouping", "allPuzzles", "group", "puzzleId", "basicMap", "basicData", "rawLevel", "DataLoader", "MAX_FRAME_TIME", "AppCore", "screenManager", "gameModeManager", "inputManager", "input", "now", "deltaTime", "distributeRectangles", "container", "numPuzzles", "margin", "scale", "rows", "columns", "spaceWidth", "spaceHeight", "spaceForN", "n", "offsetForN", "boxSize", "innerContainer", "Rectangle", "shapes", "i", "row", "column", "drawInnerPuzzle", "canvas", "box", "puzzle", "SCREEN_W", "offset", "Vector", "grid", "SCREEN_PIXEL", "SCR_WIDTH", "SCR_HEIGHT", "TOP_PAD", "LEFT_PAD", "col", "shape", "x0", "y0", "w", "h", "zip", "as", "bs", "a", "index", "isLeaf", "option", "isBack", "isSubgroup", "ON_SCREEN_RECTANGLE", "Rectangle", "SQUARE_CANVAS_SIZE", "PUZZLE_WINDOW_WIDTH", "placeGrouping", "grouping", "hasBackOption", "_a", "_b", "_c", "rectangles", "distributeRectangles", "options", "child", "rect", "PuzzleMode", "gameModeManager", "PuzzleManager", "DataLoader", "deltaTime", "inputState", "shape", "isHovered", "stackLevel", "allGood", "input", "click", "uiCanvas", "box", "display", "ICON_SHAPES", "shapes", "Circle", "pos", "Vector", "n", "circle", "N_CIRCLE_LAYOUT", "newCircle", "square", "N_SQUARE_LAYOUT", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "drawInnerPuzzle", "screenManager", "UI_PIXEL_WIDTH", "crossArea", "crossMid", "GROUP_SOLVED_BACKGROUND", "GROUP_DEFAULT_BACKGROUND", "outset", "SimpleGameManager", "PuzzleMode", "deltaTime", "inputState", "mode", "input", "consumed", "screenManager", "CTX", "CANVAS", "_Canvas", "canvas", "ctx", "x", "y", "width", "height", "inset", "xRadius", "yRadius", "radius", "startAngle", "toPoint", "sign", "x0", "y0", "x1", "y1", "xControl", "yControl", "xScale", "yScale", "xOffset", "yOffset", "pattern", "colorString", "red", "green", "blue", "alpha", "rgbaColor", "hue", "saturation", "lightness", "hslaColor", "r0", "r1", "imageSource", "sourceX", "sourceY", "sourceWidth", "sourceHeight", "destinationX", "destinationY", "destinationWidth", "destinationHeight", "image", "id", "Canvas", "REAL_CANVAS", "getRawCanvas", "rawCanvas", "SQUARE_CANVAS_SIZE", "_SimpleScreen", "screenCanvas", "Canvas", "canvas", "width", "height", "SimpleScreen", "main", "DataLoader", "gameManager", "SimpleGameManager", "app", "AppCore", "SimpleScreen", "InputManager", "e"]
}
