{
  "version": 3,
  "sources": ["../js/constants/ScreenConstants.ts", "../js/math/Common.ts", "../js/math/Vector.ts", "../js/math/Shapes.ts", "../js/constants/Image.ts", "../js/level/BlockTypes.ts", "../js/level/entity/Entity.ts", "../js/level/interactibles/Interactible.ts", "../js/level/interactibles/DoorInteractible.ts", "../js/puzzle-manager/constants.ts", "../js/puzzle-manager/PuzzleSpaceManager.ts", "../js/puzzle-manager/Puzzle.ts", "../js/puzzle-manager/validation/PuzzleValidation.ts", "../js/puzzle-manager/validation/CellValidation.ts", "../js/puzzle-manager/validation/EdgeValidation.ts", "../js/puzzle-manager/validation/GlobalValidation.ts", "../js/puzzle-manager/validation/PuzzleValidatorFactory.ts", "../js/puzzle-manager/PuzzleFactory.ts", "../js/puzzle-manager/PuzzleManager.ts", "../js/level/LevelEvent.ts", "../js/level/interactibles/PuzzleInteractible.ts", "../js/level/interactibles/SwitchInteractible.ts", "../js/level/interactibles/TrapdoorInteractible.ts", "../js/utils/Color.ts", "../js/level/entity/CoverEntity.ts", "../js/level/ExitTrigger.ts", "../js/constants/Keys.ts", "../js/InputManager.ts", "../js/level/background/BackgroundArtist.ts", "../js/level/Level.ts", "../js/level/RectPool.ts", "../js/level/Player.ts", "../js/level/LevelFactory.ts", "../js/level/DataLoader.ts", "../js/game-modes/MapMode.ts", "../js/level/LevelManager.ts", "../js/game-modes/PlayMode.ts", "../js/GameModeManager.ts", "../js/Canvas.ts", "../js/ScreenManager.ts", "../js/App.ts"],
  "sourcesContent": ["export const CANVAS_WIDTH = 1280;\nexport const CANVAS_HEIGHT = 720;\n\nexport const HORIZONTAL_TILES = 32;\nexport const VERTICAL_TILES = 18;\n\nexport const PIXELS_PER_TILE = 10;\n\nexport const PIXEL_WIDTH = CANVAS_WIDTH / HORIZONTAL_TILES / PIXELS_PER_TILE;\n\nexport const IS_MOBILE =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  );\n\nexport const ON_SCREEN_CANVAS_WIDTH = 1280;\nexport const ON_SCREEN_CANVAS_HEIGHT = 720;\n\nexport const UI_CANVAS_WIDTH = ON_SCREEN_CANVAS_WIDTH;\nexport const UI_CANVAS_HEIGHT = ON_SCREEN_CANVAS_HEIGHT;\n\nexport const UI_PIXEL_WIDTH = 3;\n", "/**\n * Clamps a parameter between a low and high bound.\n * @param {number} x The number to be clamped\n * @param {number} low The lowest value that could be returned\n * @param {number} high The highest value that could be returned\n */\nexport const clamp = (x: number, low: number, high: number): number => {\n  return Math.min(high, Math.max(x, low));\n};\n\nexport const sign = (x: number): number => {\n  if (x > 0) {\n    return 1;\n  } else if (x === 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n};\n", "export class Vector {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n\n    return this;\n  }\n\n  subtract(vector: Vector) {\n    this.x -= vector.x;\n    this.y -= vector.y;\n  }\n\n  multiply(factor: number) {\n    this.x *= factor;\n    this.y *= factor;\n\n    return this;\n  }\n\n  copy() {\n    return new Vector(this.x, this.y);\n  }\n\n  get magnitude(): number {\n    return Math.hypot(this.x, this.y);\n  }\n\n  static add(a: Vector, b: Vector) {\n    return new Vector(a.x + b.x, a.y + b.y);\n  }\n\n  static diff(a: Vector, b: Vector) {\n    return new Vector(a.x - b.x, a.y - b.y);\n  }\n\n  static scale(vector: Vector, factor: number) {\n    return new Vector(vector.x * factor, vector.y * factor);\n  }\n\n  static sqrDist(a: Vector, b: Vector): number {\n    const xDiff = a.x - b.x;\n    const yDiff = a.y - b.y;\n    return xDiff * xDiff + yDiff * yDiff;\n  }\n\n  /**\n   * This is not actually manhattan distance. Consider refactoring.\n   */\n  static manhattanDist(a: Vector, b: Vector) {\n    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n  }\n\n  static dist(a: Vector, b: Vector) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  static lerp(v1: Vector, v2: Vector, t: number) {\n    return new Vector(v1.x * (1 - t) + v2.x * t, v1.y * (1 - t) + v2.y * t);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { clamp, sign } from \"./Common\";\nimport { Vector } from \"./Vector\";\n\nexport class Circle {\n  position: Vector;\n  radius: number;\n\n  constructor(position: Vector, radius: number) {\n    this.position = position;\n    this.radius = radius;\n  }\n\n  /**\n   * Check if another circle intersects with this circle\n   * @param {Circle} otherCircle The circle to check intersection with\n   */\n  intersectsCircle(otherCircle: Circle) {\n    const radiusSum = this.radius + otherCircle.radius;\n    return (\n      Vector.sqrDist(this.position, otherCircle.position) <\n      radiusSum * radiusSum\n    );\n  }\n\n  /**\n   * Check if a point intersects with this circle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsVector(point: Vector) {\n    return Vector.sqrDist(this.position, point) < this.radius * this.radius;\n  }\n\n  /**\n   * Check if a rectangle intersects with this circle.\n   * @param {Rectangle} rectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(rectangle: Rectangle) {\n    // Find the co-ordinates of the closest point in the rectangle to the circle center.\n    const closestX = clamp(this.position.x, rectangle.x1, rectangle.x2);\n    const closestY = clamp(this.position.y, rectangle.y1, rectangle.y2);\n\n    // Find if the closest point in the rectangle overlaps with the circle.\n    return this.intersectsVector(new Vector(closestX, closestY));\n  }\n\n  /**\n   * Determine if this circle is exactly kissing a rectangle below.\n   * @param {Rectangle} rectangle The rectangle to check for a kiss with\n   */\n  isKissingBelow(rectangle: Rectangle) {\n    return (\n      this.position.y + this.radius === rectangle.y1 &&\n      rectangle.x1 <= this.position.x &&\n      this.position.x <= rectangle.x2\n    );\n  }\n\n  /**\n   * Draw this circle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas) {\n    canvas.fillEllipse(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      this.radius\n    );\n  }\n}\n\nexport class Rectangle {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /**\n   * Check if a point intersects with this rectangle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsPoint(point: Vector) {\n    return (\n      this.x1 <= point.x &&\n      point.x <= this.x2 &&\n      this.y1 <= point.y &&\n      point.y <= this.y2\n    );\n  }\n\n  get width() {\n    return this.x2 - this.x1;\n  }\n\n  get height() {\n    return this.y2 - this.y1;\n  }\n\n  get midpoint() {\n    return new Vector((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n  }\n\n  xInRange(x: number): boolean {\n    return this.x1 <= x && x < this.x2;\n  }\n\n  yInRange(y: number): boolean {\n    return this.y1 <= y && y < this.y2;\n  }\n\n  /**\n   * Check if another rectangle intersects with this rectangle.\n   * @param {Rectangle} otherRectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(otherRectangle: Rectangle) {\n    return (\n      otherRectangle.x1 <= this.x2 &&\n      this.x1 <= otherRectangle.x2 &&\n      otherRectangle.y1 <= this.y2 &&\n      this.y1 <= otherRectangle.y2\n    );\n  }\n\n  /**\n   * Compute the smallest vector in the reverse direction to movement to\n   * uncollide with a given rectangle.\n   * @param {Circle} circle\n   */\n  uncollideCircle(circle: Circle) {\n    const closestX = clamp(circle.position.x, this.x1, this.x2);\n    const closestY = clamp(circle.position.y, this.y1, this.y2);\n\n    const p0 = new Vector(closestX, closestY);\n    const pToCenter = Vector.diff(circle.position, p0);\n\n    const distFromCenter = pToCenter.magnitude || 1;\n\n    if (distFromCenter >= circle.radius) {\n      const circleDistToMyCenter = Vector.diff(circle.position, this.midpoint);\n      const horizontalDistance =\n        this.width / 2 - Math.abs(circleDistToMyCenter.x);\n      const verticalDistance =\n        this.height / 2 - Math.abs(circleDistToMyCenter.y);\n\n      // Shortest way out is horizontally\n      if (horizontalDistance < verticalDistance) {\n        return new Vector(\n          (horizontalDistance + circle.radius) * sign(circleDistToMyCenter.x),\n          0\n        );\n      } else {\n        return new Vector(\n          0,\n          (verticalDistance + circle.radius) * sign(circleDistToMyCenter.y)\n        );\n      }\n    }\n\n    return Vector.scale(\n      pToCenter,\n      (circle.radius - distFromCenter) / distFromCenter\n    );\n  }\n\n  /**\n   * Draw this rectangle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas, outset = 0) {\n    canvas.fillRect(\n      this.x1 - outset,\n      this.y1 - outset,\n      this.width + outset * 2,\n      this.height + outset * 2\n    );\n  }\n\n  stroke(canvas: Canvas, inset = 0) {\n    canvas.strokeRectInset(this.x1, this.y1, this.width, this.height, inset);\n  }\n\n  inset(insetBy: number) {\n    return new Rectangle(\n      this.x1 + insetBy,\n      this.y1 + insetBy,\n      this.x2 - insetBy,\n      this.y2 - insetBy\n    );\n  }\n\n  static widthForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x, y, x + width, y + height);\n  }\n\n  static centerForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x - width, y - height, x + width, y + height);\n  }\n\n  static aroundPoint(point: Vector, halfWidth: number, halfHeight: number) {\n    return new Rectangle(\n      point.x - halfWidth,\n      point.y - halfHeight,\n      point.x + halfWidth,\n      point.y + halfHeight\n    );\n  }\n\n  // Creates a rectangle that overlaps all of the provided ones\n  static merged(rectangles: Rectangle[]) {\n    const [x1, y1, x2, y2] = rectangles.reduce<\n      [number, number, number, number]\n    >(\n      ([x1, y1, x2, y2], rect) => [\n        Math.min(rect.x1, x1),\n        Math.min(rect.y1, y1),\n        Math.max(rect.x2, x2),\n        Math.max(rect.y2, y2),\n      ],\n      [Infinity, Infinity, -Infinity, -Infinity]\n    );\n\n    return new Rectangle(x1, y1, x2, y2);\n  }\n}\n", "export const TileImage = new Image();\nTileImage.src = \"./img/tileset.png\";\n\nexport const EntityImage = new Image();\nEntityImage.src = \"./img/entity-set.png\";\n", "export enum BlockEnum {\n  SOLID = 1,\n  LEDGE = 2,\n  VENT = 3,\n  LADDER = 4,\n}\n\nexport const BlockType = {\n  isSolid: (blockType?: BlockEnum) => {\n    return blockType === BlockEnum.SOLID;\n  },\n  isGrounding: (blockType?: BlockEnum) => {\n    return blockType === BlockEnum.LEDGE || BlockType.isSolid(blockType);\n  },\n};\n", "import { Canvas } from \"../../Canvas\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nexport class Entity {\n  id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  onStart(_level: Level) {\n    // Do nothing\n  }\n\n  onAwaken() {\n    // Do nothing\n  }\n\n  update(_player: Player, _deltaTime: number, _level: Level) {\n    // Do nothing\n  }\n\n  draw(_screenManager: ScreenManager) {\n    // Do nothing\n  }\n\n  drawForMap(_canvas: Canvas) {\n    // Do nothing\n  }\n}\n", "import { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Entity } from \"../entity/Entity\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\nimport { LevelEvent } from \"../LevelEvent\";\n\nconst AREA_DEBUG = false;\n\nexport class Interactible extends Entity {\n  position: Vector;\n  triggerArea: Rectangle | undefined;\n\n  prerequisites: string[];\n  prereqsActive: boolean;\n  prereqEntities: Interactible[];\n\n  isEnabled: boolean;\n  isAreaActive: boolean;\n\n  connectionPoint: Vector;\n  outputPoint: Vector;\n\n  constructor(\n    id: string,\n    position: Vector,\n    triggerArea: Rectangle | undefined,\n    prerequisites: string[] = []\n  ) {\n    super(id);\n\n    this.position = position;\n    this.triggerArea = triggerArea;\n\n    this.prerequisites = prerequisites;\n    this.prereqsActive = prerequisites.length === 0;\n    this.prereqEntities = [];\n\n    this.isEnabled = false;\n\n    this.isAreaActive = false;\n\n    this.connectionPoint = this.position;\n    this.outputPoint = this.position;\n  }\n\n  onStart(level: Level) {\n    this.findPrerequisites(level);\n  }\n\n  onAwaken() {\n    // Do nothing\n  }\n\n  findPrerequisites(level: Level): Interactible[] {\n    if (this.prereqEntities.length === this.prerequisites.length) {\n      return this.prereqEntities;\n    }\n\n    this.prereqEntities = level.interactibles.filter((i) =>\n      this.prerequisites.includes(i.id)\n    );\n\n    return this.prereqEntities;\n  }\n\n  update(player: Player, _deltaTime: number, _level: Level) {\n    this.prereqsActive = this.prereqEntities.every((i) => i.isEnabled);\n    this.isAreaActive = !!(\n      this.prereqsActive && this.triggerArea?.intersectsPoint(player.position)\n    );\n  }\n\n  /**\n   * Draw the element on the canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(screenManager: ScreenManager) {\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (AREA_DEBUG) {\n      canvas.setColorRGB(255, 255, 255);\n      canvas.setLineWidth(0.1);\n      canvas.setLineDash([0.2, 0.2]);\n      this.triggerArea?.stroke(canvas);\n    }\n\n    screenManager.behindGroundCanvas.setLineWidth(0.2);\n    for (const prereq of this.prereqEntities) {\n      screenManager.behindGroundCanvas.setColor(\n        prereq.isEnabled ? \"white\" : \"black\"\n      );\n      const xDiff = Vector.manhattanDist(\n        prereq.outputPoint,\n        this.connectionPoint\n      );\n      const mid = Vector.lerp(prereq.outputPoint, this.connectionPoint, 0.5);\n      const control = Vector.add(mid, new Vector(0, xDiff * 0.3));\n      screenManager.behindGroundCanvas.drawQuadratic(\n        prereq.outputPoint.x,\n        prereq.outputPoint.y,\n        this.connectionPoint.x,\n        this.connectionPoint.y,\n        control.x,\n        control.y\n      );\n    }\n  }\n\n  onInteract(): LevelEvent | undefined | void {\n    // Maybe return an event\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { EntityImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { BlockEnum } from \"../BlockTypes\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nconst OPEN_CLOSE_DURATION = 0.8;\n\nexport class DoorInteractible extends Interactible {\n  headCollider: Rectangle;\n  doorCollider: Rectangle;\n\n  fullHeight: number;\n\n  constructor(\n    id: string,\n    position: Vector,\n    prerequisites: string[],\n    height = 4\n  ) {\n    super(id, position, undefined, prerequisites);\n\n    this.connectionPoint = Vector.add(position, new Vector(0, -1.8));\n\n    this.headCollider = Rectangle.centerForm(\n      this.position.x,\n      this.position.y - 1.8,\n      0.6,\n      0.4\n    );\n    this.doorCollider = Rectangle.widthForm(\n      this.position.x - 0.5,\n      this.position.y - 2,\n      1,\n      height\n    );\n\n    this.fullHeight = height;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n\n    level.addWithoutDuplicate({\n      type: BlockEnum.SOLID,\n      rect: this.headCollider,\n    });\n    level.addWithoutDuplicate({\n      type: BlockEnum.SOLID,\n      rect: this.doorCollider,\n    });\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const motion =\n      ((this.fullHeight * deltaTime) / OPEN_CLOSE_DURATION) *\n      (this.prereqsActive ? -1 : 1);\n\n    this.doorCollider.y2 = clamp(\n      this.doorCollider.y2 + motion,\n      this.doorCollider.y1,\n      this.doorCollider.y1 + this.fullHeight\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const h = this.doorCollider.height;\n    if (h > 0) {\n      canvas.setColor(\"black\");\n      canvas.fillRect(this.position.x - 0.5, this.position.y - 2, 1, h);\n\n      canvas.drawImage(\n        EntityImage,\n        120,\n        Math.max(40 - 10 * h, 20) - 10,\n        40,\n        Math.min(10 * h, 20),\n        this.position.x - 2,\n        this.position.y - 2 + Math.max(h - 2, 0),\n        4,\n        Math.min(h, 2)\n      );\n    }\n\n    canvas.drawImage(\n      EntityImage,\n      this.prereqsActive ? 140 : 128,\n      0,\n      12,\n      6,\n      this.position.x - 6 / PIXELS_PER_TILE,\n      this.position.y - 2,\n      12 / PIXELS_PER_TILE,\n      6 / PIXELS_PER_TILE\n    );\n  }\n\n  drawForMap(canvas: Canvas): void {\n    canvas.setColor(\"black\");\n\n    this.doorCollider.draw(canvas);\n  }\n}\n", "import { UI_CANVAS_HEIGHT } from \"../constants/ScreenConstants\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nexport const OPEN_DURATION = 0.4;\nexport const CLOSE_DURATION = 0.25;\n\nexport const PUZZLE_WINDOW_WIDTH = (7 / 9) * UI_CANVAS_HEIGHT;\n\nexport const SOLVED_BACKGROUND = \"#00ff62c8\";\nexport const DEFAULT_BACKGROUND = \"#0096ffc8\";\n\nexport const N_CIRCLE_LAYOUT = [\n  [new Circle(new Vector(0, 0), 0.33)],\n  [new Circle(new Vector(0, 0), 0.33)],\n  [new Circle(new Vector(0, 0.4), 0.33), new Circle(new Vector(0, -0.4), 0.33)],\n  [\n    new Circle(new Vector(-0.42, 0.4), 0.33),\n    new Circle(new Vector(0.42, 0.4), 0.33),\n    new Circle(new Vector(0, -0.4), 0.33),\n  ],\n  [\n    new Circle(new Vector(0.4, 0.4), 0.33),\n    new Circle(new Vector(0.4, -0.4), 0.33),\n    new Circle(new Vector(-0.4, 0.4), 0.33),\n    new Circle(new Vector(-0.4, -0.4), 0.33),\n  ],\n  [\n    new Circle(new Vector(0, 0.3), 0.28),\n    new Circle(new Vector(0.64, 0.3), 0.28),\n    new Circle(new Vector(-0.64, 0.3), 0.28),\n    new Circle(new Vector(-0.32, -0.3), 0.28),\n    new Circle(new Vector(0.32, -0.3), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0.6), 0.28),\n    new Circle(new Vector(0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.32, 0), 0.28),\n    new Circle(new Vector(0.32, 0), 0.28),\n    new Circle(new Vector(0, -0.6), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0), 0.28),\n    new Circle(new Vector(0.64, 0), 0.28),\n    new Circle(new Vector(-0.64, 0), 0.28),\n    new Circle(new Vector(-0.32, -0.6), 0.28),\n    new Circle(new Vector(0.32, -0.6), 0.28),\n    new Circle(new Vector(-0.32, 0.6), 0.28),\n    new Circle(new Vector(0.32, 0.6), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0.6), 0.28),\n    new Circle(new Vector(0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.32, 0), 0.28),\n    new Circle(new Vector(0.32, 0), 0.28),\n    new Circle(new Vector(0, -0.6), 0.28),\n    new Circle(new Vector(0.64, -0.6), 0.28),\n    new Circle(new Vector(-0.64, -0.6), 0.28),\n  ],\n];\n\nexport const N_SQUARE_LAYOUT = [\n  [Rectangle.centerForm(0, 0, 0.33, 0.33)],\n  [Rectangle.centerForm(0, 0, 0.33, 0.33)],\n  [\n    Rectangle.centerForm(0, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(0, 0.4, 0.33, 0.33),\n  ],\n  [\n    Rectangle.centerForm(0, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(-0.4, 0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, 0.4, 0.33, 0.33),\n  ],\n  [\n    Rectangle.centerForm(-0.4, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(-0.4, 0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, 0.4, 0.33, 0.33),\n  ],\n];\n", "import { Rectangle } from \"../math/Shapes\";\nimport { PUZZLE_WINDOW_WIDTH } from \"./constants\";\nimport { PositionGetter } from \"./types\";\n\nconst CACHE: Record<string, Rectangle[][]> = {};\n\nconst cacheKey = (rows: number, cols: number, leftCol: boolean) =>\n  `${rows}-${cols}-${leftCol}`;\n\nconst produceObject = (\n  rows: number,\n  cols: number,\n  leftCol: boolean\n): Rectangle[][] => {\n  const WIDE_EDGE = 0.7;\n  const BOTTOM_ROW = 0.5;\n  const LEFT_COL = leftCol ? 1 : 0.5;\n  const CELL_SIZE_FROM_COLS = Math.floor(\n    PUZZLE_WINDOW_WIDTH / (cols + WIDE_EDGE + LEFT_COL)\n  );\n  const CELL_SIZE_FROM_ROWS = Math.floor(\n    PUZZLE_WINDOW_WIDTH / (rows + WIDE_EDGE + BOTTOM_ROW)\n  );\n  const CELL_SIZE = Math.min(CELL_SIZE_FROM_COLS, CELL_SIZE_FROM_ROWS);\n  const BOTTOM_SIZE = Math.floor(CELL_SIZE * BOTTOM_ROW);\n  const LEFT_SIZE = Math.floor(CELL_SIZE * LEFT_COL);\n  const WIDE_SIZE = Math.min(\n    PUZZLE_WINDOW_WIDTH - CELL_SIZE * cols - LEFT_SIZE,\n    PUZZLE_WINDOW_WIDTH - CELL_SIZE * rows - BOTTOM_SIZE\n  );\n\n  const FULL_HEIGHT = WIDE_SIZE + BOTTOM_SIZE + rows * CELL_SIZE;\n  const FULL_WIDTH = WIDE_SIZE + LEFT_SIZE + cols * CELL_SIZE;\n\n  const TOP_EDGE = Math.max((FULL_WIDTH - FULL_HEIGHT) / 2, 0);\n  const LEFT_EDGE = Math.max((FULL_HEIGHT - FULL_WIDTH) / 2, 0);\n\n  let lastX = LEFT_EDGE + LEFT_SIZE;\n  const xSpacing = [[LEFT_EDGE, lastX]];\n\n  for (let i = 0; i < cols; i++) {\n    xSpacing.push([lastX, lastX + CELL_SIZE]);\n    lastX += CELL_SIZE;\n  }\n\n  xSpacing.push([lastX, lastX + WIDE_SIZE]);\n\n  let lastY = TOP_EDGE + WIDE_SIZE;\n  const ySpacing = [[TOP_EDGE, lastY]];\n\n  for (let i = 0; i < rows; i++) {\n    ySpacing.push([lastY, lastY + CELL_SIZE]);\n    lastY += CELL_SIZE;\n  }\n\n  ySpacing.push([lastY, lastY + BOTTOM_SIZE]);\n\n  const matrix = [];\n\n  for (const [y1, y2] of ySpacing) {\n    const thisRow = [];\n    for (const [x1, x2] of xSpacing) {\n      thisRow.push(new Rectangle(x1, y1, x2, y2));\n    }\n\n    matrix.push(thisRow);\n  }\n\n  return matrix;\n};\n\nconst getObject = (rows: number, cols: number, leftCol: boolean) => {\n  const key = cacheKey(rows, cols, leftCol);\n  if (!(key in CACHE)) {\n    CACHE[key] = produceObject(rows, cols, leftCol);\n  }\n\n  return CACHE[key];\n};\n\nexport const positionGetter = (\n  rows: number,\n  cols: number,\n  leftCol?: boolean\n): PositionGetter => {\n  const matrix = getObject(rows, cols, !!leftCol);\n\n  // Indexed from [-1 to ROWS][-1 to COLS]\n  return (row: number | \"end\", col: number | \"end\") => {\n    return matrix[row === \"end\" ? rows + 1 : row + 1][\n      col === \"end\" ? cols + 1 : col + 1\n    ];\n  };\n};\n", "import {\n  UI_PIXEL_WIDTH,\n  UI_CANVAS_HEIGHT,\n  UI_CANVAS_WIDTH,\n} from \"../constants/ScreenConstants\";\nimport { ClickEvent, InputEvent, InputState } from \"../InputManager\";\nimport { clamp } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nimport {\n  CLOSE_DURATION,\n  DEFAULT_BACKGROUND,\n  OPEN_DURATION,\n  PUZZLE_WINDOW_WIDTH,\n  SOLVED_BACKGROUND,\n} from \"./constants\";\nimport { positionGetter } from \"./PuzzleSpaceManager\";\nimport { PuzzleValidator } from \"./validation/PuzzleValidation\";\nimport {\n  CellValue,\n  PositionGetter,\n  PuzzleCellMap,\n  PuzzleGrid,\n  PuzzleValues,\n} from \"./types\";\n\nconst PARTIAL_RADIUS = 0.4;\n\ntype DragState = \"enabling\" | \"emptying\" | \"disabling\" | undefined;\ntype DragKind = \"left\" | \"right\" | undefined;\n\ninterface Element {\n  row: number;\n  col: number;\n  shape: Rectangle;\n  isHovered: boolean;\n}\n\ntype CellGroup = [number, number][];\n\nexport interface PuzzleConfig {\n  combinedGroups?: CellGroup[];\n}\n\nconst SPACE_DEBUG_DRAW = false;\n\nexport class Puzzle {\n  // Basic info\n  id: string;\n  rows: number;\n  cols: number;\n\n  // Open state\n  openCloseStatus: number;\n  isOpen: boolean;\n\n  // Puzzle display & state info\n  grid: PuzzleGrid;\n  values: PuzzleValues;\n  cellMap: PuzzleCellMap;\n  elements: Element[];\n  positionGetter: PositionGetter;\n  miniElements: Element[];\n\n  // Validation & completion\n  validator: PuzzleValidator;\n  isSolved: boolean;\n  hasBeenSolvedEver: boolean;\n\n  // Interaction\n  dragState: DragState;\n  dragKind: DragKind;\n\n  constructor(\n    id: string,\n    rows: number,\n    columns: number,\n    validator: PuzzleValidator,\n    config: PuzzleConfig = {}\n  ) {\n    this.id = id;\n    this.openCloseStatus = 0;\n    this.isOpen = false;\n    this.rows = rows;\n    this.cols = columns;\n\n    this.validator = validator;\n    this.isSolved = false;\n    this.hasBeenSolvedEver = false;\n\n    let incId = 0;\n\n    this.positionGetter = positionGetter(\n      rows,\n      columns,\n      validator.validationItems.some((item) => item.drawnOnLeft)\n    );\n\n    this.grid = [];\n\n    // Initialise grid\n    for (let row = 0; row < rows; row++) {\n      const currentRow = [];\n\n      for (let col = 0; col < columns; col++) {\n        incId++;\n        const cell = {\n          row,\n          column: col,\n          id: incId,\n        };\n        currentRow.push(cell);\n      }\n\n      this.grid.push(currentRow);\n    }\n\n    // Combine provided groups with an id\n    if (config.combinedGroups) {\n      for (const group of config.combinedGroups) {\n        incId++;\n        const groupId = incId;\n        group.forEach(([row, column]) => {\n          this.grid[row][column].id = groupId;\n        });\n      }\n    }\n\n    this.values = {};\n    this.cellMap = {};\n\n    // Initialise values & cell map\n    for (const cell of this.grid.flat()) {\n      this.values[cell.id] = null;\n      this.cellMap[cell.id] =\n        cell.id in this.cellMap ? this.cellMap[cell.id].concat([cell]) : [cell];\n    }\n\n    this.elements = [];\n    this.miniElements = [];\n\n    // Construct elements\n    for (const id in this.cellMap) {\n      const cells = this.cellMap[id];\n\n      this.elements.push({\n        row: cells[0].row,\n        col: cells[0].column,\n        shape: Rectangle.merged(\n          cells.map(({ row, column }) => this.positionGetter(row, column))\n        ).inset(UI_PIXEL_WIDTH),\n        isHovered: false,\n      });\n      this.miniElements.push({\n        row: cells[0].row,\n        col: cells[0].column,\n        shape: Rectangle.merged(\n          cells.map(({ row, column }) => Rectangle.widthForm(column, row, 1, 1))\n        ),\n        isHovered: false,\n      });\n    }\n  }\n\n  open() {\n    if (this.isOpen) {\n      return;\n    }\n\n    this.isOpen = true;\n    this.openCloseStatus = 0;\n  }\n\n  close() {\n    this.isOpen = false;\n  }\n\n  uiPosition() {\n    // Function with f(0) = 1, f(1) = 0, f\"(1) = 0\n    // Feel free to replace this with any other function moving those\n    // parameters.\n    const pos = Math.pow(1 - this.openCloseStatus, 2);\n\n    const slideInOffset = new Vector(0, UI_CANVAS_HEIGHT * pos);\n    const puzzleScreenOffset = new Vector(\n      (UI_CANVAS_WIDTH - PUZZLE_WINDOW_WIDTH) / 2,\n      (UI_CANVAS_HEIGHT - PUZZLE_WINDOW_WIDTH) / 2\n    );\n    return Vector.add(slideInOffset, puzzleScreenOffset);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager) {\n    const canvas = screenManager.uiCanvas;\n\n    canvas.clear();\n\n    if (this.openCloseStatus === 0) {\n      return;\n    }\n\n    const offset = this.uiPosition();\n\n    canvas.translate(offset.x, offset.y);\n\n    // Draw screen background\n    canvas.setColor(this.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND);\n    canvas.fillRect(0, 0, PUZZLE_WINDOW_WIDTH, PUZZLE_WINDOW_WIDTH);\n\n    // Draw monitor leg\n    canvas.setColor(\"#222222\");\n    canvas.fillRect(\n      PUZZLE_WINDOW_WIDTH / 4,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH / 2,\n      PUZZLE_WINDOW_WIDTH\n    );\n\n    // Draw monitor outline\n    canvas.setLineWidth(UI_PIXEL_WIDTH * 8);\n    canvas.setLineDash([]);\n    canvas.strokeRectInset(\n      0,\n      0,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH,\n      -UI_PIXEL_WIDTH * 4\n    );\n\n    // Draw screen outline\n    canvas.setColor(\"#ffffff64\");\n    canvas.setLineWidth(UI_PIXEL_WIDTH);\n\n    canvas.strokeRectInset(\n      0,\n      0,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH,\n      UI_PIXEL_WIDTH / 2\n    );\n\n    if (SPACE_DEBUG_DRAW) {\n      canvas.setColor(\"red\");\n      canvas.setLineDash([]);\n      for (let i = -1; i <= this.rows; i++) {\n        for (let j = -1; j <= this.cols; j++) {\n          this.positionGetter(i, j).stroke(canvas);\n        }\n      }\n    }\n\n    // Draw squares\n    for (const element of this.elements) {\n      if (element.isHovered) {\n        canvas.setColor(\"white\");\n      } else {\n        canvas.setColor(\"#ffffff64\");\n      }\n      canvas.setLineDash([]);\n      element.shape.stroke(canvas, UI_PIXEL_WIDTH / 2);\n\n      const cellState = this.getElementState(element);\n      const mid = element.shape.midpoint;\n      const radius =\n        Math.min(element.shape.width, element.shape.height) * PARTIAL_RADIUS;\n      if (cellState) {\n        canvas.setColor(\"white\");\n        canvas.fillEllipse(mid.x, mid.y, radius, radius);\n      } else if (cellState === false) {\n        // Might be null, so need exact check\n        canvas.setColor(\"#ffffff64\");\n        canvas.setLineDash([UI_PIXEL_WIDTH * 2, UI_PIXEL_WIDTH * 2]);\n        canvas.strokeEllipse(mid.x, mid.y, radius, radius);\n      }\n    }\n\n    this.validator.draw(canvas, this.positionGetter);\n\n    canvas.translate(-offset.x, -offset.y);\n  }\n\n  getRowColState(row: number, column: number): CellValue {\n    const cell = this.grid[row][column];\n    return this.values[cell.id];\n  }\n\n  getElementState(element: Element): CellValue {\n    return this.getRowColState(element.row, element.col);\n  }\n\n  setElementState(element: Element, value: CellValue) {\n    const cell = this.grid[element.row][element.col];\n    if (value !== this.values[cell.id]) {\n      this.values[cell.id] = value;\n      this.onStateChange();\n    }\n  }\n\n  resolveClick(element: Element, left: boolean, right: boolean) {\n    const elementState = this.getElementState(element);\n    if (this.dragKind === undefined) {\n      return;\n    } else if (this.dragKind === \"left\" && !left) {\n      this.dragKind = undefined;\n      this.dragState = undefined;\n    } else if (this.dragKind === \"right\" && !right) {\n      this.dragKind = undefined;\n      this.dragState = undefined;\n    }\n\n    if (this.dragKind === \"left\") {\n      if (this.dragState === undefined) {\n        const current = elementState;\n        if (current !== true) {\n          this.dragState = \"enabling\";\n        } else {\n          this.dragState = \"emptying\";\n        }\n      }\n\n      if (this.dragState === \"enabling\") {\n        if (elementState !== false) {\n          this.setElementState(element, true);\n        }\n      } else if (this.dragState === \"emptying\") {\n        if (elementState !== false) {\n          this.setElementState(element, null);\n        }\n      }\n    } else if (this.dragKind === \"right\") {\n      if (this.dragState === undefined) {\n        const current = elementState;\n        if (current !== false) {\n          this.dragState = \"disabling\";\n        } else {\n          this.dragState = \"emptying\";\n        }\n      }\n\n      if (this.dragState === \"disabling\") {\n        if (elementState !== true) {\n          this.setElementState(element, false);\n        }\n      } else if (this.dragState === \"emptying\") {\n        if (elementState !== true) {\n          this.setElementState(element, null);\n        }\n      }\n    }\n  }\n\n  findPositionElement(position: Vector): Element | undefined {\n    let foundElement: Element | undefined = undefined;\n    for (const element of this.elements) {\n      element.isHovered = element.shape.intersectsPoint(position);\n      if (element.isHovered) {\n        foundElement = element;\n      }\n    }\n    return foundElement;\n  }\n\n  update(deltaTime: number, inputState: InputState) {\n    if (this.isOpen && this.openCloseStatus < 1) {\n      this.openCloseStatus += deltaTime / OPEN_DURATION;\n    } else if (!this.isOpen && this.openCloseStatus > 0) {\n      this.openCloseStatus -= deltaTime / CLOSE_DURATION;\n    }\n\n    this.openCloseStatus = clamp(this.openCloseStatus, 0, 1);\n\n    if (inputState) {\n      const position = Vector.diff(inputState.mousePosition, this.uiPosition());\n\n      const foundElement = this.findPositionElement(position);\n\n      if (foundElement) {\n        this.resolveClick(\n          foundElement,\n          inputState.isLeftClicking(),\n          inputState.isRightClicking()\n        );\n      }\n    } else {\n      this.dragState = undefined;\n    }\n  }\n\n  onStateChange() {\n    this.isSolved = this.validator.isValid(this.grid, this.values);\n    if (this.isSolved) {\n      this.hasBeenSolvedEver = true;\n    }\n  }\n\n  onInput(input: InputEvent) {\n    if (input.isClick()) {\n      const click = input as ClickEvent;\n      const clickPosition = Vector.diff(click.position, this.uiPosition());\n\n      this.dragKind = click.isRightClick() ? \"right\" : \"left\";\n      this.dragState = undefined;\n\n      const foundElement = this.findPositionElement(clickPosition);\n\n      if (foundElement) {\n        this.resolveClick(\n          foundElement,\n          this.dragKind === \"left\",\n          this.dragKind === \"right\"\n        );\n      }\n    }\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\n\nexport class PuzzleValidator {\n  validationItems: ValidationItem[];\n\n  leftAreas: Rectangle[] | undefined;\n\n  constructor(validationItems: ValidationItem[]) {\n    this.validationItems = validationItems;\n  }\n\n  isValid(grid: PuzzleGrid, values: PuzzleValues) {\n    this.validationItems.forEach((item) => {\n      item.validate(grid, values);\n    });\n\n    return this.validationItems.every((item) => item.isValid);\n  }\n\n  getLeftArea(index: number, total: number, positionGetter: PositionGetter) {\n    if (this.leftAreas) {\n      return this.leftAreas[index];\n    }\n    // TODO Draw this better when there are more global rules than fits\n    const leftColumn = Rectangle.merged([\n      positionGetter(-1, -1),\n      positionGetter(\"end\", -1),\n    ]);\n\n    const width = leftColumn.width;\n    const top = leftColumn.midpoint.y - width * (total + 0.1 * (total - 1));\n    this.leftAreas = [];\n    for (let i = 0; i < total; i++) {\n      this.leftAreas.push(\n        Rectangle.widthForm(leftColumn.x1, top + i * width * 1.1, width, width)\n      );\n    }\n\n    console.log(this.leftAreas);\n\n    return this.leftAreas[index];\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter, ...args: unknown[]) {\n    this.validationItems.forEach((item) => {\n      if (!item.drawnOnLeft) {\n        item.draw(canvas, positionGetter, ...args);\n      }\n    });\n\n    const globals = this.validationItems.filter((item) => item.drawnOnLeft);\n\n    globals.forEach((item, index) => {\n      item.draw(\n        canvas,\n        this.getLeftArea(index, globals.length, positionGetter)\n      );\n    });\n  }\n}\n\nexport class ValidationItem {\n  isValid: boolean;\n  drawnOnLeft: boolean;\n\n  constructor() {\n    this.isValid = false;\n    this.drawnOnLeft = false;\n  }\n\n  validate(_grid: PuzzleGrid, _values: PuzzleValues) {\n    // Do nothing...\n  }\n\n  draw(_canvas: Canvas, ..._args: unknown[]) {\n    // Do nothing...\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { Vector } from \"../../math/Vector\";\n\nimport { N_CIRCLE_LAYOUT, SOLVED_BACKGROUND } from \"../constants\";\nimport { ValidationItem } from \"./PuzzleValidation\";\nimport { PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\n\nexport class CellValidation extends ValidationItem {\n  row: number;\n  column: number;\n\n  constructor(row: number, column: number) {\n    super();\n    this.row = row;\n    this.column = column;\n  }\n}\n\nexport class ForcedCellValidation extends CellValidation {\n  mustBeOn: boolean;\n\n  constructor(row: number, column: number, mustBeOn: boolean) {\n    super(row, column);\n    this.mustBeOn = mustBeOn;\n\n    this.isValid = !mustBeOn;\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues) {\n    const cell = grid[this.row][this.column];\n\n    this.isValid = !!values[cell.id] === !!this.mustBeOn;\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const rect = positionGetter(this.row, this.column);\n\n    const width = Math.min(rect.width, rect.height);\n\n    const center = new Vector(rect.x2 - width * 0.15, rect.y1 + width * 0.15);\n\n    if (this.mustBeOn) {\n      canvas.fillEllipse(center.x, center.y, width * 0.1, width * 0.1);\n    } else {\n      canvas.setLineWidth(width * 0.05);\n      canvas.setLineDash([]);\n      canvas.strokeEllipse(center.x, center.y, width * 0.075, width * 0.075);\n    }\n  }\n}\n\nexport class CountInAreaValidation extends CellValidation {\n  desiredCount: number;\n  isCellColoured: boolean;\n\n  constructor(row: number, column: number, desiredCount: number) {\n    super(row, column);\n\n    this.desiredCount = desiredCount;\n    this.isValid = desiredCount === 0;\n    this.isCellColoured = false;\n  }\n\n  *iterateArea(grid: PuzzleGrid) {\n    for (\n      let row = Math.max(this.row - 1, 0);\n      row <= Math.min(this.row + 1, grid.length - 1);\n      row++\n    ) {\n      for (\n        let col = Math.max(this.column - 1, 0);\n        col <= Math.min(this.column + 1, grid[row].length - 1);\n        col++\n      ) {\n        yield [row, col];\n      }\n    }\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues) {\n    let count = 0;\n\n    const seenIds = new Set();\n\n    for (const [row, col] of this.iterateArea(grid)) {\n      const cell = grid[row][col];\n      if (!!values[cell.id] && !seenIds.has(cell.id)) {\n        count++;\n        seenIds.add(cell.id);\n      }\n    }\n\n    this.isValid = count === this.desiredCount;\n    this.isCellColoured = !!values[grid[this.row][this.column].id];\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(this.isCellColoured ? SOLVED_BACKGROUND : \"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const rect = positionGetter(this.row, this.column);\n\n    const width = Math.min(rect.width, rect.height) * 0.25;\n\n    const center = rect.midpoint;\n\n    for (const circle of N_CIRCLE_LAYOUT[this.desiredCount]) {\n      const position = Vector.add(center, Vector.scale(circle.position, width));\n\n      if (this.desiredCount === 0) {\n        canvas.setLineWidth(circle.radius * width * 0.5);\n        canvas.strokeEllipse(\n          position.x,\n          position.y,\n          circle.radius * width * 0.75,\n          circle.radius * width * 0.75\n        );\n      } else {\n        canvas.fillEllipse(\n          position.x,\n          position.y,\n          circle.radius * width,\n          circle.radius * width\n        );\n      }\n    }\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { Circle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\n\nimport { N_CIRCLE_LAYOUT, N_SQUARE_LAYOUT } from \"../constants\";\nimport { ValidationItem } from \"./PuzzleValidation\";\nimport { CellValue, PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\n\nconst rotRight = (vector: Vector) => new Vector(-vector.y, vector.x);\n\nclass EdgeValidationItem extends ValidationItem {\n  isRow: boolean;\n  index: number;\n\n  constructor(isRow: boolean, index: number) {\n    super();\n    this.isRow = isRow;\n    this.index = index;\n\n    this.isValid = false;\n  }\n\n  getRelevantRow(grid: PuzzleGrid, valueMap: PuzzleValues): CellValue[] {\n    const cells = this.isRow\n      ? grid[this.index]\n      : grid.map((row) => row[this.index]);\n\n    const [values] = cells.reduce<[CellValue[], number]>(\n      ([valuesSoFar, lastId], cell) => [\n        cell.id === lastId\n          ? valuesSoFar\n          : valuesSoFar.concat([valueMap[cell.id]]),\n        cell.id,\n      ],\n      [[], -1]\n    );\n\n    return values;\n  }\n\n  validateRow(_row: CellValue[]): boolean {\n    throw new TypeError(\"Cannot validate as a generic EdgeValidationItem\");\n  }\n\n  validate(grid: PuzzleGrid, values: PuzzleValues) {\n    const row = this.getRelevantRow(grid, values);\n\n    this.isValid = this.validateRow(row);\n  }\n\n  drawInCell(\n    _canvas: Canvas,\n    _center: Vector,\n    _scaleBy: number,\n    _isSideways: boolean\n  ) {\n    throw new TypeError(\"Cannot draw a generic EdgeValidationItem\");\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    if (this.isRow) {\n      const cell = positionGetter(this.index, \"end\");\n\n      this.drawInCell(canvas, cell.midpoint, cell.width / 2, true);\n    } else {\n      const cell = positionGetter(-1, this.index);\n\n      this.drawInCell(canvas, cell.midpoint, cell.height / 2, false);\n    }\n  }\n}\n\nexport class EdgeCountValidationItem extends EdgeValidationItem {\n  count: number;\n\n  constructor(isRow: boolean, index: number, count: number) {\n    super(isRow, index);\n    this.count = count;\n\n    this.isValid = count === 0;\n  }\n\n  validateRow(row: CellValue[]) {\n    const count = row.reduce((soFar, item) => (item ? soFar + 1 : soFar), 0);\n\n    return count === this.count;\n  }\n\n  drawInCell(\n    canvas: Canvas,\n    center: Vector,\n    scaleBy: number,\n    isSideways: boolean\n  ) {\n    const transformCircle = isSideways\n      ? (circle: Circle) => new Circle(rotRight(circle.position), circle.radius)\n      : (v: Circle) => v;\n\n    for (let circle of N_CIRCLE_LAYOUT[this.count]) {\n      circle = transformCircle(circle);\n      const position = Vector.add(\n        center,\n        Vector.scale(circle.position, scaleBy)\n      );\n\n      if (this.count === 0) {\n        canvas.setLineDash([]);\n        canvas.setLineWidth(circle.radius * scaleBy * 0.5);\n        canvas.strokeEllipse(\n          position.x,\n          position.y,\n          circle.radius * scaleBy * 0.75,\n          circle.radius * scaleBy * 0.75\n        );\n      } else {\n        canvas.fillEllipse(\n          position.x,\n          position.y,\n          circle.radius * scaleBy,\n          circle.radius * scaleBy\n        );\n      }\n    }\n  }\n}\n\nexport class EdgeGroupsValidationItem extends EdgeCountValidationItem {\n  validateRow(row: CellValue[]) {\n    const [numGroups] = row.reduce(\n      ([soFar, inGroup], item) =>\n        item && !inGroup\n          ? // Start of new group\n            [soFar + 1, true]\n          : // Continue, updating inGroup based on current item state\n            [soFar, !!item],\n      [0, false]\n    );\n\n    return numGroups === this.count;\n  }\n\n  drawSquare(canvas: Canvas, position: Vector, width: number) {\n    canvas.fillRect(\n      position.x - width / 2,\n      position.y - width / 2,\n      width,\n      width\n    );\n  }\n\n  drawInCell(\n    canvas: Canvas,\n    center: Vector,\n    scaleBy: number,\n    isSideways: boolean\n  ) {\n    const moveCenter = (pos: Vector) => (isSideways ? rotRight(pos) : pos);\n\n    for (const square of N_SQUARE_LAYOUT[this.count]) {\n      const position = Vector.add(\n        center,\n        Vector.scale(moveCenter(square.midpoint), scaleBy)\n      );\n      const width = square.width * scaleBy;\n\n      this.drawSquare(canvas, position, width);\n    }\n  }\n}\n\nexport class EdgeBlankGroupsValidationItem extends EdgeGroupsValidationItem {\n  constructor(isRow: boolean, index: number, count: number) {\n    super(isRow, index, count);\n\n    this.isValid = count === 1;\n  }\n\n  validateRow(row: CellValue[]) {\n    const [numGroups] = row.reduce(\n      ([soFar, inGroup], item) =>\n        !item && inGroup\n          ? // Start of new group\n            [soFar + 1, false]\n          : // Continue, updating inGroup based on current item state\n            [soFar, !!item],\n      [0, true]\n    );\n\n    return numGroups === this.count;\n  }\n\n  drawSquare(canvas: Canvas, position: Vector, width: number) {\n    canvas.setLineDash([]);\n    canvas.setLineWidth(width * 0.25);\n    canvas.strokeRectInset(position.x, position.y, 0, 0, -width * 0.4);\n  }\n}\n\nexport class EdgeNoTripleValidationItem extends EdgeValidationItem {\n  constructor(isRow: boolean, index: number) {\n    super(isRow, index);\n\n    // Valid by default if no triple\n    this.isValid = true;\n  }\n\n  validateRow(row: CellValue[]) {\n    let count = 0;\n    for (const value of row) {\n      if (value) {\n        count += 1;\n      } else {\n        count = 0;\n      }\n      if (count >= 3) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  drawInCell(\n    canvas: Canvas,\n    center: Vector,\n    scaleBy: number,\n    isSideways: boolean\n  ) {\n    canvas.setLineWidth(scaleBy * 0.1);\n    canvas.setLineDash([]);\n\n    canvas.fillEllipse(center.x, center.y, 0.22 * scaleBy, 0.22 * scaleBy);\n    const center2 = Vector.add(\n      center,\n      Vector.scale(\n        isSideways ? new Vector(-0.5, 0) : new Vector(0, 0.5),\n        scaleBy\n      )\n    );\n    canvas.fillEllipse(center2.x, center2.y, 0.22 * scaleBy, 0.22 * scaleBy);\n    const center3 = Vector.add(center, Vector.diff(center, center2));\n\n    const radius = scaleBy * 0.22;\n    canvas.drawLine(\n      center3.x - radius,\n      center3.y - radius,\n      center3.x + radius,\n      center3.y + radius\n    );\n    canvas.drawLine(\n      center3.x - radius,\n      center3.y + radius,\n      center3.x + radius,\n      center3.y - radius\n    );\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { PIXEL_WIDTH } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { PositionGetter, PuzzleGrid, PuzzleValues } from \"../types\";\nimport { ValidationItem } from \"./PuzzleValidation\";\n\nclass GlobalValidationItem extends ValidationItem {\n  constructor() {\n    super();\n    this.drawnOnLeft = true;\n  }\n\n  draw(canvas: Canvas, rectangle: Rectangle) {}\n}\n\nexport class GlobalCountValidationItem extends GlobalValidationItem {\n  desiredCount: number;\n  currentCount: number;\n\n  constructor(count: number) {\n    super();\n    this.desiredCount = count;\n    this.currentCount = 0;\n  }\n\n  validate(_grid: PuzzleGrid, values: PuzzleValues) {\n    this.currentCount = 0;\n    for (const val of Object.values<boolean | null>(values)) {\n      if (val) {\n        this.currentCount++;\n      }\n    }\n\n    this.isValid = this.currentCount === this.desiredCount;\n  }\n\n  drawNumber(canvas: Canvas, rectangle: Rectangle, number: number) {\n    // TODO Draw numbers better, this is bad\n    const center = rectangle.midpoint;\n    const w = Math.min(rectangle.height, rectangle.width);\n    const squareSize = Math.ceil(Math.sqrt(number));\n    const radius = w / squareSize;\n    const l = center.x - ((squareSize - 1) * radius) / 2;\n    const t = center.y - ((squareSize - 1) * radius) / 2;\n\n    if (number === 0) {\n      canvas.setLineWidth(PIXEL_WIDTH);\n      canvas.strokeEllipse(center.x, center.y, w * 0.4, w * 0.4);\n    }\n\n    for (let row = 0; row < squareSize; row++) {\n      for (let col = 0; col < squareSize; col++) {\n        const ind = row * squareSize + col;\n        if (ind < number) {\n          canvas.fillEllipse(\n            l + col * radius,\n            t + row * radius,\n            radius * 0.4,\n            radius * 0.4\n          );\n        }\n      }\n    }\n  }\n\n  draw(canvas: Canvas, cell: Rectangle) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n    // const cell = positionGetter(0, -1).inset(PIXEL_WIDTH * 2);\n\n    const halfWidth = cell.width / 2;\n    const halfHeight = cell.height / 2;\n\n    const midpoint = cell.midpoint;\n\n    this.drawNumber(\n      canvas,\n      Rectangle.widthForm(cell.x1, cell.y1, halfWidth, halfHeight),\n      this.currentCount\n    );\n    canvas.setLineWidth(PIXEL_WIDTH);\n    canvas.drawLine(\n      midpoint.x - halfWidth * 0.67,\n      midpoint.y + halfHeight * 0.67,\n      midpoint.x + halfWidth * 0.67,\n      midpoint.y - halfHeight * 0.67\n    );\n    this.drawNumber(\n      canvas,\n      Rectangle.widthForm(midpoint.x, midpoint.y, halfWidth, halfHeight),\n      this.desiredCount\n    );\n  }\n}\n", "import { CountInAreaValidation, ForcedCellValidation } from \"./CellValidation\";\nimport {\n  EdgeBlankGroupsValidationItem,\n  EdgeCountValidationItem,\n  EdgeGroupsValidationItem,\n  EdgeNoTripleValidationItem,\n} from \"./EdgeValidation\";\nimport { GlobalCountValidationItem } from \"./GlobalValidation\";\nimport { PuzzleValidator, ValidationItem } from \"./PuzzleValidation\";\n\nexport class PuzzleValidatorFactory {\n  validationItems: ValidationItem[];\n\n  constructor() {\n    this.validationItems = [];\n  }\n\n  addForcedCellValidator(row: number, column: number, mustBeOn: boolean) {\n    this.validationItems.push(new ForcedCellValidation(row, column, mustBeOn));\n    return this;\n  }\n\n  addCountAreaValidator(row: number, column: number, count: number) {\n    this.validationItems.push(new CountInAreaValidation(row, column, count));\n    return this;\n  }\n\n  addEdgeValidators(\n    nums: (number | null)[],\n    isRow: boolean,\n    ValidationItemType = EdgeCountValidationItem\n  ) {\n    nums.forEach((num, index) => {\n      if (typeof num !== \"number\") {\n        return;\n      }\n\n      this.validationItems.push(new ValidationItemType(isRow, index, num));\n    });\n  }\n\n  addColumnCounts(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false);\n    return this;\n  }\n\n  addRowCounts(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true);\n    return this;\n  }\n\n  addColumnGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false, EdgeGroupsValidationItem);\n    return this;\n  }\n\n  addRowGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true, EdgeGroupsValidationItem);\n    return this;\n  }\n\n  addColumnBlankGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false, EdgeBlankGroupsValidationItem);\n    return this;\n  }\n\n  addRowBlankGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true, EdgeBlankGroupsValidationItem);\n    return this;\n  }\n\n  addColumnNoTriple(yeses: boolean[]) {\n    yeses.forEach((bool, index) => {\n      if (!bool) {\n        return;\n      }\n\n      this.validationItems.push(new EdgeNoTripleValidationItem(false, index));\n    });\n    return this;\n  }\n\n  addRowNoTriple(yeses: boolean[]) {\n    yeses.forEach((bool, index) => {\n      if (!bool) {\n        return;\n      }\n\n      this.validationItems.push(new EdgeNoTripleValidationItem(true, index));\n    });\n    return this;\n  }\n\n  setGlobalCount(count: number) {\n    this.validationItems.push(new GlobalCountValidationItem(count));\n    return this;\n  }\n\n  create() {\n    return new PuzzleValidator(this.validationItems);\n  }\n}\n", "import { Puzzle, PuzzleConfig } from \"./Puzzle\";\nimport { PuzzleValidatorFactory } from \"./validation/PuzzleValidatorFactory\";\n\nexport interface PuzzleRules {\n  rows: number;\n  cols: number;\n\n  columnCounts?: (number | null)[];\n  rowCounts?: (number | null)[];\n\n  columnGroups?: (number | null)[];\n  rowGroups?: (number | null)[];\n\n  columnBlankGroups?: (number | null)[];\n  rowBlankGroups?: (number | null)[];\n\n  columnNoTriple?: boolean[];\n  rowNoTriple?: boolean[];\n\n  forcedCells?: { row: number; col: number; on: boolean }[];\n  countAreas?: { row: number; col: number; count: number }[];\n\n  globalCount?: number;\n\n  config?: PuzzleConfig;\n}\n\nexport const initPuzzle = (id: string, options: PuzzleRules) => {\n  const { rows, cols, config } = options;\n\n  const rules = new PuzzleValidatorFactory();\n\n  if (options.columnCounts) {\n    rules.addColumnCounts(options.columnCounts);\n  }\n  if (options.rowCounts) {\n    rules.addRowCounts(options.rowCounts);\n  }\n  if (options.columnGroups) {\n    rules.addColumnGroups(options.columnGroups);\n  }\n  if (options.rowGroups) {\n    rules.addRowGroups(options.rowGroups);\n  }\n  if (options.columnBlankGroups) {\n    rules.addColumnBlankGroups(options.columnBlankGroups);\n  }\n  if (options.rowBlankGroups) {\n    rules.addRowBlankGroups(options.rowBlankGroups);\n  }\n  if (options.columnNoTriple) {\n    rules.addColumnNoTriple(options.columnNoTriple);\n  }\n  if (options.rowNoTriple) {\n    rules.addRowNoTriple(options.rowNoTriple);\n  }\n  if (options.forcedCells) {\n    options.forcedCells.forEach((cell) => {\n      rules.addForcedCellValidator(cell.row, cell.col, cell.on);\n    });\n  }\n  if (options.countAreas) {\n    options.countAreas.forEach((cell) => {\n      rules.addCountAreaValidator(cell.row, cell.col, cell.count);\n    });\n  }\n  if (options.globalCount) {\n    rules.setGlobalCount(options.globalCount);\n  }\n\n  return new Puzzle(id, rows, cols, rules.create(), config);\n};\n", "import { DataLoader } from \"../level/DataLoader\";\nimport { Puzzle } from \"./Puzzle\";\nimport { initPuzzle } from \"./PuzzleFactory\";\n\nfunction makePuzzle(id: string): Puzzle {\n  const rules = DataLoader.puzzles;\n  if (id in rules) {\n    return initPuzzle(id, rules[id]);\n  }\n\n  console.warn(`Cannot find puzzle with id: ${id}`);\n\n  return initPuzzle(id, {\n    rows: 1,\n    cols: 1,\n    rowCounts: [1],\n    columnCounts: [1],\n  });\n}\n\nclass PuzzleManagerInstance {\n  puzzleMap: Record<string, Puzzle>;\n\n  constructor() {\n    this.puzzleMap = {};\n  }\n\n  loadPuzzle(id: string): Puzzle {\n    return makePuzzle(id);\n  }\n\n  getPuzzle(id: string) {\n    if (id in this.puzzleMap) {\n      return this.puzzleMap[id];\n    }\n\n    const puzzle = this.loadPuzzle(id);\n    this.puzzleMap[id] = puzzle;\n\n    return puzzle;\n  }\n}\n\nexport const PuzzleManager = new PuzzleManagerInstance();\n", "import { ExitTrigger } from \"./ExitTrigger\";\n\nexport class LevelEvent {\n  constructor() {}\n\n  isExitEvent() {\n    return false;\n  }\n\n  isOpenPuzzleEvent() {\n    return false;\n  }\n\n  isClosePuzzleEvent() {\n    return false;\n  }\n}\n\nexport class ExitEvent extends LevelEvent {\n  exitTrigger: ExitTrigger;\n\n  constructor(exitTrigger: ExitTrigger) {\n    super();\n    this.exitTrigger = exitTrigger;\n  }\n\n  isExitEvent() {\n    return true;\n  }\n}\n\nexport class OpenPuzzleEvent extends LevelEvent {\n  puzzleId: string;\n\n  constructor(puzzleId: string) {\n    super();\n    this.puzzleId = puzzleId;\n  }\n\n  isOpenPuzzleEvent() {\n    return true;\n  }\n}\n\nexport class ClosePuzzleEvent extends LevelEvent {\n  puzzleId: string;\n\n  constructor(puzzleId: string) {\n    super();\n    this.puzzleId = puzzleId;\n  }\n\n  isClosePuzzleEvent() {\n    return true;\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport {\n  DEFAULT_BACKGROUND,\n  SOLVED_BACKGROUND,\n} from \"../../puzzle-manager/constants\";\nimport { Puzzle } from \"../../puzzle-manager/Puzzle\";\nimport { PuzzleManager } from \"../../puzzle-manager/PuzzleManager\";\nimport { ScreenManager } from \"../../ScreenManager\";\n\nimport { OpenPuzzleEvent } from \"../LevelEvent\";\n\nimport { Interactible } from \"./Interactible\";\n\ninterface Config {\n  isFlipped?: boolean;\n}\n\nconst SCREEN_W = 1;\n\nconst DRAW_CIRCLES = false;\n\nexport class PuzzleInteractible extends Interactible {\n  puzzleId: string;\n  puzzle: Puzzle;\n  config: Config;\n\n  constructor(\n    id: string,\n    position: Vector,\n    area: Rectangle,\n    prereqs: string[],\n    puzzleId: string,\n    config: Config\n  ) {\n    super(id, position, area, prereqs);\n\n    this.puzzleId = puzzleId;\n    this.puzzle = PuzzleManager.getPuzzle(puzzleId);\n    this.connectionPoint = Vector.add(position, new Vector(0, 1.2));\n    this.outputPoint = Vector.add(\n      position,\n      new Vector(config.isFlipped ? -1 : 1, -1.15)\n    );\n    this.config = config;\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const PIXEL_SCALE = 1 / PIXELS_PER_TILE;\n\n    // Draw monitor leg\n    canvas.setColorRGB(0, 0, 0);\n    canvas.fillRect(\n      this.position.x - SCREEN_W / 2,\n      this.position.y + SCREEN_W,\n      SCREEN_W,\n      1\n    );\n\n    canvas.setLineWidth(PIXEL_SCALE);\n\n    // Draw hover outline\n    if (this.isAreaActive) {\n      canvas.setColorRGB(255, 255, 255, 128);\n      canvas.strokeRectInset(\n        this.position.x,\n        this.position.y,\n        0,\n        0,\n        -SCREEN_W - PIXEL_SCALE * 1.5\n      );\n    }\n\n    // Draw monitor outline\n    canvas.setColorRGB(0, 0, 0);\n    canvas.strokeRectInset(\n      this.position.x,\n      this.position.y,\n      0,\n      0,\n      -SCREEN_W - PIXEL_SCALE / 2\n    );\n\n    // Draw light area\n    const isFlippedMul = this.config.isFlipped ? -1 : 1;\n    canvas.fillRect(\n      this.position.x +\n        isFlippedMul * (SCREEN_W - PIXEL_SCALE) -\n        2 * PIXEL_SCALE,\n      this.position.y - SCREEN_W - 4 * PIXEL_SCALE,\n      4 * PIXEL_SCALE,\n      4 * PIXEL_SCALE\n    );\n\n    if (this.puzzle.hasBeenSolvedEver) {\n      this.isEnabled = true;\n      canvas.setColor(\"white\");\n      canvas.fillRect(\n        this.position.x + isFlippedMul * (SCREEN_W - PIXEL_SCALE) - PIXEL_SCALE,\n        this.position.y - SCREEN_W - 3 * PIXEL_SCALE,\n        PIXEL_SCALE * 2,\n        PIXEL_SCALE * 2\n      );\n    }\n\n    if (this.prereqsActive) {\n      // Draw screen\n      canvas.setColor(\n        this.puzzle.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND\n      );\n      canvas.fillRect(\n        this.position.x - SCREEN_W,\n        this.position.y - SCREEN_W,\n        SCREEN_W * 2,\n        SCREEN_W * 2\n      );\n    }\n\n    this.drawGrid(canvas);\n  }\n\n  drawGrid(canvas: Canvas) {\n    const offset = new Vector(\n      this.position.x - SCREEN_W,\n      this.position.y - SCREEN_W\n    );\n\n    canvas.translate(offset.x, offset.y);\n\n    canvas.setColor(\"white\");\n\n    // Draw current selection\n    const grid = this.puzzle.grid;\n    const SCREEN_PIXEL =\n      (SCREEN_W * 2) / (3 * Math.max(grid.length, grid[0].length) + 1);\n    const SCR_WIDTH = SCREEN_PIXEL * (3 * grid[0].length + 1);\n    const SCR_HEIGHT = SCREEN_PIXEL * (3 * grid.length + 1);\n\n    const TOP_PAD = Math.max(0, (SCR_WIDTH - SCR_HEIGHT) / 2);\n    const LEFT_PAD = Math.max(0, (SCR_HEIGHT - SCR_WIDTH) / 2);\n\n    this.puzzle.miniElements.forEach(({ row, col, shape }) => {\n      if (this.puzzle.values[grid[row][col].id]) {\n        const x0 = LEFT_PAD + SCREEN_PIXEL * (3 * shape.x1 + 1);\n        const y0 = TOP_PAD + SCREEN_PIXEL * (3 * shape.y1 + 1);\n        const w = SCREEN_PIXEL * (3 * shape.width - 1);\n        const h = SCREEN_PIXEL * (3 * shape.height - 1);\n        if (DRAW_CIRCLES) {\n          canvas.fillEllipse(x0 + w / 2, y0 + h / 2, w / 2, h / 2);\n        } else {\n          canvas.fillRect(x0, y0, w, h);\n        }\n      }\n    });\n\n    canvas.translate(-offset.x, -offset.y);\n  }\n\n  onInteract() {\n    return new OpenPuzzleEvent(this.puzzleId);\n  }\n}\n", "import { EntityImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nexport class SwitchInteractible extends Interactible {\n  constructor(\n    id: string,\n    position: Vector,\n    area: Rectangle,\n    prerequisites: string[]\n  ) {\n    super(id, position, area, prerequisites);\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    if (this.isEnabled) {\n      this.isAreaActive = false;\n    } else {\n      super.update(player, deltaTime, level);\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const PIXEL_SCALE = 1 / PIXELS_PER_TILE;\n\n    // Draw hover outline\n    if (this.isAreaActive) {\n      canvas.setColorRGB(255, 255, 255, 128);\n      canvas.setLineWidth(PIXEL_SCALE);\n      canvas.setLineDash([]);\n      canvas.strokeRectInset(\n        this.position.x - PIXEL_SCALE * 3,\n        this.position.y - PIXEL_SCALE * 4,\n        PIXEL_SCALE * 6,\n        PIXEL_SCALE * 8,\n        -PIXEL_SCALE * 1.5\n      );\n    }\n\n    canvas.drawImage(\n      EntityImage,\n      this.isEnabled ? 80 : 40,\n      0,\n      PIXELS_PER_TILE * 4,\n      PIXELS_PER_TILE * 4,\n      this.position.x - 2,\n      this.position.y - 2,\n      4,\n      4\n    );\n  }\n\n  onInteract() {\n    this.isEnabled = true;\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport { EntityImage, TileImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { BlockEnum } from \"../BlockTypes\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nconst mockTrigger = {\n  intersectsPoint: () => false,\n  stroke: () => null,\n};\n\nconst OPEN_CLOSE_DUR = 0.3;\n\ninterface Config {\n  isFlipped?: boolean;\n  hasLedge?: boolean;\n  isSingle?: boolean;\n}\n\nexport class TrapdoorInteractible extends Interactible {\n  hasLeft: boolean;\n  hasRight: boolean;\n  hasLedge: boolean;\n\n  leftHead: Rectangle;\n  rightHead: Rectangle;\n  leftDoor: Rectangle;\n  rightDoor: Rectangle;\n\n  ledge: Rectangle;\n\n  fullWidth: number;\n  doorWidth: number;\n\n  constructor(\n    id: string,\n    position: Vector,\n    prerequisites: string[],\n    width = 4,\n    config: Config = {}\n  ) {\n    super(id, position, undefined, prerequisites);\n\n    this.connectionPoint = Vector.add(\n      position,\n      new Vector((config.isFlipped ? 1 : -1) * (width / 2 - 0.9), 0.3)\n    );\n\n    const isDouble = !config.isSingle;\n\n    this.hasLeft = isDouble || !config.isFlipped;\n    this.hasRight = isDouble || !!config.isFlipped;\n\n    this.hasLedge = !!config.hasLedge;\n\n    this.leftHead = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      1.2,\n      0.8\n    );\n    this.rightHead = Rectangle.widthForm(\n      this.position.x + width / 2 - 1.2,\n      this.position.y,\n      1.2,\n      0.8\n    );\n    this.leftDoor = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      this.hasRight ? width / 2 : width,\n      0.6\n    );\n    this.rightDoor = Rectangle.widthForm(\n      this.position.x - (this.hasLeft ? 0 : width / 2),\n      this.position.y,\n      this.hasLeft ? width / 2 : width,\n      0.6\n    );\n\n    this.ledge = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      width,\n      0.2\n    );\n\n    this.fullWidth = width / 2;\n    this.doorWidth = this.hasLeft && this.hasRight ? width / 2 : width;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n\n    if (this.hasLeft) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.leftHead,\n      });\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.leftDoor,\n      });\n    }\n    if (this.hasRight) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.rightHead,\n      });\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.rightDoor,\n      });\n    }\n\n    if (this.hasLedge) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.LEDGE,\n        rect: this.ledge,\n      });\n    }\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const motion = (deltaTime / OPEN_CLOSE_DUR) * (this.prereqsActive ? -1 : 1);\n\n    this.leftDoor.x2 = clamp(\n      this.leftDoor.x2 + motion,\n      this.leftDoor.x1,\n      this.leftDoor.x1 + this.doorWidth\n    );\n\n    this.rightDoor.x1 = clamp(\n      this.rightDoor.x1 - motion,\n      this.rightDoor.x2 - this.doorWidth,\n      this.rightDoor.x2\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (this.hasLedge) {\n      for (let x = this.ledge.x1; x < this.ledge.x2; x++) {\n        canvas.drawImage(\n          TileImage,\n          PIXELS_PER_TILE,\n          0,\n          PIXELS_PER_TILE,\n          PIXELS_PER_TILE,\n          x,\n          this.ledge.y1,\n          1,\n          1\n        );\n      }\n    }\n\n    if (this.hasLeft) {\n      const w = this.leftDoor.width;\n      if (w > 0) {\n        canvas.setColor(\"black\");\n        this.leftDoor.draw(canvas);\n        canvas.drawImage(\n          EntityImage,\n          160 + Math.max(40 - 10 * w, 20) - 10,\n          10,\n          Math.min(10 * w, 20),\n          10,\n          Math.max(this.leftDoor.x1, this.leftDoor.x2 - 2),\n          this.position.y,\n          Math.min(w, 2),\n          1\n        );\n      }\n\n      canvas.drawImage(\n        EntityImage,\n        this.prereqsActive ? 180 : 160,\n        0,\n        12,\n        8,\n        this.leftHead.x1,\n        this.leftHead.y1,\n        this.leftHead.width,\n        this.leftHead.height\n      );\n    }\n    if (this.hasRight) {\n      const w = this.rightDoor.width;\n      if (w > 0) {\n        canvas.setColor(\"black\");\n        this.rightDoor.draw(canvas);\n        canvas.drawImage(\n          EntityImage,\n          170,\n          30,\n          Math.min(10 * w, 20),\n          10,\n          this.rightDoor.x1,\n          this.position.y,\n          Math.min(w, 2),\n          1\n        );\n      }\n\n      canvas.drawImage(\n        EntityImage,\n        this.prereqsActive ? 188 : 168,\n        20,\n        12,\n        8,\n        this.rightHead.x1,\n        this.rightHead.y1,\n        this.rightHead.width,\n        this.rightHead.height\n      );\n    }\n  }\n\n  drawForMap(canvas: Canvas): void {\n    canvas.setColor(\"black\");\n\n    if (this.hasLeft) {\n      this.leftDoor.draw(canvas);\n    }\n    if (this.hasRight) {\n      this.rightDoor.draw(canvas);\n    }\n  }\n}\n", "const HEX = 16;\nconst ZERO = \"0\";\n\n/**\n * A function to convert a number to a zero-padded hex string.\n * @param {number} number The number to be converted\n * @param {number} digits The expected length (for zero-padding purposes)\n */\nexport const toHex = (number: number, digits: number) => {\n  return number.toString(HEX).padStart(digits, ZERO);\n};\n\nexport const rgbaColor = (\n  red: number,\n  green: number,\n  blue: number,\n  alpha = 255\n) => {\n  return `#${toHex(red, 2)}${toHex(green, 2)}${toHex(blue, 2)}${toHex(\n    alpha,\n    2\n  )}`;\n};\n\nexport const hslaColor = (\n  hue: number,\n  saturation: number,\n  lightness: number,\n  alpha = 1\n) => {\n  return `hsla(${hue},${Math.floor(saturation * 100)}%,${Math.floor(\n    lightness * 100\n  )}%,${alpha})`;\n};\n", "import { Canvas } from \"../../Canvas\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { rgbaColor } from \"../../utils/Color\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Entity } from \"./Entity\";\n\nconst UNCOVER_DURATION = 1;\n\ninterface Config {\n  coverIsTrigger?: boolean;\n  canReCover?: boolean;\n}\n\nexport class CoverEntity extends Entity {\n  coverArea: Rectangle;\n  extraCovers: Rectangle[];\n  triggerArea: Rectangle;\n\n  coverIsTrigger: boolean;\n  canReCover: boolean;\n  isUncovered: boolean;\n\n  revealState: number;\n\n  lastPlayerPos: Vector | undefined;\n\n  constructor(\n    id: string,\n    coverArea: Rectangle,\n    extraCovers: Rectangle[],\n    triggerArea: Rectangle,\n    config: Config = {}\n  ) {\n    super(id);\n\n    this.coverArea = coverArea;\n    this.extraCovers = extraCovers;\n    this.triggerArea = triggerArea;\n\n    this.coverIsTrigger = !!config.coverIsTrigger;\n    this.canReCover = !!config.canReCover;\n\n    this.isUncovered = false;\n    this.revealState = 0;\n  }\n\n  playerCollidesCover(player: Player) {\n    return (\n      this.coverArea.intersectsPoint(player.position) ||\n      this.extraCovers.some((cover) => cover.intersectsPoint(player.position))\n    );\n  }\n\n  isPlayerTriggering(player: Player) {\n    return (\n      this.triggerArea.intersectsPoint(player.position) ||\n      (this.coverIsTrigger && this.playerCollidesCover(player))\n    );\n  }\n\n  isOpen(player: Player) {\n    if (!this.canReCover) {\n      if (this.isUncovered) {\n        return true;\n      } else {\n        this.isUncovered = this.isPlayerTriggering(player);\n        return this.isUncovered;\n      }\n    } else {\n      return this.isPlayerTriggering(player);\n    }\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const isOpen = this.isOpen(player);\n\n    this.revealState = clamp(\n      this.revealState + (isOpen ? 1 : -1) * (deltaTime / UNCOVER_DURATION),\n      0,\n      1\n    );\n\n    this.lastPlayerPos = player.position;\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    // Nothing to draw if fully revealed\n    if (this.revealState === 1) {\n      return;\n    }\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (this.revealState === 0) {\n      canvas.setColor(\"black\");\n    } else {\n      const size = this.coverArea.width + this.coverArea.height;\n\n      const fadeRange = size * 0.2;\n      const pos = this.lastPlayerPos\n        ? Vector.lerp(\n            this.lastPlayerPos,\n            this.coverArea.midpoint,\n            this.revealState\n          )\n        : this.coverArea.midpoint;\n\n      const rOut = (size + fadeRange) * this.revealState;\n      const gradient = canvas.createRadialGradient(\n        pos.x,\n        pos.y,\n        Math.max(0, rOut - fadeRange / 2),\n        pos.x,\n        pos.y,\n        rOut + fadeRange / 2\n      );\n      gradient.addColorStop(0, rgbaColor(0, 0, 0, 0));\n      gradient.addColorStop(1, rgbaColor(0, 0, 0, 255));\n\n      canvas.setColor(gradient);\n    }\n\n    this.coverArea.draw(canvas);\n    this.extraCovers.forEach((cover) => cover.draw(canvas));\n  }\n\n  drawForMap(canvas: Canvas) {\n    if (this.revealState !== 1) {\n      canvas.setColor(\"black\");\n      for (const rect of this.extraCovers.concat(this.coverArea)) {\n        rect.draw(canvas, 0.05);\n      }\n    }\n  }\n}\n", "import { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { Player } from \"./Player\";\n\nexport class ExitTrigger {\n  collider: Rectangle;\n  key: string;\n  nextLevelCollider: Rectangle;\n\n  constructor(collider: Rectangle, key: string, nextLevelCollider: Rectangle) {\n    this.collider = collider;\n    this.key = key;\n    this.nextLevelCollider = nextLevelCollider || collider;\n  }\n\n  hasEntered(player: Player) {\n    return this.collider.intersectsPoint(player.position);\n  }\n\n  translatePlayerToNext(player: Player) {\n    return Vector.diff(\n      player.position,\n      new Vector(this.nextLevelCollider.x1, this.nextLevelCollider.y1)\n    );\n  }\n}\n", "const Up = Symbol(\"Up\");\nconst Down = Symbol(\"Down\");\nconst Left = Symbol(\"Left\");\nconst Right = Symbol(\"Right\");\nconst Jump = Symbol(\"Jump\");\nconst Interact = Symbol(\"Interact\");\nconst Escape = Symbol(\"Escape\");\nconst Map = Symbol(\"Map\");\n\n// TODO Convert this to an enum\nexport const Input = {\n  Down,\n  Escape,\n  Interact,\n  Jump,\n  Left,\n  Right,\n  Up,\n  Map,\n};\n", "import { Input } from \"./constants/Keys\";\nimport {\n  UI_CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_WIDTH,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nconst KEY_MAP: Record<string, Key> = {\n  \" \": Input.Jump,\n  escape: Input.Escape,\n  esc: Input.Escape,\n  Escape: Input.Escape,\n  Esc: Input.Escape,\n  w: Input.Up,\n  a: Input.Left,\n  s: Input.Down,\n  d: Input.Right,\n  e: Input.Interact,\n  m: Input.Map,\n};\n\ntype ValueOf<T> = T[keyof T];\n\ntype Key = ValueOf<typeof Input>;\n\ntype KeyMap = Record<Key, boolean>;\n\nexport class InputState {\n  keyMap: KeyMap;\n  mousePosition: Vector;\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  constructor(\n    keyMap: KeyMap,\n    mousePosition: Vector,\n    leftClicking: boolean = false,\n    rightClicking: boolean = false\n  ) {\n    this.keyMap = keyMap;\n    this.mousePosition = mousePosition;\n    this.leftClicking = leftClicking;\n    this.rightClicking = rightClicking;\n  }\n\n  /**\n   * Check the current value for the horizontal axis input.\n   * @return {number} a value from -1 to 1.\n   */\n  getHorizontalAxis() {\n    return +!!this.keyMap[Input.Right] - +!!this.keyMap[Input.Left];\n  }\n\n  getVerticalAxis() {\n    return +!!this.keyMap[Input.Down] - +!!this.keyMap[Input.Up];\n  }\n\n  /**\n   * Checks whether an input is currently pressed.\n   * @param {Input} input\n   */\n  isPressed(input: Key) {\n    return !!this.keyMap[input];\n  }\n\n  isLeftClicking() {\n    return this.leftClicking;\n  }\n\n  isRightClicking() {\n    return this.rightClicking;\n  }\n\n  static empty() {\n    return new InputState({}, new Vector(0, 0));\n  }\n}\n\nexport class InputEvent {\n  constructor() {}\n\n  isForKey(_key: Key) {\n    return false;\n  }\n\n  isClick() {\n    return false;\n  }\n\n  isScroll() {\n    return false;\n  }\n}\n\nexport class KeyPressEvent extends InputEvent {\n  input: Key;\n\n  constructor(input: Key) {\n    super();\n    this.input = input;\n  }\n\n  isForKey(key: Key) {\n    return key === this.input;\n  }\n}\n\nexport class ClickEvent extends InputEvent {\n  position: Vector;\n  isRight: boolean;\n\n  constructor(position: Vector, isRightClick: boolean) {\n    super();\n    this.position = position;\n    this.isRight = isRightClick;\n  }\n\n  isClick() {\n    return true;\n  }\n\n  isRightClick() {\n    return this.isRight;\n  }\n}\n\nexport class ScrollEvent extends InputEvent {\n  delta: number;\n\n  constructor(delta: number) {\n    super();\n    this.delta = delta;\n  }\n\n  isScroll() {\n    return true;\n  }\n}\n\nexport class InputManager {\n  listener: (inputEvent: InputEvent) => void;\n\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  isButtonDown: KeyMap;\n  mousePosition: Vector;\n\n  canvas: HTMLCanvasElement;\n\n  constructor(listener: (inputEvent: InputEvent) => void) {\n    this.leftClicking = false;\n    this.rightClicking = false;\n\n    this.isButtonDown = {};\n    this.listener = listener;\n    this.mousePosition = new Vector(0, 0);\n\n    this.canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  }\n\n  /**\n   * Set up event listeners.\n   */\n  init() {\n    const onKeyEvent = (symbol: Key) => {\n      if (this.listener) {\n        this.listener(new KeyPressEvent(symbol));\n      }\n    };\n\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.repeat) {\n        return;\n      }\n      const symbol = KEY_MAP[e.key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = true;\n      onKeyEvent(symbol);\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const symbol = KEY_MAP[e.key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = false;\n    });\n\n    document.addEventListener(\"mousemove\", (event) => {\n      this.mousePosition = this.toCanvasPosition(event);\n    });\n\n    document.addEventListener(\"mousedown\", (event) => {\n      this.mousePosition = this.toCanvasPosition(event);\n\n      if (event.button === 0) {\n        this.listener?.(new ClickEvent(this.mousePosition, false));\n        this.leftClicking = true;\n      } else if (event.button === 2) {\n        this.listener?.(new ClickEvent(this.mousePosition, true));\n        this.rightClicking = true;\n      }\n    });\n\n    document.addEventListener(\"mouseup\", (event) => {\n      if (event.button === 0) {\n        this.leftClicking = false;\n      } else if (event.button === 2) {\n        this.rightClicking = false;\n      }\n    });\n\n    document.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n\n    // Stop current clicks on mouse leave\n    this.canvas.addEventListener(\"mouseleave\", () => {\n      this.leftClicking = false;\n      this.rightClicking = false;\n    });\n\n    this.canvas.addEventListener(\"wheel\", (event) => {\n      this.listener?.(new ScrollEvent(event.deltaY));\n    });\n\n    const wireButton = (id: string, input: Key) => {\n      const btn = document.getElementById(id);\n\n      if (!btn) {\n        return;\n      }\n\n      btn.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n        this.isButtonDown[input] = true;\n\n        onKeyEvent(input);\n      });\n\n      btn.addEventListener(\"touchcancel\", (e) => {\n        e.preventDefault();\n        this.isButtonDown[input] = false;\n      });\n\n      btn.addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        this.isButtonDown[input] = false;\n      });\n    };\n\n    wireButton(\"left\", Input.Left);\n    wireButton(\"right\", Input.Right);\n    wireButton(\"jump\", Input.Jump);\n    wireButton(\"down\", Input.Down);\n    wireButton(\"escape\", Input.Escape);\n    wireButton(\"interact\", Input.Interact);\n  }\n\n  toCanvasPosition(event: MouseEvent) {\n    return Vector.scale(\n      new Vector(\n        event.clientX - this.canvas.offsetLeft,\n        event.clientY - this.canvas.offsetTop\n      ),\n      ((this.canvas.width / this.canvas.clientWidth) * UI_CANVAS_WIDTH) /\n        ON_SCREEN_CANVAS_WIDTH\n    );\n  }\n\n  /**\n   * @return {InputState} The current state of inputs\n   */\n  getInputState() {\n    return new InputState(\n      this.isButtonDown,\n      this.mousePosition,\n      this.leftClicking,\n      this.rightClicking\n    );\n  }\n}\n", "import { Canvas } from \"../../Canvas\";\nimport {\n  HORIZONTAL_TILES,\n  PIXELS_PER_TILE,\n  PIXEL_WIDTH,\n  VERTICAL_TILES,\n} from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { hslaColor } from \"../../utils/Color\";\n\ntype DrawAction = (canvas: Canvas, width: number, height: number) => void;\n\nexport class BackgroundArtist {\n  width: number;\n  height: number;\n\n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n  }\n\n  lerpFactor(index: number, screenManager: ScreenManager) {\n    return (index + 1) / screenManager.parallax.length;\n  }\n\n  *iterateArea(\n    width: number,\n    height: number,\n    xStep: number,\n    yStep: number\n  ): Generator<[number, number, Rectangle]> {\n    let col = 0;\n    for (let x = 0; x < width; x += xStep) {\n      let row = 0;\n      for (let y = 0; y < height; y += yStep) {\n        yield [row, col, Rectangle.widthForm(x, y, xStep, yStep)];\n        row++;\n      }\n      col++;\n    }\n  }\n\n  prepareCanvas(\n    screenManager: ScreenManager,\n    index: number,\n    hue: number,\n    backColor: Vector,\n    foreColor: Vector,\n    action: DrawAction\n  ) {\n    const factor = this.lerpFactor(index, screenManager);\n    const scale = PIXELS_PER_TILE * PIXEL_WIDTH;\n    const minSize = new Vector(\n      HORIZONTAL_TILES * scale,\n      VERTICAL_TILES * scale\n    );\n    const fullSize = new Vector(this.width * scale, this.height * scale);\n\n    const size = Vector.lerp(minSize, fullSize, factor);\n    const canvas = screenManager.parallax[index];\n\n    const color = Vector.lerp(backColor, foreColor, factor);\n\n    canvas.setColor(hslaColor(hue, color.x, color.y));\n\n    action(canvas, size.x, size.y);\n  }\n\n  draw(screenManager: ScreenManager) {\n    const hue = 154;\n    const backgroundColor = new Vector(0.14, 0.72);\n    const foregroundColor = new Vector(0.14, 0.4);\n\n    screenManager.background.setColor(\n      hslaColor(hue, backgroundColor.x, backgroundColor.y)\n    );\n    screenManager.background.fillRect(\n      0,\n      0,\n      screenManager.background.width,\n      screenManager.background.height\n    );\n\n    for (const canvas of screenManager.parallax) {\n      canvas.clear();\n    }\n\n    // Thick horizontal and vertical beams\n    this.prepareCanvas(\n      screenManager,\n      0,\n      hue,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          70,\n          height\n        )) {\n          if (Math.random() > 0.95) {\n            rect.draw(canvas);\n          }\n        }\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          width,\n          70\n        )) {\n          if (Math.random() > 0.95) {\n            rect.draw(canvas);\n          }\n        }\n      }\n    );\n\n    // Structural vertical beams\n    this.prepareCanvas(\n      screenManager,\n      1,\n      hue,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          120,\n          height\n        )) {\n          if (Math.random() > 0.9) {\n            const thickWidth = 20;\n            canvas.setLineWidth(thickWidth * 2);\n            canvas.drawLine(rect.x1, rect.y1, rect.x1, rect.y2);\n            canvas.drawLine(rect.x2, rect.y1, rect.x2, rect.y2);\n\n            const beamWidth = 10;\n            canvas.setLineWidth(beamWidth * 2);\n            const yOffset = Math.floor(Math.random() * 240);\n            for (const [_row2, _col2, rect2] of this.iterateArea(\n              1,\n              height,\n              1,\n              240\n            )) {\n              const y = rect2.y1 + yOffset;\n              canvas.drawLine(rect.x1, y, rect.x2, y);\n              const radius = 20;\n              canvas.outerCircleCorner(\n                rect.x2 - thickWidth - radius,\n                y - beamWidth - radius,\n                20,\n                0\n              );\n              canvas.outerCircleCorner(\n                rect.x1 + thickWidth + radius,\n                y - beamWidth - radius,\n                20,\n                Math.PI / 2\n              );\n              canvas.outerCircleCorner(\n                rect.x1 + thickWidth + radius,\n                y + beamWidth + radius,\n                20,\n                Math.PI\n              );\n              canvas.outerCircleCorner(\n                rect.x2 - thickWidth - radius,\n                y + beamWidth + radius,\n                20,\n                (Math.PI * 3) / 2\n              );\n            }\n          }\n        }\n      }\n    );\n\n    // Boxes\n    this.prepareCanvas(\n      screenManager,\n      2,\n      hue,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        const xs = [],\n          ys = [];\n        for (let i = 0; i < width; i += 800) {\n          xs.push(Math.random() * width);\n        }\n        for (let i = 0; i < height; i += 600) {\n          ys.push(Math.random() * height);\n        }\n\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          50,\n          50\n        )) {\n          if (\n            xs.some((x) => rect.xInRange(x)) ||\n            ys.some((y) => rect.yInRange(y))\n          ) {\n            canvas.setLineWidth(12);\n            rect.stroke(canvas);\n            canvas.setLineWidth(6);\n            if (Math.random() > 0.2) {\n              canvas.drawLine(rect.x1, rect.y1, rect.x2, rect.y2);\n            }\n            if (Math.random() > 0.2) {\n              canvas.drawLine(rect.x2, rect.y1, rect.x1, rect.y2);\n            }\n          }\n        }\n      }\n    );\n\n    // Lots of narrow pipes\n    this.prepareCanvas(\n      screenManager,\n      3,\n      hue,\n      backgroundColor,\n      foregroundColor,\n      (canvas, width, height) => {\n        for (const [_row, _col, rect] of this.iterateArea(\n          width,\n          height,\n          30,\n          height\n        )) {\n          if (Math.random() > 0.92) {\n            rect.draw(canvas);\n          }\n        }\n      }\n    );\n  }\n\n  updateCameras(screenManager: ScreenManager) {\n    const back = new Vector(0, 0);\n    const front = screenManager.camera;\n    screenManager.parallax.forEach((_, index) => {\n      screenManager.parallaxCameras[index] = Vector.lerp(\n        back,\n        front,\n        this.lerpFactor(index, screenManager)\n      );\n    });\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { TileImage } from \"../constants/Image\";\nimport { Input } from \"../constants/Keys\";\nimport {\n  CANVAS_WIDTH,\n  HORIZONTAL_TILES,\n  PIXELS_PER_TILE,\n  VERTICAL_TILES,\n} from \"../constants/ScreenConstants\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { clamp } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nimport { Entity } from \"./entity/Entity\";\n\nimport { BlockEnum } from \"./BlockTypes\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport {\n  ClosePuzzleEvent,\n  ExitEvent,\n  LevelEvent,\n  OpenPuzzleEvent,\n} from \"./LevelEvent\";\nimport { Interactible } from \"./interactibles/Interactible\";\nimport { Player } from \"./Player\";\nimport { PlayMode } from \"../game-modes/PlayMode\";\nimport { BackgroundArtist } from \"./background/BackgroundArtist\";\n\nconst SCALE_FACTOR = CANVAS_WIDTH / HORIZONTAL_TILES;\n\nexport interface Object {\n  type: BlockEnum;\n  rect: Rectangle;\n}\n\nexport class Level {\n  key: string;\n  levelGrid: BlockEnum[][];\n  width: number;\n  height: number;\n\n  player: Player;\n\n  objects: Object[];\n  exitTriggers: ExitTrigger[];\n  interactibles: Interactible[];\n  entities: Entity[];\n\n  camera: Vector;\n  interactingWith: Interactible | undefined;\n\n  backgroundArtist: BackgroundArtist;\n  drawnStatic: boolean;\n  playModeManager: PlayMode | undefined;\n\n  worldPosition: Vector;\n\n  visited: boolean;\n\n  constructor(\n    key: string,\n    width: number,\n    height: number,\n    levelGrid: BlockEnum[][],\n    objects: Object[],\n    player: Player,\n    exitTriggers: ExitTrigger[],\n    interactibles: Interactible[],\n    entities: Entity[],\n    worldPosition: Vector\n  ) {\n    this.key = key;\n    this.levelGrid = levelGrid;\n    this.objects = objects;\n    this.player = player;\n    this.exitTriggers = exitTriggers;\n    this.interactibles = interactibles;\n    this.entities = entities;\n\n    this.width = width;\n    this.height = height;\n\n    this.camera = this.getIdealCamera();\n    this.interactingWith = undefined;\n\n    this.backgroundArtist = new BackgroundArtist(width, height);\n    this.drawnStatic = false;\n    this.playModeManager = undefined;\n\n    this.worldPosition = worldPosition;\n\n    this.visited = false;\n  }\n\n  start(playModeManager: PlayMode) {\n    this.onAwaken();\n\n    this.interactingWith = undefined;\n    this.playModeManager = playModeManager;\n    this.interactibles.forEach((i) => i.onStart(this));\n    this.entities.forEach((e) => e.onStart(this));\n\n    this.visited = true;\n  }\n\n  onAwaken() {\n    this.drawnStatic = false;\n    this.interactibles.forEach((i) => i.onAwaken());\n    this.entities.forEach((e) => e.onAwaken());\n  }\n\n  addWithoutDuplicate(object: Object) {\n    if (!this.objects.find(({ rect }) => rect === object.rect)) {\n      this.objects.push(object);\n    }\n  }\n\n  emitEvent(event: LevelEvent) {\n    // TODO: Either guarantee that this is available or create a queue to send\n    // these events once it does become available.\n    if (this.playModeManager) {\n      this.playModeManager.onLevelEvent(event);\n    }\n  }\n\n  feedPlayerInfo(previousPlayer: Player, previousExit: ExitTrigger) {\n    if (previousExit.key !== this.key) {\n      console.error(\"Exit key mis-match\");\n    }\n    const position = previousExit.translatePlayerToNext(previousPlayer);\n\n    this.player.position.x = position.x;\n    this.player.position.y = position.y;\n\n    this.player.velocity = previousPlayer.velocity.copy();\n\n    this.camera = this.getIdealCamera();\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    // Update player\n    this.player.update(\n      deltaTime,\n      this.isPlayerActive() ? inputState : InputState.empty(),\n      this\n    );\n\n    // Update interactibles\n    this.interactibles.forEach((interactible) => {\n      interactible.update(this.player, deltaTime, this);\n    });\n    if (!this.interactingWith?.isAreaActive) {\n      this.closeCurrentPuzzle();\n    }\n\n    // Update entities\n    this.entities.forEach((entity) => {\n      entity.update(this.player, deltaTime, this);\n    });\n\n    this.updateCamera(deltaTime);\n\n    this.updateExits();\n  }\n\n  isPlayerActive() {\n    return !this.interactingWith;\n  }\n\n  closeCurrentPuzzle() {\n    // Don't close unnecessarily\n    if (this.interactingWith) {\n      this.emitEvent(new ClosePuzzleEvent(this.interactingWith.id));\n\n      this.interactingWith = undefined;\n    }\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (this.isPlayerActive()) {\n      this.player.onInput(input);\n    }\n\n    if (input.isForKey(Input.Interact)) {\n      if (this.interactingWith) {\n        this.closeCurrentPuzzle();\n      } else {\n        const relevant = this.interactibles.find((i) => i.isAreaActive);\n        if (relevant) {\n          const event = relevant.onInteract();\n\n          if (event && event instanceof OpenPuzzleEvent) {\n            this.interactingWith = relevant;\n            this.emitEvent(event);\n          }\n        }\n      }\n    } else if (input.isForKey(Input.Escape)) {\n      this.closeCurrentPuzzle();\n    }\n  }\n\n  /**\n   * Check if the player should exit.\n   * @returns The trigger key.\n   */\n  updateExits() {\n    const triggeredExit = this.exitTriggers.find((trigger) =>\n      trigger.hasEntered(this.player)\n    );\n\n    if (triggeredExit) {\n      this.emitEvent(new ExitEvent(triggeredExit));\n    }\n  }\n\n  clampCamera(camera: Vector) {\n    const clampedToPlayer = new Vector(\n      clamp(\n        camera.x,\n        this.player.position.x - HORIZONTAL_TILES + 1,\n        this.player.position.x - 1\n      ),\n      clamp(\n        camera.y,\n        this.player.position.y - VERTICAL_TILES + 1,\n        this.player.position.y - 1\n      )\n    );\n    const clampedToLevel = new Vector(\n      clamp(clampedToPlayer.x, 0, this.width - HORIZONTAL_TILES),\n      clamp(clampedToPlayer.y, 0, this.height - VERTICAL_TILES)\n    );\n\n    return clampedToLevel;\n  }\n\n  getNaiveCamera(position = this.player.position) {\n    return new Vector(\n      position.x - HORIZONTAL_TILES / 2,\n      position.y - VERTICAL_TILES / 2\n    );\n  }\n\n  getIdealCamera(position = this.player.position) {\n    return this.clampCamera(this.getNaiveCamera(position));\n  }\n\n  updateCamera(deltaTime: number) {\n    this.camera = this.clampCamera(\n      Vector.lerp(\n        this.camera,\n        this.getNaiveCamera(\n          Vector.add(\n            this.player.position,\n            new Vector(this.player.velocity.x * 0.3, 0)\n          )\n        ),\n        deltaTime * 2\n      )\n    );\n  }\n\n  withSetupCanvas(canvas: Canvas, action: (canvas: Canvas) => void) {\n    canvas.saveTransform();\n    canvas.scale(SCALE_FACTOR, SCALE_FACTOR);\n    action(canvas);\n    canvas.restoreTransform();\n  }\n\n  drawForMap(canvas: Canvas) {\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        const blockType = this.levelGrid[row][col];\n\n        if (blockType === BlockEnum.SOLID) {\n          canvas.setColor(\"black\");\n          canvas.fillRect(col - 0.05, row - 0.05, 1.1, 1.1);\n        } else if (blockType === BlockEnum.LEDGE) {\n          canvas.setColor(\"black\");\n          canvas.fillRect(col - 0.05, row - 0.05, 1.1, 0.2);\n        }\n      }\n    }\n\n    for (const interactible of this.interactibles) {\n      interactible.drawForMap(canvas);\n    }\n\n    for (const entity of this.entities) {\n      entity.drawForMap(canvas);\n    }\n  }\n\n  /**\n   * Draw the current level.\n   * @param {ScreenManager} screenManager The screen to draw on\n   */\n  draw(screenManager: ScreenManager) {\n    if (!this.drawnStatic) {\n      // Draw background\n      this.backgroundArtist.draw(screenManager);\n\n      this.withSetupCanvas(screenManager.staticWorldCanvas, (canvas) => {\n        canvas.clear();\n\n        canvas.setColor(\"black\");\n        for (let row = 0; row < this.height; row++) {\n          for (let col = 0; col < this.width; col++) {\n            const blockType = this.levelGrid[row][col];\n\n            if (blockType) {\n              canvas.drawImage(\n                TileImage,\n                (blockType - 1) * PIXELS_PER_TILE,\n                0,\n                PIXELS_PER_TILE,\n                PIXELS_PER_TILE,\n                col,\n                row,\n                1,\n                1\n              );\n            }\n          }\n        }\n      });\n\n      screenManager.uiCanvas.clear();\n\n      this.drawnStatic = true;\n    }\n\n    this.withSetupCanvas(screenManager.dynamicWorldCanvas, (canvas) => {\n      canvas.clear();\n\n      this.withSetupCanvas(screenManager.behindGroundCanvas, () => {\n        screenManager.behindGroundCanvas.clear();\n\n        // Draw interactibles\n        this.interactibles.forEach((interactible) => {\n          interactible.draw(screenManager);\n        });\n\n        // Draw player\n        this.player.draw(canvas);\n\n        // Draw entities\n        this.entities.forEach((entity) => {\n          entity.draw(screenManager);\n        });\n      });\n    });\n\n    screenManager.setCamera(\n      new Vector(\n        Math.floor(this.camera.x * SCALE_FACTOR),\n        Math.floor(this.camera.y * SCALE_FACTOR)\n      )\n    );\n\n    this.backgroundArtist.updateCameras(screenManager);\n  }\n}\n", "import { Rectangle } from \"../math/Shapes\";\n\n/**\n * They say premature optimization is the root of all evil.\n *\n * Oh no.\n */\n\nclass RectPoolClass {\n  grid: Rectangle[][];\n  shortGrid: Rectangle[][];\n\n  constructor() {\n    this.grid = [];\n    this.shortGrid = [];\n  }\n\n  innerGet(row: number, col: number, isShort: boolean, grid: Rectangle[][]) {\n    if (!(row in grid)) {\n      grid[row] = [];\n    }\n    if (!(col in grid[row])) {\n      grid[row][col] = Rectangle.widthForm(col, row, 1, isShort ? 0.2 : 1);\n    }\n\n    return grid[row][col];\n  }\n\n  get(row: number, col: number, isShort = false) {\n    return this.innerGet(\n      row,\n      col,\n      isShort,\n      isShort ? this.shortGrid : this.grid\n    );\n  }\n}\n\n// Woo! Singleton pattern again...\nexport const RectPool = new RectPoolClass();\n", "import { Canvas } from \"../Canvas\";\nimport { Input } from \"../constants/Keys\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { clamp, sign } from \"../math/Common\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { BlockEnum, BlockType } from \"./BlockTypes\";\nimport { Level } from \"./Level\";\n\nimport { RectPool } from \"./RectPool\";\n\nconst PLAYER_RADIUS = 0.8;\n\n// Running parameters\nconst PLAYER_MAX_SPEED = 16;\nconst PLAYER_ACCEL = PLAYER_MAX_SPEED / 0.3;\nconst PLAYER_DECEL = 2 * PLAYER_ACCEL;\nconst TURN_SPEED = 1.8 * PLAYER_ACCEL;\n\n// Jump speed parameters\nconst JUMP_HEIGHT = 4;\nconst JUMP_DURATION = 0.6;\nconst PARAM_A = (4 * JUMP_HEIGHT) / JUMP_DURATION;\nconst JUMP_INITIAL_SPEED = PARAM_A;\nconst GRAVITY = (2 * PARAM_A) / JUMP_DURATION;\n\n// Jump assist parameters\nconst COYOTE_TIME = 0.1;\n\n// Climbing parameters\nconst CLIMB_MAX_SPEED = PLAYER_MAX_SPEED * 0.5;\n\nfunction isDefined<T>(value: T | undefined): value is T {\n  return !!value;\n}\n\nenum PlayerState {\n  GROUND,\n  CLIMB,\n  AIR,\n}\n\nexport class Player {\n  position: Vector;\n  velocity: Vector;\n  collider: Circle;\n\n  isDropping: boolean;\n\n  wantsToJump: boolean;\n  contactingAnyLedge: boolean;\n  inAirFor: number;\n\n  state: PlayerState;\n\n  constructor(position: Vector) {\n    this.position = position;\n    this.collider = new Circle(position, PLAYER_RADIUS);\n\n    this.velocity = new Vector(0, 0);\n\n    this.isDropping = false;\n\n    this.wantsToJump = false;\n    this.contactingAnyLedge = false;\n    this.inAirFor = 1;\n\n    this.state = PlayerState.AIR;\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (input.isForKey(Input.Jump)) {\n      this.wantsToJump = true;\n    }\n  }\n\n  collideWithBlock(type: BlockEnum, rect: Rectangle, deltaTime: number) {\n    const isActiveLedge =\n      !this.isDropping &&\n      type === BlockEnum.LEDGE &&\n      this.velocity.y >= 0 &&\n      this.position.y < rect.y1;\n\n    const intersects = this.collider.intersectsRectangle(rect);\n\n    if (intersects && type === BlockEnum.LEDGE) {\n      this.contactingAnyLedge = true;\n      if (this.velocity.y < 0 && this.position.y >= rect.y1) {\n        this.isDropping = true;\n      }\n    }\n\n    if (BlockType.isSolid(type) || isActiveLedge) {\n      if (intersects) {\n        const collidingBy = rect.uncollideCircle(this.collider);\n\n        this.velocity.add(Vector.scale(collidingBy, 1 / deltaTime));\n        // Horizontal rebound\n        if (collidingBy.x > 0 && collidingBy.y === 0) {\n          this.velocity.x = Math.max(0, this.velocity.x);\n        } else if (collidingBy.x < 0 && collidingBy.y === 0) {\n          this.velocity.x = Math.min(0, this.velocity.x);\n        }\n        // Vertical rebound\n        if (collidingBy.y > 0 && collidingBy.x === 0) {\n          this.velocity.y = Math.max(0, this.velocity.y);\n        } else if (collidingBy.y < 0 && collidingBy.x === 0) {\n          this.velocity.y = Math.min(0, this.velocity.y);\n        }\n        this.position.add(collidingBy);\n      }\n      return this.collider.intersectsRectangle(rect);\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   * @param {Level} level The level that the player is in.\n   */\n  update(deltaTime: number, inputState: InputState, level: Level) {\n    const getCellAt = (x: number, y: number): BlockEnum | undefined => {\n      return level.levelGrid[Math.floor(y)]?.[Math.floor(x)];\n    };\n    const getRectAt = (x: number, y: number) => {\n      const type = getCellAt(x, y);\n      if (type) {\n        return {\n          type: getCellAt(x, y),\n          rect: RectPool.get(\n            Math.floor(y),\n            Math.floor(x),\n            type === BlockEnum.LEDGE\n          ),\n        };\n      }\n    };\n\n    // Process horizontal input\n    const inputX = inputState.getHorizontalAxis();\n    const inputY = inputState.getVerticalAxis();\n    const acceleration = new Vector(inputX * PLAYER_ACCEL, 0);\n\n    if (inputState.isPressed(Input.Down) && this.state !== PlayerState.CLIMB) {\n      this.isDropping = true;\n    }\n\n    // Check grounded\n    const playerBottom = this.position.y + this.collider.radius;\n    const cellBelow = getCellAt(this.position.x, playerBottom);\n    const groundingCellBelow = this.isDropping\n      ? BlockType.isSolid(cellBelow)\n      : BlockType.isGrounding(cellBelow);\n\n    const gridCellWithin = getCellAt(this.position.x, this.position.y);\n    const groundedOnGridCell =\n      groundingCellBelow && playerBottom === Math.floor(playerBottom);\n\n    const isGrounded =\n      groundedOnGridCell ||\n      level.objects.some(\n        ({ type, rect }) =>\n          (this.isDropping\n            ? BlockType.isSolid(type)\n            : BlockType.isGrounding(type)) && this.collider.isKissingBelow(rect)\n      );\n\n    const hasLeftLadder =\n      this.state === PlayerState.CLIMB && gridCellWithin !== BlockEnum.LADDER;\n\n    // Calculate immediate overrides\n    if (gridCellWithin === BlockEnum.LADDER && inputY !== 0) {\n      this.state = PlayerState.CLIMB;\n    } else if (isGrounded) {\n      this.state = PlayerState.GROUND;\n    } else if (!gridCellWithin || hasLeftLadder) {\n      // If just leaving ladder and holding up\n      if (hasLeftLadder && inputY < 0) {\n        this.wantsToJump = true;\n      }\n      this.state = PlayerState.AIR;\n    }\n\n    const updateSpeed = (input: number, vCurr: number, decel: number) => {\n      if (sign(input)) {\n        // Turn speed\n        if (sign(input) !== sign(vCurr)) {\n          return -TURN_SPEED * sign(vCurr);\n        }\n      } else {\n        return -Math.min(Math.abs(vCurr / deltaTime), decel) * sign(vCurr);\n      }\n\n      return 0;\n    };\n\n    // General motion\n    if (this.state === PlayerState.GROUND) {\n      this.inAirFor = 0;\n\n      acceleration.x += updateSpeed(inputX, this.velocity.x, PLAYER_DECEL);\n\n      this.velocity.y = 0;\n    } else if (this.state === PlayerState.CLIMB) {\n      this.inAirFor = 0;\n      acceleration.y = inputState.getVerticalAxis() * PLAYER_ACCEL;\n\n      acceleration.x += updateSpeed(inputX, this.velocity.x, PLAYER_DECEL);\n      acceleration.y += updateSpeed(inputY, this.velocity.y, PLAYER_DECEL);\n    } else {\n      // Gravity\n      this.inAirFor += deltaTime;\n      if (gridCellWithin === BlockEnum.VENT) {\n        const ventMultiplier = this.velocity.y > 0 ? 0 : 1.1;\n        acceleration.y -= GRAVITY * ventMultiplier;\n      } else {\n        acceleration.y += GRAVITY;\n      }\n    }\n\n    // Coyote jump\n    if (this.inAirFor < COYOTE_TIME && this.wantsToJump) {\n      this.wantsToJump = false;\n      this.velocity.y = -JUMP_INITIAL_SPEED;\n      this.state = PlayerState.AIR;\n    }\n\n    this.velocity.add(Vector.scale(acceleration, deltaTime));\n    if (this.state === PlayerState.CLIMB) {\n      this.velocity.x = clamp(\n        this.velocity.x,\n        -CLIMB_MAX_SPEED,\n        CLIMB_MAX_SPEED\n      );\n      this.velocity.y = clamp(\n        this.velocity.y,\n        -CLIMB_MAX_SPEED,\n        CLIMB_MAX_SPEED\n      );\n    } else {\n      this.velocity.x = clamp(\n        this.velocity.x,\n        -PLAYER_MAX_SPEED,\n        PLAYER_MAX_SPEED\n      );\n    }\n\n    const step = Vector.scale(this.velocity, deltaTime);\n\n    step.x = clamp(step.x, -PLAYER_RADIUS, PLAYER_RADIUS);\n    step.y = clamp(step.y, -PLAYER_RADIUS, PLAYER_RADIUS);\n\n    this.position.add(step);\n\n    const { x, y } = this.position;\n\n    // Re-ordered to prioritise collisions with closer blocks first\n    const nearbyBlocks = [\n      getRectAt(x, y),\n      getRectAt(x, y + 1),\n      getRectAt(x, y - 1),\n      getRectAt(x - 1, y),\n      getRectAt(x + 1, y),\n      getRectAt(x - 1, y - 1),\n      getRectAt(x + 1, y - 1),\n      getRectAt(x - 1, y + 1),\n      getRectAt(x + 1, y + 1),\n    ].filter(isDefined);\n\n    this.contactingAnyLedge = false;\n\n    nearbyBlocks.concat(level.objects).forEach(({ type, rect }) => {\n      this.collideWithBlock(type!, rect, deltaTime);\n    });\n\n    this.isDropping = this.isDropping && this.contactingAnyLedge;\n  }\n\n  /**\n   * Draw the player on the canvas\n   * @param {Canvas} canvas The canvas to draw on\n   */\n  draw(canvas: Canvas) {\n    canvas.setColor(\"#EF9606\");\n\n    this.collider.draw(canvas);\n  }\n}\n", "import { Vector } from \"../math/Vector\";\nimport { BlockEnum } from \"./BlockTypes\";\nimport { Entity } from \"./entity/Entity\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { Interactible } from \"./interactibles/Interactible\";\n\nimport { Level, Object } from \"./Level\";\nimport { Player } from \"./Player\";\n\nexport class LevelFactory {\n  key: string;\n  iid: string;\n  width: number;\n  height: number;\n  levelGrid: BlockEnum[][];\n  objects: Object[];\n  playerPosition: Vector;\n  exitTriggers: ExitTrigger[];\n  interactibles: Interactible[];\n  entities: Entity[];\n  worldPosition: Vector;\n\n  constructor(key: string, iid: string, width: number, height: number) {\n    this.key = key;\n    this.iid = iid;\n    this.width = width;\n    this.height = height;\n    this.levelGrid = [];\n    this.objects = [];\n    this.playerPosition = new Vector(16, 9);\n    this.exitTriggers = [];\n    this.interactibles = [];\n    this.entities = [];\n\n    this.worldPosition = new Vector(0, 0);\n  }\n\n  addObjects(objects: Object[]) {\n    this.objects = this.objects.concat(objects);\n    return this;\n  }\n\n  addExits(exits: ExitTrigger[]) {\n    this.exitTriggers = this.exitTriggers.concat(exits);\n    return this;\n  }\n\n  addInteractibles(is: Interactible[]) {\n    this.interactibles = this.interactibles.concat(is);\n    return this;\n  }\n\n  addEntities(es: Entity[]) {\n    this.entities = this.entities.concat(es);\n    return this;\n  }\n\n  setPlayerPos(pos: Vector) {\n    this.playerPosition = pos;\n    return this;\n  }\n\n  setLevelGrid(grid: BlockEnum[][]) {\n    this.levelGrid = grid;\n  }\n\n  makeGridSpace() {\n    this.levelGrid = [];\n\n    for (let row = 0; row < this.height; row++) {\n      this.levelGrid.push([]);\n    }\n  }\n\n  setWorldPosition(vec: Vector) {\n    this.worldPosition = vec;\n  }\n\n  setCell(row: number, col: number, blockType: BlockEnum) {\n    this.levelGrid[row][col] = blockType;\n  }\n\n  create() {\n    return new Level(\n      this.key,\n      this.width,\n      this.height,\n      this.levelGrid,\n      this.objects,\n      new Player(this.playerPosition),\n      this.exitTriggers,\n      this.interactibles,\n      this.entities,\n      this.worldPosition\n    );\n  }\n}\n", "import { PIXELS_PER_TILE } from \"../constants/ScreenConstants\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { DoorInteractible } from \"./interactibles/DoorInteractible\";\nimport { PuzzleInteractible } from \"./interactibles/PuzzleInteractible\";\nimport { SwitchInteractible } from \"./interactibles/SwitchInteractible\";\nimport { TrapdoorInteractible } from \"./interactibles/TrapdoorInteractible\";\nimport { CoverEntity } from \"./entity/CoverEntity\";\n\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { LevelFactory } from \"./LevelFactory\";\nimport { Level } from \"./Level\";\nimport { PuzzleRules } from \"../puzzle-manager/PuzzleFactory\";\n\nconst LEVEL_DATA_URL = \"./data/world.json\";\nconst PUZZLE_DATA_URL = \"./data/puzzles.json\";\n\ninterface EntityRef {\n  entityIid: string;\n}\n\ninterface FieldData {\n  __identifier: string;\n  __value: string | boolean | string[] | EntityRef | EntityRef[];\n}\n\ninterface EntityData {\n  __identifier: string;\n  iid: string;\n  fieldInstances: FieldData[];\n  __grid: [number, number];\n  px: [number, number];\n  width: number;\n  height: number;\n}\n\ninterface GridCell {\n  px: [number, number];\n  src: [number, number];\n}\n\ninterface LayerData {\n  __identifier: string;\n  gridTiles: GridCell[];\n  entityInstances: EntityData[];\n}\n\ninterface LevelData {\n  identifier: string;\n  iid: string;\n  pxWid: number;\n  pxHei: number;\n  worldX: number;\n  worldY: number;\n\n  __neighbours: { levelIid: string }[];\n\n  layerInstances: LayerData[];\n}\n\ninterface WorldData {\n  levels: LevelData[];\n}\n\nfunction loadJson<T>(file: string): Promise<T> {\n  return fetch(file).then((data) => data.json());\n}\n\nfunction find<T extends { __identifier: string }>(list: T[], iden: string) {\n  return list.find((item) => item.__identifier === iden);\n}\n\nfunction findByIid<T extends { iid: string }>(list: T[], iid?: string) {\n  return list.find((item) => item.iid === iid);\n}\n\nfunction findLayer(level: LevelData, key: string) {\n  return find(level.layerInstances, key);\n}\n\nfunction pxToTile(num: number) {\n  return Math.floor(num / PIXELS_PER_TILE);\n}\n\nfunction srcToBlockType(src: [number, number]) {\n  return pxToTile(src[0]) + 1;\n}\n\nfunction getField<T>(entity: EntityData, fieldKey: string): T | undefined {\n  return find(entity.fieldInstances, fieldKey)?.__value as T | undefined;\n}\n\nfunction getPrereqs(entity: EntityData) {\n  const raw = getField<EntityRef[]>(entity, \"prerequisites\") || [];\n  return raw.map((ref) => ref.entityIid);\n}\n\nfunction getInteractibleTrigger(entity: EntityData, entities: EntityData[]) {\n  const triggerId = getField<EntityRef>(entity, \"triggerArea\")?.entityIid;\n  const triggerArea = triggerId ? findByIid(entities, triggerId) : undefined;\n\n  return triggerArea\n    ? rectOfEntity(triggerArea)\n    : Rectangle.aroundPoint(\n        new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2),\n        2,\n        2\n      );\n}\n\nfunction entityToPos(entity: EntityData) {\n  return Vector.scale(new Vector(...entity.px), 1 / PIXELS_PER_TILE);\n}\n\nfunction createPuzzle(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  const key = getField<string>(entity, \"key\");\n  if (!key) {\n    console.warn(\"Puzzle with no key!\");\n  }\n  const center = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  const config = {\n    isFlipped: getField<boolean>(entity, \"isFlipped\"),\n  };\n\n  return new PuzzleInteractible(\n    id,\n    center,\n    getInteractibleTrigger(entity, entities),\n    getPrereqs(entity),\n    key!,\n    config\n  );\n}\n\nfunction createSwitch(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Switch with no key!\");\n  }\n  const center = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  return new SwitchInteractible(\n    id,\n    center,\n    getInteractibleTrigger(entity, entities),\n    getPrereqs(entity)\n  );\n}\n\nfunction createDoor(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Door with no key!\");\n  }\n  const door = Vector.add(entityToPos(entity), new Vector(2, 2));\n  return new DoorInteractible(\n    id,\n    door,\n    getPrereqs(entity),\n    pxToTile(entity.height)\n  );\n}\n\nfunction createTrapdoor(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Trapdoor with no key!\");\n  }\n  const pos = entityToPos(entity);\n  const config = {\n    isFlipped: getField<boolean>(entity, \"isFlipped\"),\n    hasLedge: getField<boolean>(entity, \"hasLedge\"),\n    isSingle: getField<boolean>(entity, \"isSingle\"),\n  };\n  return new TrapdoorInteractible(\n    id,\n    pos,\n    getPrereqs(entity),\n    pxToTile(entity.width),\n    config\n  );\n}\n\nconst rectOfEntity = (entity: EntityData) => {\n  return Rectangle.widthForm(\n    ...entity.__grid,\n    pxToTile(entity.width),\n    pxToTile(entity.height)\n  );\n};\n\nfunction isDefined<T>(value: T | undefined): value is T {\n  return !!value;\n}\n\nfunction createCoverEntity(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"CoverEntity with no key!\");\n  }\n  const triggerId = getField<EntityRef>(entity, \"triggerArea\")?.entityIid;\n  const trigger = findByIid(entities, triggerId) || entity;\n\n  const extraField = getField<EntityRef[]>(entity, \"extraCover\") || [];\n  const extraCovers = extraField\n    .map((ref) => findByIid(entities, ref.entityIid))\n    .filter(isDefined)\n    .map(rectOfEntity);\n\n  const config = {\n    coverIsTrigger: getField<boolean>(entity, \"coverIsTrigger\"),\n    canReCover: getField<boolean>(entity, \"canReCover\"),\n  };\n\n  return new CoverEntity(\n    id,\n    rectOfEntity(entity),\n    extraCovers,\n    rectOfEntity(trigger),\n    config\n  );\n}\n\nfunction firstPass(level: LevelData): LevelFactory {\n  const factory = new LevelFactory(\n    level.identifier,\n    level.iid,\n    pxToTile(level.pxWid),\n    pxToTile(level.pxHei)\n  );\n  factory.makeGridSpace();\n  const solidLayer = findLayer(level, \"Solid\")!;\n  for (const cell of solidLayer.gridTiles) {\n    const col = pxToTile(cell.px[0]);\n    const row = pxToTile(cell.px[1]);\n    const blockType = srcToBlockType(cell.src);\n\n    factory.setCell(row, col, blockType);\n  }\n\n  let setStartPos = false;\n  const entityLayer = findLayer(level, \"EntityLayer\")!;\n\n  const entities = entityLayer.entityInstances;\n  entities.forEach((entity) => {\n    switch (entity.__identifier) {\n      case \"Util\":\n        break;\n      case \"PlayerStart\":\n        factory.setPlayerPos(new Vector(entity.__grid[0], entity.__grid[1]));\n        setStartPos = true;\n        break;\n      case \"PuzzleScreen\":\n        factory.addInteractibles([createPuzzle(entity, entities)]);\n        break;\n      case \"Switch\":\n        factory.addInteractibles([createSwitch(entity, entities)]);\n        break;\n      case \"Door\":\n        factory.addInteractibles([createDoor(entity)]);\n        break;\n      case \"Trapdoor\":\n        factory.addInteractibles([createTrapdoor(entity)]);\n        break;\n      case \"CoverEntity\":\n        factory.addEntities([createCoverEntity(entity, entities)]);\n        break;\n      default:\n        console.warn(\"Processing unknown entity type:\", entity.__identifier);\n    }\n  });\n\n  if (!setStartPos) {\n    console.warn(`Level ${level.identifier} is missing a PlayerStart`);\n  }\n\n  factory.setWorldPosition(\n    new Vector(pxToTile(level.worldX), pxToTile(level.worldY))\n  );\n\n  return factory;\n}\n\nfunction secondPass(level: LevelData, others: Record<string, LevelFactory>) {\n  const factory = others[level.iid];\n  for (const neighbourInfo of level.__neighbours) {\n    const nId = neighbourInfo.levelIid;\n    const neighbour = others[nId];\n    const topLeft = Vector.diff(neighbour.worldPosition, factory.worldPosition);\n    const nextCollider = Rectangle.widthForm(\n      topLeft.x,\n      topLeft.y,\n      neighbour.width,\n      neighbour.height\n    );\n    factory.addExits([\n      new ExitTrigger(nextCollider, neighbour.key, nextCollider),\n    ]);\n  }\n\n  return factory.create();\n}\n\ninterface RawPuzzles {\n  puzzlesByLevel: {\n    [levelName: string]: {\n      [groupName: string]: Record<string, PuzzleRules>;\n    };\n  };\n}\n\nexport class DataLoader {\n  static hasLoaded = false;\n  static data: WorldData | null = null;\n  static levelMap: Record<string, Level> = {};\n  static puzzles: Record<string, PuzzleRules> = {};\n\n  static fetchPuzzles() {\n    return loadJson<RawPuzzles>(PUZZLE_DATA_URL).then((rawPuzzles) => {\n      const { puzzlesByLevel } = rawPuzzles;\n      const allPuzzles: Record<string, PuzzleRules> = {};\n\n      for (const level of Object.values(puzzlesByLevel)) {\n        for (const group of Object.values(level))\n          Object.assign(allPuzzles, group);\n      }\n\n      DataLoader.puzzles = allPuzzles;\n    });\n  }\n\n  static fetchWorld() {\n    return loadJson<WorldData>(LEVEL_DATA_URL)\n      .then((data) => {\n        DataLoader.data = data;\n\n        const basicMap: Record<string, LevelFactory> = {};\n\n        data.levels.forEach((level) => {\n          const basicData = firstPass(level);\n          basicMap[basicData.iid] = basicData;\n          basicMap[basicData.key] = basicData;\n        });\n\n        data.levels.forEach((rawLevel) => {\n          const level = secondPass(rawLevel, basicMap);\n          DataLoader.levelMap[level.key] = level;\n        });\n      })\n      .then(() => undefined);\n  }\n\n  static start() {\n    return Promise.all([DataLoader.fetchPuzzles(), DataLoader.fetchWorld()]);\n  }\n\n  static getLevel(key: string) {\n    return DataLoader.levelMap[key];\n  }\n}\n", "import {\n  ClickEvent,\n  InputEvent,\n  InputState,\n  ScrollEvent,\n} from \"../InputManager\";\nimport { DataLoader } from \"../level/DataLoader\";\nimport { Player } from \"../level/Player\";\nimport { clamp } from \"../math/Common\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { PlayMode } from \"./PlayMode\";\n\nexport class MapMode {\n  playMode: PlayMode;\n  cameraPosition: Vector;\n  zoom: number;\n\n  mousePosition: Vector;\n  isClicked: boolean;\n\n  canvasW: number;\n  canvasH: number;\n\n  constructor(playMode: PlayMode) {\n    this.playMode = playMode;\n    this.cameraPosition = new Vector(0, 0);\n    this.setCameraPos();\n    this.zoom = 2;\n\n    this.mousePosition = new Vector(0, 0);\n    this.isClicked = false;\n\n    this.canvasW = 0;\n    this.canvasH = 0;\n  }\n\n  setCameraPos() {\n    this.cameraPosition = Vector.add(\n      this.playMode.currentLevel.worldPosition,\n      this.playMode.currentLevel.player.position\n    );\n  }\n\n  onStart() {\n    this.setCameraPos();\n    this.mousePosition = new Vector(0, 0);\n    this.isClicked = false;\n  }\n\n  toWorldPosition(position: Vector) {\n    return Vector.add(\n      Vector.scale(\n        Vector.diff(position, new Vector(this.canvasW / 2, this.canvasH / 2)),\n        1 / this.zoom\n      ),\n      this.cameraPosition\n    );\n  }\n\n  update(_deltaTime: number, inputState: InputState) {\n    // Do this on start\n    if (inputState.isLeftClicking() && this.isClicked) {\n      const currentWorldPos = this.toWorldPosition(inputState.mousePosition);\n      this.cameraPosition.subtract(\n        Vector.diff(currentWorldPos, this.mousePosition)\n      );\n      // this.mousePosition = currentWorldPos;\n    } else {\n      this.isClicked = false;\n    }\n  }\n\n  onInput(inputEvent: InputEvent) {\n    // Do nothing\n    if (inputEvent.isClick()) {\n      const event = inputEvent as ClickEvent;\n      if (!event.isRightClick()) {\n        this.mousePosition = this.toWorldPosition(event.position);\n        this.isClicked = true;\n      }\n    } else if (inputEvent.isScroll()) {\n      const scroll = inputEvent as ScrollEvent;\n      this.zoom = clamp(this.zoom + scroll.delta * -0.01, 0.5, 20);\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    const currentLevel = this.playMode.currentLevel;\n\n    const canvas = screenManager.uiCanvas;\n    this.canvasW = canvas.width;\n    this.canvasH = canvas.height;\n\n    canvas.setColor(\"#223366\");\n    canvas.fillRect(0, 0, canvas.width, canvas.height);\n\n    canvas.saveTransform();\n    canvas.translate(canvas.width / 2, canvas.height / 2);\n\n    canvas.scale(this.zoom, this.zoom);\n\n    canvas.translate(-this.cameraPosition.x, -this.cameraPosition.y);\n\n    let currentPlayer: Player | undefined;\n\n    for (const level of Object.values(DataLoader.levelMap)) {\n      if (!level.visited) {\n        continue;\n      }\n\n      canvas.setColor(\"white\");\n      canvas.fillRect(\n        level.worldPosition.x,\n        level.worldPosition.y,\n        level.width,\n        level.height\n      );\n      canvas.translate(level.worldPosition.x, level.worldPosition.y);\n\n      level.drawForMap(canvas);\n\n      if (currentLevel === level) {\n        currentPlayer = level.player;\n      }\n\n      canvas.translate(-level.worldPosition.x, -level.worldPosition.y);\n    }\n\n    if (currentPlayer) {\n      const offset = Vector.add(currentLevel.worldPosition, currentPlayer.position);\n      canvas.translate(offset.x, offset.y);\n\n      canvas.setLineWidth(2);\n      canvas.setLineDash([]);\n\n      canvas.scale(1 / this.zoom, 1 / this.zoom);\n\n      canvas.setColor(\"#EF9606\");\n      canvas.fillEllipse(0, 0, 15, 15);\n      canvas.setColor(\"black\");\n      canvas.strokeEllipse(0, 0, 15, 15);\n\n      canvas.scale(this.zoom, this.zoom);\n\n      canvas.translate(-offset.x, -offset.y);\n    }\n\n    canvas.restoreTransform();\n  }\n}\n", "import { DataLoader } from \"./DataLoader\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { Level } from \"./Level\";\n\n/**\n * Responsible for finding and loading levels, not managing what level is\n * currently active.\n */\nexport class LevelManager {\n  levelMap: Record<string, Level>;\n  currentLevel: Level;\n\n  constructor() {\n    let initialLevel = \"Initial_Level\";\n\n    if (location.href.includes(\"localhost\")) {\n      (window as any).setStartLevel = (levelName: string) => {\n        localStorage.setItem(\"start_level\", levelName);\n      };\n\n      const curr = localStorage.getItem(\"start_level\");\n      if (curr) {\n        initialLevel = curr;\n      }\n    }\n\n    this.levelMap = {};\n    this.currentLevel = DataLoader.getLevel(initialLevel);\n    this.levelMap[initialLevel] = this.currentLevel;\n  }\n\n  getInitialLevel() {\n    return this.currentLevel;\n  }\n\n  getLevel(key: string, previousExit: ExitTrigger) {\n    const nextLevel = this.levelMap[key] || DataLoader.getLevel(key);\n    nextLevel.feedPlayerInfo(this.currentLevel.player, previousExit);\n\n    this.currentLevel = nextLevel;\n    this.levelMap[key] = nextLevel;\n    return nextLevel;\n  }\n}\n", "import { LevelManager } from \"../level/LevelManager\";\nimport { PuzzleManager } from \"../puzzle-manager/PuzzleManager\";\nimport { Puzzle } from \"../puzzle-manager/Puzzle\";\nimport { Level } from \"../level/Level\";\nimport { ExitEvent, LevelEvent, OpenPuzzleEvent } from \"../level/LevelEvent\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nexport class PlayMode {\n  levelManager: LevelManager;\n  puzzleManager: typeof PuzzleManager;\n\n  currentPuzzle: Puzzle | undefined;\n  currentLevel: Level;\n\n  constructor() {\n    this.levelManager = new LevelManager();\n\n    this.currentLevel = this.levelManager.getInitialLevel();\n    this.startLevel(this.currentLevel);\n\n    this.puzzleManager = PuzzleManager;\n\n    this.currentPuzzle = undefined;\n  }\n\n  startLevel(level: Level) {\n    this.currentLevel = level;\n    level.start(this);\n  }\n\n  onStart() {\n    this.currentLevel.onAwaken();\n  }\n\n  onLevelEvent(event: LevelEvent) {\n    if (event.isExitEvent()) {\n      const exitTrigger = (event as ExitEvent).exitTrigger;\n      this.startLevel(this.levelManager.getLevel(exitTrigger.key, exitTrigger));\n    } else if (event.isOpenPuzzleEvent()) {\n      this.currentPuzzle = this.puzzleManager.getPuzzle(\n        (event as OpenPuzzleEvent).puzzleId\n      );\n      this.currentPuzzle.open();\n    } else if (event.isClosePuzzleEvent()) {\n      this.currentPuzzle?.close();\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {object} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentLevel?.update(deltaTime, inputState);\n    this.currentPuzzle?.update(deltaTime, inputState);\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.currentLevel?.onInput(input);\n    this.currentPuzzle?.onInput(input);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager) {\n    this.currentLevel?.draw(screenManager);\n    this.currentPuzzle?.draw(screenManager);\n  }\n}\n", "import { Input } from \"./constants/Keys\";\nimport { MapMode } from \"./game-modes/MapMode\";\nimport { PlayMode } from \"./game-modes/PlayMode\";\nimport { InputEvent, InputState } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\ninterface Mode {\n  update(deltaTime: number, inputState: InputState): void;\n  onInput(inputEvent: InputEvent): void;\n  draw(screenManager: ScreenManager): void;\n  onStart(): void;\n}\n\nexport class GameModeManager {\n  playMode: PlayMode;\n  mapMode: MapMode;\n\n  currentMode: Mode;\n\n  constructor() {\n    this.playMode = new PlayMode();\n    this.mapMode = new MapMode(this.playMode);\n\n    // Probably needs to initially be a menu mode eventually, or some dev-mode tooling\n    this.currentMode = this.playMode;\n  }\n\n  /**\n   * Update the current gamemode.\n   * @param {number} deltaTime The time that has elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentMode.update(deltaTime, inputState);\n  }\n\n  switchToMode(mode: Mode) {\n    this.currentMode = mode;\n    mode.onStart();\n  }\n\n  /**\n   * Process an input event\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    let consumed = false;\n    if (this.currentMode === this.playMode) {\n      if (input.isForKey(Input.Map)) {\n        consumed = true;\n        this.switchToMode(this.mapMode);\n      }\n    } else if (this.currentMode === this.mapMode) {\n      if (input.isForKey(Input.Escape) || input.isForKey(Input.Map)) {\n        consumed = false;\n        this.switchToMode(this.playMode);\n      }\n    }\n\n    if (!consumed) {\n      this.currentMode.onInput(input);\n    }\n  }\n\n  /**\n   * Draw the current gamemode.\n   * @param {ScreenManager} screenManager The screenManager object.\n   */\n  draw(screenManager: ScreenManager) {\n    this.currentMode.draw(screenManager);\n  }\n}\n", "import { sign } from \"./math/Common\";\nimport { hslaColor, rgbaColor } from \"./utils/Color\";\n\nconst CTX = Symbol(\"ctx\");\nconst CANVAS = Symbol(\"canvas\");\n\nexport class Canvas {\n  [CANVAS]: HTMLCanvasElement;\n  [CTX]: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this[CANVAS] = canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      throw Error(\"Unable to get 2d context\");\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    this[CTX] = ctx;\n\n    this[CTX].fillStyle = \"black\";\n    this[CTX].strokeStyle = \"black\";\n\n    this.width = this[CANVAS].width;\n    this.height = this[CANVAS].height;\n  }\n\n  /**\n   * Fill a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  fillRect(x: number, y: number, width: number, height: number) {\n    this[CTX].fillRect(x, y, width, height);\n  }\n\n  clear() {\n    this[CTX].clearRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Draw the outline of a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  strokeRect(x: number, y: number, width: number, height: number) {\n    this[CTX].strokeRect(x, y, width, height);\n  }\n\n  strokeRectInset(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    inset: number\n  ) {\n    this.strokeRect(\n      x + inset,\n      y + inset,\n      width - inset * 2,\n      height - inset * 2\n    );\n  }\n\n  /**\n   * Fill an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  fillEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].fill();\n  }\n\n  fillTriangle(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y + height);\n    this[CTX].lineTo(x + width, y + height);\n    this[CTX].lineTo(x + width / 2, y);\n    this[CTX].fill();\n  }\n\n  /**\n   * Outline an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  strokeEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].stroke();\n  }\n\n  outerCircleCorner(x: number, y: number, radius: number, startAngle: number) {\n    this[CTX].beginPath();\n    this[CTX].arc(x, y, radius, startAngle, startAngle + Math.PI / 2);\n    const toPoint = startAngle + Math.PI / 4;\n    this[CTX].lineTo(\n      x + sign(Math.cos(toPoint)) * radius,\n      y + sign(Math.sin(toPoint)) * radius\n    );\n    this[CTX].fill();\n  }\n\n  /**\n   * Draw a line on the canvas.\n   * @param {number} x0 The start x position\n   * @param {number} y0 The start y position\n   * @param {number} x1 The end x position\n   * @param {number} y1 The start y position\n   */\n  drawLine(x0: number, y0: number, x1: number, y1: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].lineTo(x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Draw a quadratic bezier curve on the canvas.\n   * @param {*} x0 The starting x position\n   * @param {*} y0 The starting y position\n   * @param {*} x1 The ending x position\n   * @param {*} y1 The ending y position\n   * @param {*} xControl The control point x position\n   * @param {*} yControl The control point y position\n   */\n  drawQuadratic(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    xControl: number,\n    yControl: number\n  ) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].quadraticCurveTo(xControl, yControl, x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Scale the canvas.\n   * @param {number} xScale\n   * @param {number} yScale\n   */\n  scale(xScale: number, yScale: number) {\n    this[CTX].scale(xScale, yScale);\n  }\n\n  /**\n   * Translate the canvas.\n   * @param {number} xOffset\n   * @param {number} yOffset\n   */\n  translate(xOffset: number, yOffset: number) {\n    this[CTX].translate(xOffset, yOffset);\n  }\n\n  setLineWidth(width: number) {\n    this[CTX].lineWidth = width;\n  }\n\n  get lineWidth() {\n    return this[CTX].lineWidth;\n  }\n\n  setLineDash(pattern: number[]) {\n    this[CTX].setLineDash(pattern);\n  }\n\n  /**\n   * Set the colour to be used for drawing on the canvas.\n   * @param {string} colorString The name of the color to be used\n   */\n  setColor(colorString: CanvasRenderingContext2D[\"fillStyle\"]) {\n    if (colorString === this[CTX].fillStyle) {\n      return;\n    }\n\n    this[CTX].fillStyle = colorString;\n    this[CTX].strokeStyle = colorString;\n  }\n\n  /**\n   * Set the current color via RGB.\n   * @param {number} red Red value from 0-255\n   * @param {number} green Green value from 0-255\n   * @param {number} blue Blue value from 0-255\n   * @param {number | undefined} alpha Alpha value from 0-255\n   */\n  setColorRGB(red: number, green: number, blue: number, alpha = 255) {\n    this.setColor(rgbaColor(red, green, blue, alpha));\n  }\n\n  /**\n   * Set the current color with hue, saturation, lightness and alpha.\n   * @param {number} hue Hue value from 0-359\n   * @param {number} saturation Saturation value from 0-1\n   * @param {number} lightness Lightness value from 0-1\n   * @param {number | undefined} alpha Alpha value from 0-1\n   */\n  setColorHSLA(hue: number, saturation: number, lightness: number, alpha = 1) {\n    this.setColor(hslaColor(hue, saturation, lightness, alpha));\n  }\n\n  createGradient(x0: number, y0: number, x1: number, y1: number) {\n    return this[CTX].createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(\n    x0: number,\n    y0: number,\n    r0: number,\n    x1: number,\n    y1: number,\n    r1: number\n  ) {\n    return this[CTX].createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  saveTransform() {\n    this[CTX].save();\n  }\n\n  restoreTransform() {\n    this[CTX].restore();\n  }\n\n  /**\n   * Draw another image to this canvas\n   * @param {Canvas} imageSource\n   * @param {number} sourceX\n   * @param {number} sourceY\n   * @param {number} sourceWidth\n   * @param {number} sourceHeight\n   * @param {number} destinationX\n   * @param {number} destinationY\n   * @param {number} destinationWidth\n   * @param {nubmer} destinationHeight\n   */\n  drawImage(\n    imageSource: Canvas | HTMLImageElement,\n    sourceX: number,\n    sourceY: number,\n    sourceWidth: number,\n    sourceHeight: number,\n    destinationX: number,\n    destinationY: number,\n    destinationWidth: number,\n    destinationHeight: number\n  ) {\n    let image: CanvasImageSource;\n    if (imageSource instanceof Canvas) {\n      image = imageSource[CANVAS];\n    } else if (imageSource instanceof Image) {\n      if (!imageSource.complete) {\n        return;\n      }\n      image = imageSource;\n    } else {\n      throw Error(\"Drawing something unmanageable\");\n    }\n\n    this[CTX].drawImage(\n      image,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destinationX,\n      destinationY,\n      destinationWidth,\n      destinationHeight\n    );\n  }\n\n  /**\n   * Create a Canvas from an id.\n   * @param {string} id The id attribute of the HTMLCanvasElement\n   */\n  static fromId(id: string) {\n    const canvas = document.getElementById(id);\n\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Could not find canvas with id: \"${id}\"`);\n    }\n\n    return new Canvas(canvas);\n  }\n\n  /**\n   * Create a new HTMLCanvasElement and use that as the basis for a Canvas.\n   */\n  static fromScratch(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n\n    return new Canvas(canvas);\n  }\n}\n", "import {\n  CANVAS_HEIGHT,\n  CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_HEIGHT,\n  ON_SCREEN_CANVAS_WIDTH,\n  UI_CANVAS_HEIGHT,\n  UI_CANVAS_WIDTH,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nimport { Canvas } from \"./Canvas\";\n\nconst REAL_CANVAS = Symbol(\"real-canvas\");\n\nfunction getRawCanvas(): HTMLCanvasElement {\n  const rawCanvas = document.getElementById(\"canvas\");\n\n  if (!(rawCanvas instanceof HTMLCanvasElement)) {\n    throw new Error(\"Could not find canvas\");\n  }\n\n  rawCanvas.width = ON_SCREEN_CANVAS_WIDTH;\n  rawCanvas.height = ON_SCREEN_CANVAS_HEIGHT;\n\n  return rawCanvas;\n}\n\nexport class ScreenManager {\n  [REAL_CANVAS]: Canvas;\n  background: Canvas;\n  parallaxCameras: Vector[];\n  parallax: Canvas[];\n  behindGroundCanvas: Canvas;\n  staticWorldCanvas: Canvas;\n  dynamicWorldCanvas: Canvas;\n  uiCanvas: Canvas;\n  camera: Vector;\n\n  constructor() {\n    const screenCanvas = new Canvas(getRawCanvas());\n\n    if (!(screenCanvas instanceof Canvas)) {\n      throw Error(\"No canvas found!\");\n    }\n\n    this[REAL_CANVAS] = screenCanvas;\n\n    this.background = Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3);\n    this.parallax = [\n      Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3),\n      Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3),\n      Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3),\n      Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3),\n      Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3),\n    ];\n    this.parallaxCameras = this.parallax.map(() => new Vector(0, 0));\n\n    this.behindGroundCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 3\n    );\n    this.staticWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 3\n    );\n    this.dynamicWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 3\n    );\n    this.uiCanvas = Canvas.fromScratch(\n      ON_SCREEN_CANVAS_WIDTH,\n      ON_SCREEN_CANVAS_HEIGHT\n    );\n\n    // Stores the top-left position of the camera\n    this.camera = new Vector(0, 0);\n  }\n\n  setParallaxCameras(cameras: Vector[]) {\n    this.parallaxCameras = cameras;\n  }\n\n  setCamera(cameraPosition: Vector) {\n    this.camera = cameraPosition;\n  }\n\n  drawCanvas(\n    canvas: Canvas,\n    camera: Vector,\n    width = CANVAS_WIDTH,\n    height = CANVAS_HEIGHT\n  ) {\n    this[REAL_CANVAS].drawImage(\n      canvas,\n      camera.x,\n      camera.y,\n      width,\n      height,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n  }\n\n  drawToScreen() {\n    this.drawCanvas(this.background, this.camera);\n    this.parallax.forEach((canvas, index) => {\n      this.drawCanvas(canvas, this.parallaxCameras[index]);\n    });\n    this.drawCanvas(this.behindGroundCanvas, this.camera);\n    this.drawCanvas(this.staticWorldCanvas, this.camera);\n    this.drawCanvas(this.dynamicWorldCanvas, this.camera);\n    this.drawCanvas(\n      this.uiCanvas,\n      new Vector(0, 0),\n      UI_CANVAS_WIDTH,\n      UI_CANVAS_HEIGHT\n    );\n  }\n\n  static instance = null;\n  static getInstance() {\n    if (this.instance) {\n      return this.instance;\n    }\n\n    return new ScreenManager();\n  }\n}\n", "import { IS_MOBILE } from \"./constants/ScreenConstants\";\nimport { DataLoader } from \"./level/DataLoader\";\n\nimport { GameModeManager } from \"./GameModeManager\";\nimport { InputEvent, InputManager } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\nconst MAX_FRAME_TIME = 1 / 20;\n\n/**\n * The head owner of everything.\n */\nclass App {\n  screenManager: ScreenManager;\n  gameModeManager: GameModeManager;\n  inputManager: InputManager;\n\n  lastFrameTime: number;\n\n  constructor() {\n    this.screenManager = ScreenManager.getInstance();\n    this.gameModeManager = new GameModeManager();\n    this.inputManager = new InputManager((input) => this.onInput(input));\n\n    this.lastFrameTime = performance.now();\n  }\n\n  start() {\n    this.inputManager.init();\n    this.lastFrameTime = performance.now();\n    requestAnimationFrame(() => this.mainLoop());\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.gameModeManager.onInput(input);\n  }\n\n  mainLoop() {\n    const now = performance.now();\n    const deltaTime = Math.min(\n      (now - this.lastFrameTime) / 1000,\n      MAX_FRAME_TIME\n    );\n    // Do stuff\n    this.gameModeManager.update(deltaTime, this.inputManager.getInputState());\n    this.gameModeManager.draw(this.screenManager);\n    this.screenManager.drawToScreen();\n\n    // Loop\n    requestAnimationFrame(() => this.mainLoop());\n    this.lastFrameTime = now;\n  }\n}\n\nfunction findById(id: string) {\n  const element = document.getElementById(id);\n\n  if (!element) {\n    console.warn(`Can't find element with id: ${id}`);\n  }\n\n  return element;\n}\n\n/**\n * The function used to kick off the whole app.\n */\nconst main = () => {\n  const loading = DataLoader.start();\n\n  loading.then(() => {\n    const app = new App();\n\n    app.start();\n\n    (window as any).app = app;\n  });\n\n  if (!IS_MOBILE && !location.href.includes(\"localhost\")) {\n    Array.from(document.getElementsByTagName(\"p\")).forEach((tag) =>\n      tag.classList.add(\"visible\")\n    );\n  }\n  if (!IS_MOBILE) {\n    findById(\"mobile-controls\")?.remove();\n  }\n  if (IS_MOBILE) {\n    findById(\"canvas\")?.classList.add(\"fit-screen\");\n    findById(\"mobile-controls\")?.classList.remove(\"hidden\");\n  }\n};\n\nwindow.onload = () => {\n  main();\n};\n"],
  "mappings": "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",
  "names": ["IS_MOBILE", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "UI_CANVAS_WIDTH", "UI_CANVAS_HEIGHT", "UI_PIXEL_WIDTH", "clamp", "x", "low", "high", "sign", "Vector", "x", "y", "vector", "factor", "a", "b", "xDiff", "yDiff", "v1", "v2", "t", "Circle", "position", "radius", "otherCircle", "radiusSum", "Vector", "point", "rectangle", "closestX", "clamp", "closestY", "canvas", "Rectangle", "x1", "y1", "x2", "y2", "x", "y", "otherRectangle", "circle", "p0", "pToCenter", "distFromCenter", "circleDistToMyCenter", "horizontalDistance", "verticalDistance", "sign", "outset", "inset", "insetBy", "width", "height", "halfWidth", "halfHeight", "rectangles", "rect", "TileImage", "EntityImage", "BlockType", "blockType", "Entity", "id", "_level", "_player", "_deltaTime", "_screenManager", "_canvas", "AREA_DEBUG", "Interactible", "Entity", "id", "position", "triggerArea", "prerequisites", "level", "player", "_deltaTime", "_level", "_a", "i", "screenManager", "canvas", "prereq", "xDiff", "Vector", "mid", "control", "OPEN_CLOSE_DURATION", "DoorInteractible", "Interactible", "id", "position", "prerequisites", "height", "Vector", "Rectangle", "level", "player", "deltaTime", "motion", "clamp", "screenManager", "canvas", "h", "EntityImage", "OPEN_DURATION", "CLOSE_DURATION", "PUZZLE_WINDOW_WIDTH", "UI_CANVAS_HEIGHT", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "N_CIRCLE_LAYOUT", "Circle", "Vector", "N_SQUARE_LAYOUT", "Rectangle", "CACHE", "cacheKey", "rows", "cols", "leftCol", "produceObject", "LEFT_COL", "CELL_SIZE_FROM_COLS", "PUZZLE_WINDOW_WIDTH", "CELL_SIZE_FROM_ROWS", "CELL_SIZE", "BOTTOM_SIZE", "LEFT_SIZE", "WIDE_SIZE", "FULL_HEIGHT", "FULL_WIDTH", "TOP_EDGE", "LEFT_EDGE", "lastX", "xSpacing", "i", "lastY", "ySpacing", "matrix", "y1", "y2", "thisRow", "x1", "x2", "Rectangle", "getObject", "key", "positionGetter", "row", "col", "PARTIAL_RADIUS", "SPACE_DEBUG_DRAW", "Puzzle", "id", "rows", "columns", "validator", "config", "incId", "positionGetter", "item", "row", "currentRow", "col", "cell", "group", "groupId", "column", "cells", "Rectangle", "UI_PIXEL_WIDTH", "pos", "slideInOffset", "Vector", "UI_CANVAS_HEIGHT", "puzzleScreenOffset", "UI_CANVAS_WIDTH", "PUZZLE_WINDOW_WIDTH", "screenManager", "canvas", "offset", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "i", "j", "element", "cellState", "mid", "radius", "value", "left", "right", "elementState", "position", "foundElement", "deltaTime", "inputState", "OPEN_DURATION", "CLOSE_DURATION", "clamp", "input", "click", "clickPosition", "PuzzleValidator", "validationItems", "grid", "values", "item", "index", "total", "positionGetter", "leftColumn", "Rectangle", "width", "top", "i", "canvas", "args", "globals", "ValidationItem", "_grid", "_values", "_canvas", "_args", "CellValidation", "ValidationItem", "row", "column", "ForcedCellValidation", "mustBeOn", "grid", "values", "cell", "canvas", "positionGetter", "rect", "width", "center", "Vector", "CountInAreaValidation", "desiredCount", "col", "count", "seenIds", "SOLVED_BACKGROUND", "circle", "N_CIRCLE_LAYOUT", "position", "rotRight", "vector", "Vector", "EdgeValidationItem", "ValidationItem", "isRow", "index", "grid", "valueMap", "cells", "row", "values", "valuesSoFar", "lastId", "cell", "_row", "_canvas", "_center", "_scaleBy", "_isSideways", "canvas", "positionGetter", "EdgeCountValidationItem", "count", "soFar", "item", "center", "scaleBy", "isSideways", "transformCircle", "circle", "Circle", "v", "N_CIRCLE_LAYOUT", "position", "EdgeGroupsValidationItem", "numGroups", "inGroup", "width", "moveCenter", "pos", "square", "N_SQUARE_LAYOUT", "EdgeBlankGroupsValidationItem", "EdgeNoTripleValidationItem", "value", "center2", "center3", "radius", "GlobalValidationItem", "ValidationItem", "canvas", "rectangle", "GlobalCountValidationItem", "count", "_grid", "values", "val", "number", "center", "w", "squareSize", "radius", "l", "t", "row", "col", "cell", "halfWidth", "halfHeight", "midpoint", "Rectangle", "PuzzleValidatorFactory", "row", "column", "mustBeOn", "ForcedCellValidation", "count", "CountInAreaValidation", "nums", "isRow", "ValidationItemType", "EdgeCountValidationItem", "num", "index", "EdgeGroupsValidationItem", "EdgeBlankGroupsValidationItem", "yeses", "bool", "EdgeNoTripleValidationItem", "GlobalCountValidationItem", "PuzzleValidator", "initPuzzle", "id", "options", "rows", "cols", "config", "rules", "PuzzleValidatorFactory", "cell", "Puzzle", "makePuzzle", "id", "rules", "DataLoader", "initPuzzle", "PuzzleManagerInstance", "puzzle", "PuzzleManager", "LevelEvent", "ExitEvent", "exitTrigger", "OpenPuzzleEvent", "puzzleId", "ClosePuzzleEvent", "SCREEN_W", "DRAW_CIRCLES", "PuzzleInteractible", "Interactible", "id", "position", "area", "prereqs", "puzzleId", "config", "PuzzleManager", "Vector", "screenManager", "canvas", "PIXEL_SCALE", "isFlippedMul", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "offset", "grid", "SCREEN_PIXEL", "SCR_WIDTH", "SCR_HEIGHT", "TOP_PAD", "LEFT_PAD", "row", "col", "shape", "x0", "y0", "w", "h", "OpenPuzzleEvent", "SwitchInteractible", "Interactible", "id", "position", "area", "prerequisites", "player", "deltaTime", "level", "screenManager", "canvas", "PIXEL_SCALE", "EntityImage", "OPEN_CLOSE_DUR", "TrapdoorInteractible", "Interactible", "id", "position", "prerequisites", "width", "config", "Vector", "isDouble", "Rectangle", "level", "player", "deltaTime", "motion", "clamp", "screenManager", "canvas", "x", "TileImage", "w", "EntityImage", "ZERO", "toHex", "number", "digits", "rgbaColor", "red", "green", "blue", "alpha", "hslaColor", "hue", "saturation", "lightness", "UNCOVER_DURATION", "CoverEntity", "Entity", "id", "coverArea", "extraCovers", "triggerArea", "config", "player", "cover", "level", "deltaTime", "isOpen", "clamp", "screenManager", "canvas", "size", "fadeRange", "pos", "Vector", "rOut", "gradient", "rgbaColor", "rect", "ExitTrigger", "collider", "key", "nextLevelCollider", "player", "Vector", "Up", "Down", "Left", "Right", "Jump", "Interact", "Escape", "Map", "Input", "KEY_MAP", "Input", "InputState", "keyMap", "mousePosition", "leftClicking", "rightClicking", "input", "Vector", "InputEvent", "_key", "KeyPressEvent", "key", "ClickEvent", "position", "isRightClick", "ScrollEvent", "delta", "InputManager", "listener", "onKeyEvent", "symbol", "e", "event", "_a", "_b", "wireButton", "id", "btn", "UI_CANVAS_WIDTH", "ON_SCREEN_CANVAS_WIDTH", "BackgroundArtist", "width", "height", "index", "screenManager", "xStep", "yStep", "col", "x", "row", "y", "Rectangle", "hue", "backColor", "foreColor", "action", "factor", "scale", "minSize", "Vector", "fullSize", "size", "canvas", "color", "hslaColor", "backgroundColor", "foregroundColor", "_row", "_col", "rect", "beamWidth", "yOffset", "_row2", "_col2", "rect2", "radius", "xs", "ys", "i", "back", "front", "_", "SCALE_FACTOR", "Level", "key", "width", "height", "levelGrid", "objects", "player", "exitTriggers", "interactibles", "entities", "worldPosition", "BackgroundArtist", "playModeManager", "i", "e", "object", "rect", "event", "previousPlayer", "previousExit", "position", "deltaTime", "inputState", "_a", "InputState", "interactible", "entity", "ClosePuzzleEvent", "input", "Input", "relevant", "OpenPuzzleEvent", "triggeredExit", "trigger", "ExitEvent", "camera", "clampedToPlayer", "Vector", "clamp", "canvas", "action", "row", "col", "blockType", "screenManager", "TileImage", "RectPoolClass", "row", "col", "isShort", "grid", "Rectangle", "RectPool", "PLAYER_RADIUS", "PLAYER_MAX_SPEED", "PLAYER_ACCEL", "PLAYER_DECEL", "TURN_SPEED", "JUMP_HEIGHT", "JUMP_DURATION", "PARAM_A", "JUMP_INITIAL_SPEED", "GRAVITY", "COYOTE_TIME", "CLIMB_MAX_SPEED", "isDefined", "value", "Player", "position", "Circle", "PLAYER_RADIUS", "Vector", "input", "Input", "type", "rect", "deltaTime", "isActiveLedge", "intersects", "BlockType", "collidingBy", "inputState", "level", "getCellAt", "x", "y", "_a", "getRectAt", "RectPool", "inputX", "inputY", "acceleration", "PLAYER_ACCEL", "playerBottom", "cellBelow", "groundingCellBelow", "gridCellWithin", "isGrounded", "hasLeftLadder", "updateSpeed", "vCurr", "decel", "sign", "TURN_SPEED", "PLAYER_DECEL", "ventMultiplier", "GRAVITY", "COYOTE_TIME", "JUMP_INITIAL_SPEED", "clamp", "CLIMB_MAX_SPEED", "PLAYER_MAX_SPEED", "step", "nearbyBlocks", "isDefined", "canvas", "LevelFactory", "key", "iid", "width", "height", "Vector", "objects", "exits", "is", "es", "pos", "grid", "row", "vec", "col", "blockType", "Level", "Player", "LEVEL_DATA_URL", "PUZZLE_DATA_URL", "loadJson", "file", "data", "find", "list", "iden", "item", "findByIid", "iid", "findLayer", "level", "key", "pxToTile", "num", "srcToBlockType", "src", "getField", "entity", "fieldKey", "_a", "getPrereqs", "ref", "getInteractibleTrigger", "entities", "triggerId", "triggerArea", "rectOfEntity", "Rectangle", "Vector", "entityToPos", "createPuzzle", "id", "center", "config", "PuzzleInteractible", "createSwitch", "SwitchInteractible", "createDoor", "door", "DoorInteractible", "createTrapdoor", "pos", "TrapdoorInteractible", "isDefined", "value", "createCoverEntity", "trigger", "extraCovers", "CoverEntity", "firstPass", "factory", "LevelFactory", "solidLayer", "cell", "col", "row", "blockType", "setStartPos", "secondPass", "others", "neighbourInfo", "nId", "neighbour", "topLeft", "nextCollider", "ExitTrigger", "_DataLoader", "rawPuzzles", "puzzlesByLevel", "allPuzzles", "group", "basicMap", "basicData", "rawLevel", "DataLoader", "MapMode", "playMode", "Vector", "position", "_deltaTime", "inputState", "currentWorldPos", "inputEvent", "event", "scroll", "clamp", "screenManager", "currentLevel", "canvas", "currentPlayer", "level", "DataLoader", "offset", "LevelManager", "initialLevel", "levelName", "curr", "DataLoader", "key", "previousExit", "nextLevel", "PlayMode", "LevelManager", "PuzzleManager", "level", "event", "_a", "exitTrigger", "deltaTime", "inputState", "_b", "input", "screenManager", "GameModeManager", "PlayMode", "MapMode", "deltaTime", "inputState", "mode", "input", "consumed", "Input", "screenManager", "CTX", "CANVAS", "_Canvas", "canvas", "ctx", "x", "y", "width", "height", "inset", "radius", "startAngle", "toPoint", "sign", "x0", "y0", "x1", "y1", "xControl", "yControl", "xScale", "yScale", "xOffset", "yOffset", "pattern", "colorString", "red", "green", "blue", "alpha", "rgbaColor", "hue", "saturation", "lightness", "hslaColor", "r0", "r1", "imageSource", "sourceX", "sourceY", "sourceWidth", "sourceHeight", "destinationX", "destinationY", "destinationWidth", "destinationHeight", "image", "id", "Canvas", "REAL_CANVAS", "getRawCanvas", "rawCanvas", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "_ScreenManager", "screenCanvas", "Canvas", "Vector", "cameras", "cameraPosition", "canvas", "camera", "width", "height", "index", "UI_CANVAS_WIDTH", "UI_CANVAS_HEIGHT", "ScreenManager", "MAX_FRAME_TIME", "App", "ScreenManager", "GameModeManager", "InputManager", "input", "now", "deltaTime", "findById", "id", "element", "main", "_a", "_b", "_c", "DataLoader", "app", "IS_MOBILE", "tag"]
}
