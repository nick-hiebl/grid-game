{
  "version": 3,
  "sources": ["../js/constants/ScreenConstants.ts", "../js/math/Common.ts", "../js/math/Vector.ts", "../js/math/Shapes.ts", "../js/constants/Image.ts", "../js/level/BlockTypes.ts", "../js/level/entity/Entity.ts", "../js/level/interactibles/Interactible.ts", "../js/level/interactibles/DoorInteractible.ts", "../js/puzzle-manager/constants.ts", "../js/puzzle-manager/PuzzleSpaceManager.ts", "../js/puzzle-manager/Puzzle.ts", "../js/puzzle-manager/PuzzleValidation.ts", "../js/puzzle-manager/CellValidation.ts", "../js/puzzle-manager/EdgeValidation.ts", "../js/puzzle-manager/PuzzleValidatorFactory.ts", "../js/puzzle-manager/PuzzleFactory.ts", "../js/puzzle-manager/PuzzleManager.ts", "../js/level/LevelEvent.ts", "../js/level/interactibles/PuzzleInteractible.ts", "../js/level/interactibles/SwitchInteractible.ts", "../js/level/interactibles/TrapdoorInteractible.ts", "../js/level/entity/CoverEntity.ts", "../js/level/ExitTrigger.ts", "../js/constants/Keys.ts", "../js/InputManager.ts", "../js/level/Level.ts", "../js/level/RectPool.ts", "../js/level/Player.ts", "../js/level/LevelFactory.ts", "../js/level/DataLoader.ts", "../js/level/LevelManager.ts", "../js/game-modes/PlayMode.ts", "../js/GameModeManager.ts", "../js/utils/Color.ts", "../js/Canvas.ts", "../js/ScreenManager.ts", "../js/App.ts"],
  "sourcesContent": ["export const CANVAS_WIDTH = 1280;\nexport const CANVAS_HEIGHT = 720;\n\nexport const HORIZONTAL_TILES = 32;\nexport const VERTICAL_TILES = 18;\n\nexport const PIXELS_PER_TILE = 10;\n\nexport const PIXEL_WIDTH = CANVAS_WIDTH / HORIZONTAL_TILES / PIXELS_PER_TILE;\n\nexport const IS_MOBILE =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  );\n\nexport const ON_SCREEN_CANVAS_WIDTH = 1280;\nexport const ON_SCREEN_CANVAS_HEIGHT = 720;\n\nexport const UI_CANVAS_WIDTH = ON_SCREEN_CANVAS_WIDTH;\nexport const UI_CANVAS_HEIGHT = ON_SCREEN_CANVAS_HEIGHT;\n\nexport const UI_PIXEL_WIDTH = 3;\n", "/**\n * Clamps a parameter between a low and high bound.\n * @param {number} x The number to be clamped\n * @param {number} low The lowest value that could be returned\n * @param {number} high The highest value that could be returned\n */\nexport const clamp = (x: number, low: number, high: number): number => {\n  return Math.min(high, Math.max(x, low));\n};\n\nexport const sign = (x: number): number => {\n  if (x > 0) {\n    return 1;\n  } else if (x === 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n};\n", "export class Vector {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n\n    return this;\n  }\n\n  multiply(factor: number) {\n    this.x *= factor;\n    this.y *= factor;\n\n    return this;\n  }\n\n  copy() {\n    return new Vector(this.x, this.y);\n  }\n\n  get magnitude(): number {\n    return Math.hypot(this.x, this.y);\n  }\n\n  static add(a: Vector, b: Vector) {\n    return new Vector(a.x + b.x, a.y + b.y);\n  }\n\n  static diff(a: Vector, b: Vector) {\n    return new Vector(a.x - b.x, a.y - b.y);\n  }\n\n  static scale(vector: Vector, factor: number) {\n    return new Vector(vector.x * factor, vector.y * factor);\n  }\n\n  static sqrDist(a: Vector, b: Vector): number {\n    const xDiff = a.x - b.x;\n    const yDiff = a.y - b.y;\n    return xDiff * xDiff + yDiff * yDiff;\n  }\n\n  /**\n   * This is not actually manhattan distance. Consider refactoring.\n   */\n  static manhattanDist(a: Vector, b: Vector) {\n    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n  }\n\n  static dist(a: Vector, b: Vector) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  static lerp(v1: Vector, v2: Vector, t: number) {\n    return new Vector(v1.x * (1 - t) + v2.x * t, v1.y * (1 - t) + v2.y * t);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { clamp, sign } from \"./Common\";\nimport { Vector } from \"./Vector\";\n\nexport class Circle {\n  position: Vector;\n  radius: number;\n\n  constructor(position: Vector, radius: number) {\n    this.position = position;\n    this.radius = radius;\n  }\n\n  /**\n   * Check if another circle intersects with this circle\n   * @param {Circle} otherCircle The circle to check intersection with\n   */\n  intersectsCircle(otherCircle: Circle) {\n    const radiusSum = this.radius + otherCircle.radius;\n    return (\n      Vector.sqrDist(this.position, otherCircle.position) <\n      radiusSum * radiusSum\n    );\n  }\n\n  /**\n   * Check if a point intersects with this circle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsVector(point: Vector) {\n    return Vector.sqrDist(this.position, point) < this.radius * this.radius;\n  }\n\n  /**\n   * Check if a rectangle intersects with this circle.\n   * @param {Rectangle} rectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(rectangle: Rectangle) {\n    // Find the co-ordinates of the closest point in the rectangle to the circle center.\n    const closestX = clamp(this.position.x, rectangle.x1, rectangle.x2);\n    const closestY = clamp(this.position.y, rectangle.y1, rectangle.y2);\n\n    // Find if the closest point in the rectangle overlaps with the circle.\n    return this.intersectsVector(new Vector(closestX, closestY));\n  }\n\n  /**\n   * Determine if this circle is exactly kissing a rectangle below.\n   * @param {Rectangle} rectangle The rectangle to check for a kiss with\n   */\n  isKissingBelow(rectangle: Rectangle) {\n    return (\n      this.position.y + this.radius === rectangle.y1 &&\n      rectangle.x1 <= this.position.x &&\n      this.position.x <= rectangle.x2\n    );\n  }\n\n  /**\n   * Draw this circle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas) {\n    canvas.fillEllipse(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      this.radius\n    );\n  }\n}\n\nexport class Rectangle {\n  x1: number\n  y1: number;\n  x2: number;\n  y2: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /**\n   * Check if a point intersects with this rectangle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsPoint(point: Vector) {\n    return (\n      this.x1 <= point.x &&\n      point.x <= this.x2 &&\n      this.y1 <= point.y &&\n      point.y <= this.y2\n    );\n  }\n\n  get width() {\n    return this.x2 - this.x1;\n  }\n\n  get height() {\n    return this.y2 - this.y1;\n  }\n\n  get midpoint() {\n    return new Vector((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n  }\n\n  /**\n   * Check if another rectangle intersects with this rectangle.\n   * @param {Rectangle} otherRectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(otherRectangle: Rectangle) {\n    return (\n      otherRectangle.x1 <= this.x2 &&\n      this.x1 <= otherRectangle.x2 &&\n      otherRectangle.y1 <= this.y2 &&\n      this.y1 <= otherRectangle.y2\n    );\n  }\n\n  /**\n   * Compute the smallest vector in the reverse direction to movement to\n   * uncollide with a given rectangle.\n   * @param {Circle} circle\n   */\n  uncollideCircle(circle: Circle) {\n    const closestX = clamp(circle.position.x, this.x1, this.x2);\n    const closestY = clamp(circle.position.y, this.y1, this.y2);\n\n    const p0 = new Vector(closestX, closestY);\n    const pToCenter = Vector.diff(circle.position, p0);\n\n    const distFromCenter = pToCenter.magnitude || 1;\n\n    if (distFromCenter >= circle.radius) {\n      const circleDistToMyCenter = Vector.diff(circle.position, this.midpoint);\n      const horizontalDistance =\n        this.width / 2 - Math.abs(circleDistToMyCenter.x);\n      const verticalDistance =\n        this.height / 2 - Math.abs(circleDistToMyCenter.y);\n\n      // Shortest way out is horizontally\n      if (horizontalDistance < verticalDistance) {\n        return new Vector(\n          (horizontalDistance + circle.radius) * sign(circleDistToMyCenter.x),\n          0\n        );\n      } else {\n        return new Vector(\n          0,\n          (verticalDistance + circle.radius) * sign(circleDistToMyCenter.y)\n        );\n      }\n    }\n\n    return Vector.scale(\n      pToCenter,\n      (circle.radius - distFromCenter) / distFromCenter\n    );\n  }\n\n  /**\n   * Draw this rectangle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas) {\n    canvas.fillRect(this.x1, this.y1, this.width, this.height);\n  }\n\n  stroke(canvas: Canvas, inset = 0) {\n    canvas.strokeRectInset(this.x1, this.y1, this.width, this.height, inset);\n  }\n\n  inset(insetBy: number) {\n    return new Rectangle(\n      this.x1 + insetBy,\n      this.y1 + insetBy,\n      this.x2 - insetBy,\n      this.y2 - insetBy\n    );\n  }\n\n  static widthForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x, y, x + width, y + height);\n  }\n\n  static centerForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x - width, y - height, x + width, y + height);\n  }\n\n  static aroundPoint(point: Vector, halfWidth: number, halfHeight: number) {\n    return new Rectangle(\n      point.x - halfWidth,\n      point.y - halfHeight,\n      point.x + halfWidth,\n      point.y + halfHeight\n    );\n  }\n}\n", "export const TileImage = new Image();\nTileImage.src = \"./img/tileset.png\";\n\nexport const EntityImage = new Image();\nEntityImage.src = \"./img/entity-set.png\";\n", "export enum BlockEnum {\n  SOLID = 1,\n  LEDGE = 2,\n  VENT = 3,\n  LADDER = 4,\n}\n\nexport const BlockType = {\n  isSolid: (blockType: BlockEnum) => {\n    return blockType === BlockEnum.SOLID;\n  },\n  isGrounding: (blockType: BlockEnum) => {\n    return blockType === BlockEnum.LEDGE || BlockType.isSolid(blockType);\n  },\n};\n", "import { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nexport class Entity {\n  id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  onStart(_level: Level) {\n    // Do nothing\n  }\n\n  update(_player: Player, _deltaTime: number, _level: Level) {\n    // Do nothing\n  }\n\n  draw(_screenManager: ScreenManager) {\n    // Do nothing\n  }\n}\n", "import { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Entity } from \"../entity/Entity\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\nimport { LevelEvent } from \"../LevelEvent\";\n\nconst AREA_DEBUG = false;\n\nexport class Interactible extends Entity {\n  position: Vector;\n  triggerArea: Rectangle | undefined;\n\n  prerequisites: string[];\n  prereqsActive: boolean;\n  prereqEntities: Interactible[];\n\n  isEnabled: boolean;\n  isAreaActive: boolean;\n  \n  connectionPoint: Vector;\n  outputPoint: Vector;\n\n  constructor(id: string, position: Vector, triggerArea: Rectangle | undefined, prerequisites: string[] = []) {\n    super(id);\n\n    this.position = position;\n    this.triggerArea = triggerArea;\n\n    this.prerequisites = prerequisites;\n    this.prereqsActive = prerequisites.length === 0;\n    this.prereqEntities = [];\n\n    this.isEnabled = false;\n\n    this.isAreaActive = false;\n\n    this.connectionPoint = this.position;\n    this.outputPoint = this.position;\n  }\n\n  onStart(level: Level) {\n    this.findPrerequisites(level);\n  }\n\n  findPrerequisites(level: Level): Interactible[] {\n    if (this.prereqEntities.length === this.prerequisites.length) {\n      return this.prereqEntities;\n    }\n\n    this.prereqEntities = level.interactibles.filter((i) =>\n      this.prerequisites.includes(i.id)\n    );\n\n    return this.prereqEntities;\n  }\n\n  update(player: Player, _deltaTime: number, _level: Level) {\n    this.prereqsActive = this.prereqEntities.every((i) => i.isEnabled);\n    this.isAreaActive =\n      !!(this.prereqsActive && this.triggerArea?.intersectsPoint(player.position));\n  }\n\n  /**\n   * Draw the element on the canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(screenManager: ScreenManager) {\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (AREA_DEBUG) {\n      canvas.setColorRGB(255, 255, 255);\n      canvas.setLineWidth(0.1);\n      canvas.setLineDash([0.2, 0.2]);\n      this.triggerArea?.stroke(canvas);\n    }\n\n    screenManager.behindGroundCanvas.setLineWidth(0.2);\n    for (const prereq of this.prereqEntities) {\n      screenManager.behindGroundCanvas.setColor(\n        prereq.isEnabled ? \"white\" : \"black\"\n      );\n      const xDiff = Vector.manhattanDist(\n        prereq.outputPoint,\n        this.connectionPoint\n      );\n      const mid = Vector.lerp(prereq.outputPoint, this.connectionPoint, 0.5);\n      const control = Vector.add(mid, new Vector(0, xDiff * 0.3));\n      screenManager.behindGroundCanvas.drawQuadratic(\n        prereq.outputPoint.x,\n        prereq.outputPoint.y,\n        this.connectionPoint.x,\n        this.connectionPoint.y,\n        control.x,\n        control.y\n      );\n    }\n  }\n\n  onInteract(): LevelEvent | undefined | void {\n    // Maybe return an event\n  }\n}\n", "import { EntityImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { BlockEnum } from \"../BlockTypes\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nconst OPEN_CLOSE_SPEED = 0.2;\n\nexport class DoorInteractible extends Interactible {\n  headCollider: Rectangle;\n  doorCollider: Rectangle;\n\n  fullHeight: number;\n\n  constructor(id: string, position: Vector, prerequisites: string[], height = 4) {\n    super(id, position, undefined, prerequisites);\n\n    this.connectionPoint = Vector.add(position, new Vector(0, -1.8));\n\n    this.headCollider = Rectangle.centerForm(\n      this.position.x,\n      this.position.y - 1.8,\n      0.6,\n      0.4\n    );\n    this.doorCollider = Rectangle.widthForm(\n      this.position.x - 0.5,\n      this.position.y - 2,\n      1,\n      height\n    );\n\n    this.fullHeight = height;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n\n    level.addWithoutDuplicate({\n      type: BlockEnum.SOLID,\n      rect: this.headCollider,\n    });\n    level.addWithoutDuplicate({\n      type: BlockEnum.SOLID,\n      rect: this.doorCollider,\n    });\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const motion =\n      (deltaTime / OPEN_CLOSE_SPEED) * (this.prereqsActive ? -1 : 1);\n\n    this.doorCollider.y2 = clamp(\n      this.doorCollider.y2 + motion,\n      this.doorCollider.y1,\n      this.doorCollider.y1 + this.fullHeight\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const h = this.doorCollider.height;\n    if (h > 0) {\n      canvas.setColor(\"black\");\n      canvas.fillRect(this.position.x - 0.5, this.position.y - 2, 1, h);\n\n      canvas.drawImage(\n        EntityImage,\n        120,\n        Math.max(40 - 10 * h, 20) - 10,\n        40,\n        Math.min(10 * h, 20),\n        this.position.x - 2,\n        this.position.y - 2 + Math.max(h - 2, 0),\n        4,\n        Math.min(h, 2)\n      );\n    }\n\n    canvas.drawImage(\n      EntityImage,\n      this.prereqsActive ? 140 : 128,\n      0,\n      12,\n      6,\n      this.position.x - 6 / PIXELS_PER_TILE,\n      this.position.y - 2,\n      12 / PIXELS_PER_TILE,\n      6 / PIXELS_PER_TILE\n    );\n  }\n}\n", "import { UI_CANVAS_HEIGHT } from \"../constants/ScreenConstants\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nexport const OPEN_DURATION = 0.4;\nexport const CLOSE_DURATION = 0.25;\n\nexport const PUZZLE_WINDOW_WIDTH = (7 / 9) * UI_CANVAS_HEIGHT;\n\nexport const SOLVED_BACKGROUND = \"#00ff62c8\";\nexport const DEFAULT_BACKGROUND = \"#0096ffc8\";\n\nexport const N_CIRCLE_LAYOUT = [\n  [new Circle(new Vector(0, 0), 0.33)],\n  [new Circle(new Vector(0, 0), 0.33)],\n  [new Circle(new Vector(0, 0.4), 0.33), new Circle(new Vector(0, -0.4), 0.33)],\n  [\n    new Circle(new Vector(-0.42, 0.4), 0.33),\n    new Circle(new Vector(0.42, 0.4), 0.33),\n    new Circle(new Vector(0, -0.4), 0.33),\n  ],\n  [\n    new Circle(new Vector(0.4, 0.4), 0.33),\n    new Circle(new Vector(0.4, -0.4), 0.33),\n    new Circle(new Vector(-0.4, 0.4), 0.33),\n    new Circle(new Vector(-0.4, -0.4), 0.33),\n  ],\n  [\n    new Circle(new Vector(0, 0.3), 0.28),\n    new Circle(new Vector(0.64, 0.3), 0.28),\n    new Circle(new Vector(-0.64, 0.3), 0.28),\n    new Circle(new Vector(-0.32, -0.3), 0.28),\n    new Circle(new Vector(0.32, -0.3), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0.6), 0.28),\n    new Circle(new Vector(0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.32, 0), 0.28),\n    new Circle(new Vector(0.32, 0), 0.28),\n    new Circle(new Vector(0, -0.6), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0), 0.28),\n    new Circle(new Vector(0.64, 0), 0.28),\n    new Circle(new Vector(-0.64, 0), 0.28),\n    new Circle(new Vector(-0.32, -0.6), 0.28),\n    new Circle(new Vector(0.32, -0.6), 0.28),\n    new Circle(new Vector(-0.32, 0.6), 0.28),\n    new Circle(new Vector(0.32, 0.6), 0.28),\n  ],\n  [\n    new Circle(new Vector(0, 0.6), 0.28),\n    new Circle(new Vector(0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.64, 0.6), 0.28),\n    new Circle(new Vector(-0.32, 0), 0.28),\n    new Circle(new Vector(0.32, 0), 0.28),\n    new Circle(new Vector(0, -0.6), 0.28),\n    new Circle(new Vector(0.64, -0.6), 0.28),\n    new Circle(new Vector(-0.64, -0.6), 0.28),\n  ],\n];\n\nexport const N_SQUARE_LAYOUT = [\n  [Rectangle.centerForm(0, 0, 0.33, 0.33)],\n  [Rectangle.centerForm(0, 0, 0.33, 0.33)],\n  [\n    Rectangle.centerForm(0, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(0, 0.4, 0.33, 0.33),\n  ],\n  [\n    Rectangle.centerForm(0, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(-0.4, 0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, 0.4, 0.33, 0.33),\n  ],\n  [\n    Rectangle.centerForm(-0.4, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, -0.4, 0.33, 0.33),\n    Rectangle.centerForm(-0.4, 0.4, 0.33, 0.33),\n    Rectangle.centerForm(0.4, 0.4, 0.33, 0.33),\n  ],\n];\n", "import { Rectangle } from \"../math/Shapes\";\nimport { PUZZLE_WINDOW_WIDTH } from \"./constants\";\nimport { PositionGetter } from \"./types\";\n\nconst CACHE: Record<string, Rectangle[][]> = {};\n\nconst cacheKey = (rows: number, cols: number) => `${rows}-${cols}`;\n\nconst produceObject = (rows: number, cols: number): Rectangle[][] => {\n  const LARGER_DIR = Math.max(rows, cols);\n  const WIDE_EDGE = 0.7;\n  const NARROW_EDGE = 0.5;\n  const CELL_SIZE = Math.floor(\n    PUZZLE_WINDOW_WIDTH / (LARGER_DIR + WIDE_EDGE + NARROW_EDGE)\n  );\n  const NARROW_SIZE = Math.floor(CELL_SIZE * NARROW_EDGE);\n  const WIDE_SIZE = PUZZLE_WINDOW_WIDTH - CELL_SIZE * LARGER_DIR - NARROW_SIZE;\n\n  const FULL_HEIGHT = WIDE_SIZE + NARROW_SIZE + rows * CELL_SIZE;\n  const FULL_WIDTH = WIDE_SIZE + NARROW_SIZE + cols * CELL_SIZE;\n\n  const TOP_EDGE = Math.max((FULL_WIDTH - FULL_HEIGHT) / 2, 0);\n  const LEFT_EDGE = Math.max((FULL_HEIGHT - FULL_WIDTH) / 2, 0);\n\n  const xSpacing = [[LEFT_EDGE, LEFT_EDGE + NARROW_SIZE]];\n  let lastX = LEFT_EDGE + NARROW_SIZE;\n\n  for (let i = 0; i < cols; i++) {\n    xSpacing.push([lastX, lastX + CELL_SIZE]);\n    lastX += CELL_SIZE;\n  }\n\n  xSpacing.push([lastX, lastX + WIDE_SIZE]);\n\n  const ySpacing = [[TOP_EDGE, TOP_EDGE + WIDE_SIZE]];\n  let lastY = TOP_EDGE + WIDE_SIZE;\n\n  for (let i = 0; i < rows; i++) {\n    ySpacing.push([lastY, lastY + CELL_SIZE]);\n    lastY += CELL_SIZE;\n  }\n\n  ySpacing.push([lastY, lastY + NARROW_SIZE]);\n\n  const matrix = [];\n\n  for (const [y1, y2] of ySpacing) {\n    const thisRow = [];\n    for (const [x1, x2] of xSpacing) {\n      thisRow.push(new Rectangle(x1, y1, x2, y2));\n    }\n\n    matrix.push(thisRow);\n  }\n\n  return matrix;\n};\n\nconst getObject = (rows: number, cols: number) => {\n  const key = cacheKey(rows, cols);\n  if (!(key in CACHE)) {\n    CACHE[key] = produceObject(rows, cols);\n  }\n\n  return CACHE[key];\n};\n\nexport const positionGetter = (rows: number, cols: number): PositionGetter => {\n  const matrix = getObject(rows, cols);\n\n  // Indexed from [-1 to ROWS][-1 to COLS]\n  return (row: number | \"end\", col: number | \"end\") => {\n    return matrix[row === \"end\" ? rows + 1 : row + 1][\n      col === \"end\" ? cols + 1 : col + 1\n    ];\n  };\n};\n", "import {\n  UI_PIXEL_WIDTH,\n  UI_CANVAS_HEIGHT,\n  UI_CANVAS_WIDTH,\n} from \"../constants/ScreenConstants\";\nimport { ClickEvent, InputEvent, InputState } from \"../InputManager\";\nimport { clamp } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nimport {\n  CLOSE_DURATION,\n  DEFAULT_BACKGROUND,\n  OPEN_DURATION,\n  PUZZLE_WINDOW_WIDTH,\n  SOLVED_BACKGROUND,\n} from \"./constants\";\nimport { positionGetter } from \"./PuzzleSpaceManager\";\nimport { PuzzleValidator } from \"./PuzzleValidation\";\nimport { PositionGetter, PuzzleState } from \"./types\";\n\nconst PARTIAL_RADIUS = 0.4;\n\nexport class Puzzle {\n  id: string;\n  openCloseStatus: number;\n  isOpen: boolean;\n  rows: number;\n  cols: number;\n\n  state: PuzzleState;\n  elements: { row: number; col: number; shape: Rectangle; isHovered: boolean }[];\n  positionGetter: PositionGetter;\n\n  validator: PuzzleValidator;\n  isSolved: boolean;\n  hasBeenSolvedEver: boolean;\n\n  constructor(id: string, rows: number, columns: number, validator: PuzzleValidator) {\n    this.id = id;\n    this.openCloseStatus = 0;\n    this.isOpen = false;\n    this.rows = rows;\n    this.cols = columns;\n\n    this.state = [];\n    this.elements = [];\n\n    this.validator = validator;\n    this.isSolved = false;\n    this.hasBeenSolvedEver = false;\n\n    this.positionGetter = positionGetter(rows, columns);\n    for (let row = 0; row < rows; row++) {\n      const currentRow = [];\n\n      for (let col = 0; col < columns; col++) {\n        currentRow.push(null);\n\n        this.elements.push({\n          row,\n          col,\n          shape: this.positionGetter(row, col).inset(UI_PIXEL_WIDTH),\n          isHovered: false,\n        });\n      }\n\n      this.state.push(currentRow);\n    }\n  }\n\n  open() {\n    if (this.isOpen) {\n      return;\n    }\n\n    this.isOpen = true;\n    this.openCloseStatus = 0;\n  }\n\n  close() {\n    this.isOpen = false;\n  }\n\n  uiPosition() {\n    // Function with f(0) = 1, f(1) = 0, f\"(1) = 0\n    // Feel free to replace this with any other function moving those\n    // parameters.\n    const pos = Math.pow(1 - this.openCloseStatus, 2);\n\n    const slideInOffset = new Vector(0, UI_CANVAS_HEIGHT * pos);\n    const puzzleScreenOffset = new Vector(\n      (UI_CANVAS_WIDTH - PUZZLE_WINDOW_WIDTH) / 2,\n      (UI_CANVAS_HEIGHT - PUZZLE_WINDOW_WIDTH) / 2\n    );\n    return Vector.add(slideInOffset, puzzleScreenOffset);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager) {\n    const canvas = screenManager.uiCanvas;\n\n    canvas.clear();\n\n    if (this.openCloseStatus === 0) {\n      return;\n    }\n\n    const offset = this.uiPosition();\n\n    canvas.translate(offset.x, offset.y);\n\n    // Draw screen background\n    canvas.setColor(this.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND);\n    canvas.fillRect(0, 0, PUZZLE_WINDOW_WIDTH, PUZZLE_WINDOW_WIDTH);\n\n    // Draw monitor leg\n    canvas.setColor(\"#222222\");\n    canvas.fillRect(\n      PUZZLE_WINDOW_WIDTH / 4,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH / 2,\n      PUZZLE_WINDOW_WIDTH\n    );\n\n    // Draw monitor outline\n    canvas.setLineWidth(UI_PIXEL_WIDTH * 8);\n    canvas.setLineDash([]);\n    canvas.strokeRectInset(\n      0,\n      0,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH,\n      -UI_PIXEL_WIDTH * 4\n    );\n\n    // Draw screen outline\n    canvas.setColor(\"#ffffff64\");\n    canvas.setLineWidth(UI_PIXEL_WIDTH);\n\n    canvas.strokeRectInset(\n      0,\n      0,\n      PUZZLE_WINDOW_WIDTH,\n      PUZZLE_WINDOW_WIDTH,\n      UI_PIXEL_WIDTH / 2\n    );\n\n    // Draw squares\n    for (const element of this.elements) {\n      if (element.isHovered) {\n        canvas.setColor(\"white\");\n      } else {\n        canvas.setColor(\"#ffffff64\");\n      }\n      canvas.setLineDash([]);\n      element.shape.stroke(canvas, UI_PIXEL_WIDTH / 2);\n\n      const cellState = this.state[element.row][element.col];\n      const mid = element.shape.midpoint;\n      if (cellState) {\n        canvas.setColor(\"white\");\n        canvas.fillEllipse(\n          mid.x,\n          mid.y,\n          element.shape.width * PARTIAL_RADIUS,\n          element.shape.width * PARTIAL_RADIUS\n        );\n      } else if (cellState === false) {\n        // Might be null, so need exact check\n        canvas.setColor(\"#ffffff64\");\n        canvas.setLineDash([UI_PIXEL_WIDTH * 2, UI_PIXEL_WIDTH * 2]);\n        canvas.strokeEllipse(\n          mid.x,\n          mid.y,\n          element.shape.width * PARTIAL_RADIUS,\n          element.shape.width * PARTIAL_RADIUS\n        );\n      }\n    }\n\n    this.validator.draw(canvas, this.positionGetter);\n\n    canvas.translate(-offset.x, -offset.y);\n  }\n\n  update(deltaTime: number, inputState: InputState) {\n    if (this.isOpen && this.openCloseStatus < 1) {\n      this.openCloseStatus += deltaTime / OPEN_DURATION;\n    } else if (!this.isOpen && this.openCloseStatus > 0) {\n      this.openCloseStatus -= deltaTime / CLOSE_DURATION;\n    }\n\n    this.openCloseStatus = clamp(this.openCloseStatus, 0, 1);\n\n    if (inputState) {\n      const position = Vector.diff(inputState.mousePosition, this.uiPosition());\n\n      for (const element of this.elements) {\n        element.isHovered = element.shape.intersectsPoint(position);\n      }\n    }\n  }\n\n  onStateChange() {\n    this.isSolved = this.validator.isValid(this.state);\n    if (this.isSolved) {\n      this.hasBeenSolvedEver = true;\n    }\n  }\n\n  onInput(input: InputEvent) {\n    let anyChange = false;\n    if (input.isClick()) {\n      const click = input as ClickEvent;\n      const clickPosition = Vector.diff(click.position, this.uiPosition());\n      for (const element of this.elements) {\n        element.isHovered = element.shape.intersectsPoint(clickPosition);\n\n        if (element.isHovered) {\n          const currentState = this.state[element.row][element.col];\n\n          anyChange = true;\n\n          let nextState = null;\n          if (click.isRightClick()) {\n            // Right click\n            // Exact checking bool as currentState is bool or null\n            if (currentState === false) {\n              nextState = null;\n            } else {\n              nextState = false;\n            }\n          } else {\n            // Left click\n            // Exact checking bool as currentState is bool or null\n            if (currentState === true) {\n              nextState = null;\n            } else {\n              nextState = true;\n            }\n          }\n          this.state[element.row][element.col] = nextState;\n        }\n      }\n    }\n\n    if (anyChange) {\n      this.onStateChange();\n    }\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { PuzzleState } from \"./types\";\n\nexport class PuzzleValidator {\n  validationItems: ValidationItem[];\n\n  constructor(validationItems: ValidationItem[]) {\n    this.validationItems = validationItems;\n  }\n\n  isValid(state: PuzzleState) {\n    this.validationItems.forEach((item) => {\n      item.validate(state);\n    });\n\n    return this.validationItems.every((item) => item.isValid);\n  }\n\n  draw(canvas: Canvas, ...args: unknown[]) {\n    this.validationItems.forEach((item) => {\n      item.draw(canvas, ...args);\n    });\n  }\n}\n\nexport class ValidationItem {\n  isValid: boolean;\n\n  constructor() {\n    this.isValid = false;\n  }\n\n  validate(_state: PuzzleState) {\n    // Do nothing...\n  }\n\n  draw(_canvas: Canvas, ..._args: unknown[]) {\n    // Do nothing...\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { N_CIRCLE_LAYOUT, SOLVED_BACKGROUND } from \"./constants\";\nimport { ValidationItem } from \"./PuzzleValidation\";\nimport { PositionGetter, PuzzleState } from \"./types\";\n\nexport class CellValidation extends ValidationItem {\n  row: number;\n  column: number;\n\n  constructor(row: number, column: number) {\n    super();\n    this.row = row;\n    this.column = column;\n  }\n}\n\nexport class ForcedCellValidation extends CellValidation {\n  mustBeOn: boolean;\n\n  constructor(row: number, column: number, mustBeOn: boolean) {\n    super(row, column);\n    this.mustBeOn = mustBeOn;\n\n    this.isValid = !mustBeOn;\n  }\n\n  validate(state: PuzzleState) {\n    const cell = state[this.row][this.column];\n\n    this.isValid = !!cell === !!this.mustBeOn;\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const rect = positionGetter(this.row, this.column);\n\n    const width = Math.min(rect.width, rect.height);\n\n    const center = new Vector(rect.x2 - width * 0.15, rect.y1 + width * 0.15);\n\n    if (this.mustBeOn) {\n      canvas.fillEllipse(center.x, center.y, width * 0.1, width * 0.1);\n    } else {\n      canvas.setLineWidth(width * 0.05);\n      canvas.strokeEllipse(center.x, center.y, width * 0.075, width * 0.075);\n    }\n  }\n}\n\nexport class CountInAreaValidation extends CellValidation {\n  desiredCount: number;\n  isCellColoured: boolean;\n\n  constructor(row: number, column: number, desiredCount: number) {\n    super(row, column);\n\n    this.desiredCount = desiredCount;\n    this.isValid = desiredCount === 0;\n    this.isCellColoured = false;\n  }\n\n  *iterateArea(state: PuzzleState) {\n    for (\n      let row = Math.max(this.row - 1, 0);\n      row <= Math.min(this.row + 1, state.length - 1);\n      row++\n    ) {\n      for (\n        let col = Math.max(this.column - 1, 0);\n        col <= Math.min(this.column + 1, state[row].length - 1);\n        col++\n      ) {\n        yield [row, col];\n      }\n    }\n  }\n\n  validate(state: PuzzleState) {\n    let count = 0;\n\n    for (let [row, col] of this.iterateArea(state)) {\n      if (!!state[row][col]) {\n        count++;\n      }\n    }\n\n    this.isValid = count === this.desiredCount;\n    this.isCellColoured = !!state[this.row][this.column];\n  }\n\n  draw(canvas: Canvas, positionGetter: (row: number, column: number) => Rectangle) {\n    if (this.isValid) {\n      canvas.setColor(this.isCellColoured ? SOLVED_BACKGROUND : \"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    const rect = positionGetter(this.row, this.column);\n\n    const width = Math.min(rect.width, rect.height) * 0.25;\n\n    const center = rect.midpoint;\n\n    for (const circle of N_CIRCLE_LAYOUT[this.desiredCount]) {\n      const position = Vector.add(center, Vector.scale(circle.position, width));\n\n      if (this.desiredCount === 0) {\n        canvas.setLineWidth(circle.radius * width * 0.5);\n        canvas.strokeEllipse(\n          position.x,\n          position.y,\n          circle.radius * width * 0.75,\n          circle.radius * width * 0.75\n        );\n      } else {\n        canvas.fillEllipse(\n          position.x,\n          position.y,\n          circle.radius * width,\n          circle.radius * width\n        );\n      }\n    }\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { N_CIRCLE_LAYOUT, N_SQUARE_LAYOUT } from \"./constants\";\nimport { ValidationItem } from \"./PuzzleValidation\";\nimport { CellValue, PositionGetter, PuzzleState } from \"./types\";\n\nconst rotRight = (vector: Vector) => new Vector(-vector.y, vector.x);\n\nclass EdgeValidationItem extends ValidationItem {\n  isRow: boolean;\n  index: number;\n\n  constructor(isRow: boolean, index: number) {\n    super();\n    this.isRow = isRow;\n    this.index = index;\n\n    this.isValid = false;\n  }\n\n  getRelevantRow(state: PuzzleState) {\n    if (this.isRow) {\n      return state[this.index];\n    } else {\n      return state.map((row) => row[this.index]);\n    }\n  }\n\n  validateRow(row: CellValue[]): boolean {\n    throw new TypeError(\"Cannot validate as a generic EdgeValidationItem\");\n  }\n\n  validate(state: PuzzleState) {\n    const row = this.getRelevantRow(state);\n\n    this.isValid = this.validateRow(row);\n  }\n\n  drawInCell(_canvas: Canvas, _center: Vector, _scaleBy: number, _isSideways: boolean) {\n    throw new TypeError(\"Cannot draw a generic EdgeValidationItem\");\n  }\n\n  draw(canvas: Canvas, positionGetter: PositionGetter) {\n    if (this.isValid) {\n      canvas.setColor(\"white\");\n    } else {\n      canvas.setColor(\"red\");\n    }\n\n    if (this.isRow) {\n      const cell = positionGetter(this.index, \"end\");\n\n      this.drawInCell(canvas, cell.midpoint, cell.width / 2, true);\n    } else {\n      const cell = positionGetter(-1, this.index);\n\n      this.drawInCell(canvas, cell.midpoint, cell.height / 2, false);\n    }\n  }\n}\n\nexport class EdgeCountValidationItem extends EdgeValidationItem {\n  count: number;\n\n  constructor(isRow: boolean, index: number, count: number) {\n    super(isRow, index);\n    this.count = count;\n\n    this.isValid = count === 0;\n  }\n\n  validateRow(row: CellValue[]) {\n    const count = row.reduce((soFar, item) => (item ? soFar + 1 : soFar), 0);\n\n    return count === this.count;\n  }\n\n  drawInCell(canvas: Canvas, center: Vector, scaleBy: number, isSideways: boolean) {\n    const transformCircle = isSideways\n      ? (circle: Circle) => new Circle(rotRight(circle.position), circle.radius)\n      : (v: Circle) => v;\n\n    for (let circle of N_CIRCLE_LAYOUT[this.count]) {\n      circle = transformCircle(circle);\n      const position = Vector.add(\n        center,\n        Vector.scale(circle.position, scaleBy)\n      );\n\n      if (this.count === 0) {\n        canvas.setLineWidth(circle.radius * scaleBy * 0.5);\n        canvas.strokeEllipse(\n          position.x,\n          position.y,\n          circle.radius * scaleBy * 0.75,\n          circle.radius * scaleBy * 0.75\n        );\n      } else {\n        canvas.fillEllipse(\n          position.x,\n          position.y,\n          circle.radius * scaleBy,\n          circle.radius * scaleBy\n        );\n      }\n    }\n  }\n}\n\nexport class EdgeGroupsValidationItem extends EdgeCountValidationItem {\n  validateRow(row: CellValue[]) {\n    const [numGroups] = row.reduce(\n      ([soFar, inGroup], item) =>\n        item && !inGroup\n          ? // Start of new group\n            [soFar + 1, true]\n          : // Continue, updating inGroup based on current item state\n            [soFar, !!item],\n      [0, false]\n    );\n\n    return numGroups === this.count;\n  }\n\n  drawSquare(canvas: Canvas, position: Vector, width: number) {\n    canvas.fillRect(\n      position.x - width / 2,\n      position.y - width / 2,\n      width,\n      width\n    );\n  }\n\n  drawInCell(canvas: Canvas, center: Vector, scaleBy: number, isSideways: boolean) {\n    const moveCenter = (pos: Vector) => (isSideways ? rotRight(pos) : pos);\n\n    for (const square of N_SQUARE_LAYOUT[this.count]) {\n      const position = Vector.add(\n        center,\n        Vector.scale(moveCenter(square.midpoint), scaleBy)\n      );\n      const width = square.width * scaleBy;\n\n      this.drawSquare(canvas, position, width);\n    }\n  }\n}\n\nexport class EdgeBlankGroupsValidationItem extends EdgeGroupsValidationItem {\n  constructor(isRow: boolean, index: number, count: number) {\n    super(isRow, index, count);\n\n    this.isValid = count === 1;\n  }\n\n  validateRow(row: CellValue[]) {\n    const [numGroups] = row.reduce(\n      ([soFar, inGroup], item) =>\n        !item && inGroup\n          ? // Start of new group\n            [soFar + 1, false]\n          : // Continue, updating inGroup based on current item state\n            [soFar, !!item],\n      [0, true]\n    );\n\n    return numGroups === this.count;\n  }\n\n  drawSquare(canvas: Canvas, position: Vector, width: number) {\n    canvas.setLineDash([]);\n    canvas.setLineWidth(width * 0.25);\n    canvas.strokeRectInset(position.x, position.y, 0, 0, -width * 0.4);\n  }\n}\n\nexport class EdgeNoTripleValidationItem extends EdgeValidationItem {\n  constructor(isRow: boolean, index: number) {\n    super(isRow, index);\n\n    // Valid by default if no triple\n    this.isValid = true;\n  }\n\n  validateRow(row: CellValue[]) {\n    let count = 0;\n    for (const value of row) {\n      if (value) {\n        count += 1;\n      } else {\n        count = 0;\n      }\n      if (count >= 3) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  drawInCell(canvas: Canvas, center: Vector, scaleBy: number, isSideways: boolean) {\n    canvas.setLineWidth(scaleBy * 0.1);\n    canvas.setLineDash([]);\n\n    canvas.fillEllipse(center.x, center.y, 0.22 * scaleBy, 0.22 * scaleBy);\n    const center2 = Vector.add(\n      center,\n      Vector.scale(\n        isSideways ? new Vector(-0.5, 0) : new Vector(0, 0.5),\n        scaleBy\n      )\n    );\n    canvas.fillEllipse(center2.x, center2.y, 0.22 * scaleBy, 0.22 * scaleBy);\n    const center3 = Vector.add(center, Vector.diff(center, center2));\n\n    const radius = scaleBy * 0.22;\n    canvas.drawLine(\n      center3.x - radius,\n      center3.y - radius,\n      center3.x + radius,\n      center3.y + radius\n    );\n    canvas.drawLine(\n      center3.x - radius,\n      center3.y + radius,\n      center3.x + radius,\n      center3.y - radius\n    );\n  }\n}\n", "import {\n  CountInAreaValidation,\n  ForcedCellValidation,\n} from \"./CellValidation\";\nimport {\n  EdgeBlankGroupsValidationItem,\n  EdgeCountValidationItem,\n  EdgeGroupsValidationItem,\n  EdgeNoTripleValidationItem,\n} from \"./EdgeValidation\";\nimport { PuzzleValidator, ValidationItem } from \"./PuzzleValidation\";\n\nexport class PuzzleValidatorFactory {\n  validationItems: ValidationItem[];\n\n  constructor() {\n    this.validationItems = [];\n  }\n\n  addForcedCellValidator(row: number, column: number, mustBeOn: boolean) {\n    this.validationItems.push(new ForcedCellValidation(row, column, mustBeOn));\n    return this;\n  }\n\n  addCountAreaValidator(row: number, column: number, count: number) {\n    this.validationItems.push(new CountInAreaValidation(row, column, count));\n    return this;\n  }\n\n  addEdgeValidators(nums: (number | null)[], isRow: boolean, ValidationItemType = EdgeCountValidationItem) {\n    nums.forEach((num, index) => {\n      if (typeof num !== \"number\") {\n        return;\n      }\n\n      this.validationItems.push(new ValidationItemType(isRow, index, num));\n    });\n  }\n\n  addColumnCounts(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false);\n    return this;\n  }\n\n  addRowCounts(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true);\n    return this;\n  }\n\n  addColumnGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false, EdgeGroupsValidationItem);\n    return this;\n  }\n\n  addRowGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true, EdgeGroupsValidationItem);\n    return this;\n  }\n\n  addColumnBlankGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, false, EdgeBlankGroupsValidationItem);\n    return this;\n  }\n\n  addRowBlankGroups(nums: (number | null)[]) {\n    this.addEdgeValidators(nums, true, EdgeBlankGroupsValidationItem);\n    return this;\n  }\n\n  addColumnNoTriple(yeses: boolean[]) {\n    yeses.forEach((bool, index) => {\n      if (!bool) {\n        return;\n      }\n\n      this.validationItems.push(new EdgeNoTripleValidationItem(false, index));\n    });\n  }\n\n  addRowNoTriple(yeses: boolean[]) {\n    yeses.forEach((bool, index) => {\n      if (!bool) {\n        return;\n      }\n\n      this.validationItems.push(new EdgeNoTripleValidationItem(true, index));\n    });\n  }\n\n  create() {\n    return new PuzzleValidator(this.validationItems);\n  }\n}\n", "import { Puzzle } from \"./Puzzle\";\nimport { PuzzleValidatorFactory } from \"./PuzzleValidatorFactory\";\n\nexport interface PuzzleRules {\n  rows: number;\n  cols: number;\n\n  columnCounts?: (number | null)[];\n  rowCounts?: (number | null)[];\n\n  columnGroups?: (number | null)[];\n  rowGroups?: (number | null)[];\n\n  columnBlankGroups?: (number | null)[];\n  rowBlankGroups?: (number | null)[];\n\n  columnNoTriple?: boolean[];\n  rowNoTriple?: boolean[];\n\n  forcedCells?: { row: number; col: number; on: boolean }[];\n  countAreas?: { row: number; col: number; count: number }[];\n}\n\nexport const initPuzzle = (id: string, options: PuzzleRules) => {\n  const { rows, cols } = options;\n\n  const rules = new PuzzleValidatorFactory();\n\n  if (options.columnCounts) {\n    rules.addColumnCounts(options.columnCounts);\n  }\n  if (options.rowCounts) {\n    rules.addRowCounts(options.rowCounts);\n  }\n  if (options.columnGroups) {\n    rules.addColumnGroups(options.columnGroups);\n  }\n  if (options.rowGroups) {\n    rules.addRowGroups(options.rowGroups);\n  }\n  if (options.columnBlankGroups) {\n    rules.addColumnBlankGroups(options.columnBlankGroups);\n  }\n  if (options.rowBlankGroups) {\n    rules.addRowBlankGroups(options.rowBlankGroups);\n  }\n  if (options.columnNoTriple) {\n    rules.addColumnNoTriple(options.columnNoTriple);\n  }\n  if (options.rowNoTriple) {\n    rules.addRowNoTriple(options.rowNoTriple);\n  }\n  if (options.forcedCells) {\n    options.forcedCells.forEach((cell) => {\n      rules.addForcedCellValidator(cell.row, cell.col, cell.on);\n    });\n  }\n  if (options.countAreas) {\n    options.countAreas.forEach((cell) => {\n      rules.addCountAreaValidator(cell.row, cell.col, cell.count);\n    });\n  }\n\n  return new Puzzle(id, rows, cols, rules.create());\n};\n", "import { Puzzle } from \"./Puzzle\";\nimport { initPuzzle, PuzzleRules } from \"./PuzzleFactory\";\n\nconst RULES: Record<string, PuzzleRules> = {\n  1: { rows: 1, cols: 1, columnCounts: [1], rowCounts: [1] },\n  2: { rows: 2, cols: 1, columnCounts: [2], rowCounts: [1, 1] },\n  3: { rows: 2, cols: 2, columnCounts: [2, 1], rowCounts: [1, 2] },\n  4: { rows: 3, cols: 3, columnCounts: [1, 3, 2], rowCounts: [1, 2, 3] },\n  5: { rows: 3, cols: 3, columnCounts: [2, 3, 1], rowCounts: [2, 3, 1] },\n  6: { rows: 3, cols: 4, columnCounts: [2, 1, 3, 2], rowCounts: [3, 4, 1] },\n  7: { rows: 4, cols: 4, columnCounts: [2, 4, 2, 1], rowCounts: [4, 1, 1, 3] },\n  8: {\n    rows: 5,\n    cols: 5,\n    columnCounts: [2, 4, 2, 3, 5],\n    rowCounts: [1, 3, 5, 5, 2],\n  },\n};\n\nfunction makePuzzle(id: string): Puzzle {\n  if (id in RULES) {\n    return initPuzzle(id, RULES[id]);\n  }\n\n  throw new Error(`Cannot find puzzle with id: ${id}`);\n}\n\nclass PuzzleManagerInstance {\n  puzzleMap: Record<string, Puzzle>;\n\n  constructor() {\n    this.puzzleMap = {};\n  }\n\n  loadPuzzle(id: string): Puzzle {\n    return makePuzzle(id);\n  }\n\n  getPuzzle(id: string) {\n    if (id in this.puzzleMap) {\n      return this.puzzleMap[id];\n    }\n\n    const puzzle = this.loadPuzzle(id);\n    this.puzzleMap[id] = puzzle;\n\n    return puzzle;\n  }\n}\n\nexport const PuzzleManager = new PuzzleManagerInstance();\n", "import { ExitTrigger } from \"./ExitTrigger\";\n\nexport class LevelEvent {\n  constructor() {}\n\n  isExitEvent() {\n    return false;\n  }\n\n  isOpenPuzzleEvent() {\n    return false;\n  }\n\n  isClosePuzzleEvent() {\n    return false;\n  }\n}\n\nexport class ExitEvent extends LevelEvent {\n  exitTrigger: ExitTrigger;\n\n  constructor(exitTrigger: ExitTrigger) {\n    super();\n    this.exitTrigger = exitTrigger;\n  }\n\n  isExitEvent() {\n    return true;\n  }\n}\n\nexport class OpenPuzzleEvent extends LevelEvent {\n  puzzleId: string;\n\n  constructor(puzzleId: string) {\n    super();\n    this.puzzleId = puzzleId;\n  }\n\n  isOpenPuzzleEvent() {\n    return true;\n  }\n}\n\nexport class ClosePuzzleEvent extends LevelEvent {\n  puzzleId: string;\n\n  constructor(puzzleId: string) {\n    super();\n    this.puzzleId = puzzleId;\n  }\n\n  isClosePuzzleEvent() {\n    return true;\n  }\n}\n", "import { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport {\n  DEFAULT_BACKGROUND,\n  SOLVED_BACKGROUND,\n} from \"../../puzzle-manager/constants\";\nimport { Puzzle } from \"../../puzzle-manager/Puzzle\";\nimport { PuzzleManager } from \"../../puzzle-manager/PuzzleManager\";\nimport { ScreenManager } from \"../../ScreenManager\";\n\nimport { OpenPuzzleEvent } from \"../LevelEvent\";\n\nimport { Interactible } from \"./Interactible\";\n\ninterface Config {\n  isFlipped?: boolean;\n}\n\nexport class PuzzleInteractible extends Interactible {\n  puzzleId: string;\n  puzzle: Puzzle;\n  config: Config;\n\n  constructor(id: string, position: Vector, area: Rectangle, prereqs: string[], puzzleId: string, config: Config) {\n    super(id, position, area, prereqs);\n\n    this.puzzleId = puzzleId;\n    this.puzzle = PuzzleManager.getPuzzle(puzzleId);\n    this.connectionPoint = Vector.add(position, new Vector(0, 1.2));\n    this.outputPoint = Vector.add(\n      position,\n      new Vector(config.isFlipped ? -1 : 1, -1.15)\n    );\n    this.config = config;\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const SCREEN_W = 1;\n    const PIXEL_SCALE = 1 / PIXELS_PER_TILE;\n\n    // Draw monitor leg\n    canvas.setColorRGB(0, 0, 0);\n    canvas.fillRect(\n      this.position.x - SCREEN_W / 2,\n      this.position.y + SCREEN_W,\n      SCREEN_W,\n      1\n    );\n\n    canvas.setLineWidth(PIXEL_SCALE);\n\n    // Draw hover outline\n    if (this.isAreaActive) {\n      canvas.setColorRGB(255, 255, 255, 128);\n      canvas.strokeRectInset(\n        this.position.x,\n        this.position.y,\n        0,\n        0,\n        -SCREEN_W - PIXEL_SCALE * 1.5\n      );\n    }\n\n    // Draw monitor outline\n    canvas.setColorRGB(0, 0, 0);\n    canvas.strokeRectInset(\n      this.position.x,\n      this.position.y,\n      0,\n      0,\n      -SCREEN_W - PIXEL_SCALE / 2\n    );\n\n    // Draw light area\n    const isFlippedMul = this.config.isFlipped ? -1 : 1;\n    canvas.fillRect(\n      this.position.x +\n        isFlippedMul * (SCREEN_W - PIXEL_SCALE) -\n        2 * PIXEL_SCALE,\n      this.position.y - SCREEN_W - 4 * PIXEL_SCALE,\n      4 * PIXEL_SCALE,\n      4 * PIXEL_SCALE\n    );\n\n    if (this.puzzle.hasBeenSolvedEver) {\n      this.isEnabled = true;\n      canvas.setColor(\"white\");\n      canvas.fillRect(\n        this.position.x + isFlippedMul * (SCREEN_W - PIXEL_SCALE) - PIXEL_SCALE,\n        this.position.y - SCREEN_W - 3 * PIXEL_SCALE,\n        PIXEL_SCALE * 2,\n        PIXEL_SCALE * 2\n      );\n    }\n\n    if (this.prereqsActive) {\n      // Draw screen\n      canvas.setColor(\n        this.puzzle.isSolved ? SOLVED_BACKGROUND : DEFAULT_BACKGROUND\n      );\n      canvas.fillRect(\n        this.position.x - SCREEN_W,\n        this.position.y - SCREEN_W,\n        SCREEN_W * 2,\n        SCREEN_W * 2\n      );\n    }\n\n    const offset = new Vector(\n      this.position.x - SCREEN_W,\n      this.position.y - SCREEN_W\n    );\n\n    canvas.translate(offset.x, offset.y);\n\n    canvas.setColor(\"white\");\n\n    // Draw current selection\n    const rows = this.puzzle.state;\n    const SCREEN_PIXEL =\n      (SCREEN_W * 2) / (3 * Math.max(rows.length, rows[0].length) + 1);\n    const SCR_WIDTH = SCREEN_PIXEL * (3 * rows[0].length + 1);\n    const SCR_HEIGHT = SCREEN_PIXEL * (3 * rows.length + 1);\n\n    const TOP_PAD = Math.max(0, (SCR_WIDTH - SCR_HEIGHT) / 2);\n    const LEFT_PAD = Math.max(0, (SCR_HEIGHT - SCR_WIDTH) / 2);\n\n    for (let row = 0; row < rows.length; row++) {\n      for (let col = 0; col < rows[row].length; col++) {\n        if (rows[row][col]) {\n          canvas.fillRect(\n            LEFT_PAD + SCREEN_PIXEL * (3 * col + 1),\n            TOP_PAD + SCREEN_PIXEL * (3 * row + 1),\n            SCREEN_PIXEL * 2,\n            SCREEN_PIXEL * 2\n          );\n        }\n      }\n    }\n\n    canvas.translate(-offset.x, -offset.y);\n  }\n\n  onInteract() {\n    return new OpenPuzzleEvent(this.puzzleId);\n  }\n}\n", "import { EntityImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nexport class SwitchInteractible extends Interactible {\n  constructor(id: string, position: Vector, area: Rectangle, prerequisites: string[]) {\n    super(id, position, area, prerequisites);\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    if (this.isEnabled) {\n      this.isAreaActive = false;\n    } else {\n      super.update(player, deltaTime, level);\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    const PIXEL_SCALE = 1 / PIXELS_PER_TILE;\n\n    // Draw hover outline\n    if (this.isAreaActive) {\n      canvas.setColorRGB(255, 255, 255, 128);\n      canvas.setLineWidth(PIXEL_SCALE);\n      canvas.setLineDash([]);\n      canvas.strokeRectInset(\n        this.position.x - PIXEL_SCALE * 3,\n        this.position.y - PIXEL_SCALE * 4,\n        PIXEL_SCALE * 6,\n        PIXEL_SCALE * 8,\n        -PIXEL_SCALE * 1.5\n      );\n    }\n\n    canvas.drawImage(\n      EntityImage,\n      this.isEnabled ? 80 : 40,\n      0,\n      PIXELS_PER_TILE * 4,\n      PIXELS_PER_TILE * 4,\n      this.position.x - 2,\n      this.position.y - 2,\n      4,\n      4\n    );\n  }\n\n  onInteract() {\n    this.isEnabled = true;\n  }\n}\n", "import { EntityImage, TileImage } from \"../../constants/Image\";\nimport { PIXELS_PER_TILE } from \"../../constants/ScreenConstants\";\nimport { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { Vector } from \"../../math/Vector\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { BlockEnum } from \"../BlockTypes\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Interactible } from \"./Interactible\";\n\nconst mockTrigger = {\n  intersectsPoint: () => false,\n  stroke: () => null,\n};\n\nconst OPEN_CLOSE_DUR = 0.3;\n\ninterface Config {\n  isFlipped?: boolean;\n  hasLedge?: boolean;\n}\n\nexport class TrapdoorInteractible extends Interactible {\n  hasLeft: boolean;\n  hasRight: boolean;\n  hasLedge: boolean;\n\n  leftHead: Rectangle;\n  rightHead: Rectangle;\n  leftDoor: Rectangle;\n  rightDoor: Rectangle;\n\n  ledge: Rectangle;\n\n  fullWidth: number;\n  doorWidth: number;\n\n  constructor(id: string, position: Vector, prerequisites: string[], width = 4, config: Config = {}) {\n    super(id, position, undefined, prerequisites);\n\n    this.connectionPoint = Vector.add(\n      position,\n      new Vector((config.isFlipped ? 1 : -1) * (width / 2 - 0.9), 0.3)\n    );\n\n    this.hasLeft = width > 4 || !config.isFlipped;\n    this.hasRight = width > 4 || !!config.isFlipped;\n\n    this.hasLedge = !!config.hasLedge;\n\n    this.leftHead = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      1.2,\n      0.8\n    );\n    this.rightHead = Rectangle.widthForm(\n      this.position.x + width / 2 - 1.2,\n      this.position.y,\n      1.2,\n      0.8\n    );\n    this.leftDoor = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      this.hasRight ? width / 2 : width,\n      0.6\n    );\n    this.rightDoor = Rectangle.widthForm(\n      this.position.x - (this.hasLeft ? 0 : width / 2),\n      this.position.y,\n      this.hasLeft ? width / 2 : width,\n      0.6\n    );\n\n    this.ledge = Rectangle.widthForm(\n      this.position.x - width / 2,\n      this.position.y,\n      width,\n      0.2\n    );\n\n    this.fullWidth = width / 2;\n    this.doorWidth = this.hasLeft && this.hasRight ? width / 2 : width;\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n\n    if (this.hasLeft) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.leftHead,\n      });\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.leftDoor,\n      });\n    }\n    if (this.hasRight) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.rightHead,\n      });\n      level.addWithoutDuplicate({\n        type: BlockEnum.SOLID,\n        rect: this.rightDoor,\n      });\n    }\n\n    if (this.hasLedge) {\n      level.addWithoutDuplicate({\n        type: BlockEnum.LEDGE,\n        rect: this.ledge,\n      });\n    }\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const motion = (deltaTime / OPEN_CLOSE_DUR) * (this.prereqsActive ? -1 : 1);\n\n    this.leftDoor.x2 = clamp(\n      this.leftDoor.x2 + motion,\n      this.leftDoor.x1,\n      this.leftDoor.x1 + this.doorWidth\n    );\n\n    this.rightDoor.x1 = clamp(\n      this.rightDoor.x1 - motion,\n      this.rightDoor.x2 - this.doorWidth,\n      this.rightDoor.x2\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    const canvas = screenManager.dynamicWorldCanvas;\n\n    if (this.hasLedge) {\n      for (let x = -this.ledge.x1; x < this.ledge.x2; x++) {\n        canvas.drawImage(\n          TileImage,\n          PIXELS_PER_TILE,\n          0,\n          PIXELS_PER_TILE,\n          PIXELS_PER_TILE,\n          x,\n          this.ledge.y1,\n          1,\n          1\n        );\n      }\n    }\n\n    if (this.hasLeft) {\n      const w = this.leftDoor.width;\n      if (w > 0) {\n        canvas.setColor(\"black\");\n        this.leftDoor.draw(canvas);\n        canvas.drawImage(\n          EntityImage,\n          160 + Math.max(40 - 10 * w, 20) - 10,\n          10,\n          Math.min(10 * w, 20),\n          10,\n          Math.max(this.leftDoor.x1, this.leftDoor.x2 - 2),\n          this.position.y,\n          Math.min(w, 2),\n          1\n        );\n      }\n\n      canvas.drawImage(\n        EntityImage,\n        this.prereqsActive ? 180 : 160,\n        0,\n        12,\n        8,\n        this.leftHead.x1,\n        this.leftHead.y1,\n        this.leftHead.width,\n        this.leftHead.height\n      );\n    }\n    if (this.hasRight) {\n      const w = this.rightDoor.width;\n      if (w > 0) {\n        canvas.setColor(\"black\");\n        this.rightDoor.draw(canvas);\n        canvas.drawImage(\n          EntityImage,\n          170,\n          30,\n          Math.min(10 * w, 20),\n          10,\n          this.rightDoor.x1,\n          this.position.y,\n          Math.min(w, 2),\n          1\n        );\n      }\n\n      canvas.drawImage(\n        EntityImage,\n        this.prereqsActive ? 188 : 168,\n        20,\n        12,\n        8,\n        this.rightHead.x1,\n        this.rightHead.y1,\n        this.rightHead.width,\n        this.rightHead.height\n      );\n    }\n  }\n}\n", "import { clamp } from \"../../math/Common\";\nimport { Rectangle } from \"../../math/Shapes\";\nimport { ScreenManager } from \"../../ScreenManager\";\nimport { Level } from \"../Level\";\nimport { Player } from \"../Player\";\n\nimport { Entity } from \"./Entity\";\n\nconst UNCOVER_DURATION = 0.5;\n\ninterface Config {\n  coverIsTrigger?: boolean;\n  canReCover?: boolean;\n}\n\nexport class CoverEntity extends Entity {\n  coverArea: Rectangle;\n  triggerArea: Rectangle;\n\n  coverIsTrigger: boolean;\n  canReCover: boolean;\n  isUncovered: boolean;\n\n  revealState: number;\n\n  constructor(id: string, coverArea: Rectangle, triggerArea: Rectangle, config: Config = {}) {\n    super(id);\n\n    this.coverArea = coverArea;\n    this.triggerArea = triggerArea;\n\n    this.coverIsTrigger = !!config.coverIsTrigger;\n    this.canReCover = !!config.canReCover;\n\n    this.isUncovered = false;\n    this.revealState = 0;\n  }\n\n  isPlayerTriggering(player: Player) {\n    return (\n      this.triggerArea.intersectsPoint(player.position) ||\n      (this.coverIsTrigger && this.coverArea.intersectsPoint(player.position))\n    );\n  }\n\n  isOpen(player: Player) {\n    if (!this.canReCover) {\n      if (this.isUncovered) {\n        return true;\n      } else {\n        this.isUncovered = this.isPlayerTriggering(player);\n        return this.isUncovered;\n      }\n    } else {\n      return this.isPlayerTriggering(player);\n    }\n  }\n\n  onStart(level: Level) {\n    super.onStart(level);\n  }\n\n  update(player: Player, deltaTime: number, level: Level) {\n    super.update(player, deltaTime, level);\n\n    const isOpen = this.isOpen(player);\n\n    this.revealState = clamp(\n      this.revealState + (isOpen ? 1 : -1) * (deltaTime / UNCOVER_DURATION),\n      0,\n      1\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    super.draw(screenManager);\n\n    if (this.revealState < 1) {\n      const canvas = screenManager.dynamicWorldCanvas;\n\n      canvas.setColorRGB(\n        0,\n        0,\n        0,\n        Math.floor(255 * (1 - this.revealState * this.revealState))\n      );\n      this.coverArea.draw(canvas);\n    }\n  }\n}\n", "import { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { Player } from \"./Player\";\n\nexport class ExitTrigger {\n  collider: Rectangle;\n  key: string;\n  nextLevelCollider: Rectangle;\n\n  constructor(collider: Rectangle, key: string, nextLevelCollider: Rectangle) {\n    this.collider = collider;\n    this.key = key;\n    this.nextLevelCollider = nextLevelCollider || collider;\n  }\n\n  hasEntered(player: Player) {\n    return this.collider.intersectsPoint(player.position);\n  }\n\n  translatePlayerToNext(player: Player) {\n    return Vector.diff(\n      player.position,\n      new Vector(this.nextLevelCollider.x1, this.nextLevelCollider.y1)\n    );\n  }\n}\n", "const Up = Symbol(\"Up\");\nconst Down = Symbol(\"Down\");\nconst Left = Symbol(\"Left\");\nconst Right = Symbol(\"Right\");\nconst Jump = Symbol(\"Jump\");\nconst Interact = Symbol(\"Interact\");\nconst Escape = Symbol(\"Escape\");\n\n// TODO Convert this to an enum\nexport const Input = {\n  Down,\n  Escape,\n  Interact,\n  Jump,\n  Left,\n  Right,\n  Up,\n};\n", "import { Input } from \"./constants/Keys\";\nimport {\n  UI_CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_WIDTH,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nconst KEY_MAP: Record<string, Key> = {\n  \" \": Input.Jump,\n  escape: Input.Escape,\n  esc: Input.Escape,\n  Escape: Input.Escape,\n  Esc: Input.Escape,\n  w: Input.Up,\n  a: Input.Left,\n  s: Input.Down,\n  d: Input.Right,\n  e: Input.Interact,\n};\n\ntype ValueOf<T> = T[keyof T];\n\ntype Key = ValueOf<typeof Input>;\n\ntype KeyMap = Record<Key, boolean>;\n\nexport class InputState {\n  keyMap: KeyMap;\n  mousePosition: Vector;\n\n  constructor(keyMap: KeyMap, mousePosition: Vector) {\n    this.keyMap = keyMap;\n    this.mousePosition = mousePosition;\n  }\n\n  /**\n   * Check the current value for the horizontal axis input.\n   * @return {number} a value from -1 to 1.\n   */\n  getHorizontalAxis() {\n    return +!!this.keyMap[Input.Right] - +!!this.keyMap[Input.Left];\n  }\n\n  /**\n   * Checks whether an input is currently pressed.\n   * @param {Input} input\n   */\n  isPressed(input: Key) {\n    return !!this.keyMap[input];\n  }\n\n  static empty() {\n    return new InputState({}, new Vector(0, 0));\n  }\n}\n\nexport class InputEvent {\n  constructor() {}\n\n  isForKey(_key: Key) {\n    return false;\n  }\n\n  isClick() {\n    return false;\n  }\n}\n\nexport class KeyPressEvent extends InputEvent {\n  input: Key;\n\n  constructor(input: Key) {\n    super();\n    this.input = input;\n  }\n\n  isForKey(key: Key) {\n    return key === this.input;\n  }\n}\n\nexport class ClickEvent extends InputEvent {\n  position: Vector;\n  isRight: boolean;\n\n  constructor(position: Vector, isRightClick: boolean) {\n    super();\n    this.position = position;\n    this.isRight = isRightClick;\n  }\n\n  isClick() {\n    return true;\n  }\n\n  isRightClick() {\n    return this.isRight;\n  }\n}\n\nexport class InputManager {\n  listener: (inputEvent: InputEvent) => void;\n\n  isMouseDown: boolean;\n  isButtonDown: KeyMap;\n  mousePosition: Vector;\n\n  canvas: HTMLCanvasElement;\n\n  constructor(listener: (inputEvent: InputEvent) => void) {\n    this.isMouseDown = false;\n    this.isButtonDown = {};\n    this.listener = listener;\n    this.mousePosition = new Vector(0, 0);\n\n    this.canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  }\n\n  /**\n   * Set up event listeners.\n   */\n  init() {\n    const onKeyEvent = (symbol: Key) => {\n      if (this.listener) {\n        this.listener(new KeyPressEvent(symbol));\n      }\n    };\n\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.repeat) {\n        return;\n      }\n      const symbol = KEY_MAP[e.key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = true;\n      onKeyEvent(symbol);\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const symbol = KEY_MAP[e.key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = false;\n    });\n\n    document.addEventListener(\"mousemove\", (event) => {\n      this.mousePosition = this.toCanvasPosition(event);\n    });\n\n    document.addEventListener(\"click\", (event) => {\n      this.mousePosition = this.toCanvasPosition(event);\n\n      if (this.listener) {\n        this.listener(new ClickEvent(this.mousePosition, false));\n      }\n    });\n\n    document.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n      this.mousePosition = this.toCanvasPosition(event);\n\n      if (this.listener) {\n        this.listener(new ClickEvent(this.mousePosition, true));\n      }\n    });\n\n    const wireButton = (id: string, input: Key) => {\n      const btn = document.getElementById(id);\n\n      if (!btn) {\n        return;\n      }\n\n      btn.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n        this.isButtonDown[input] = true;\n\n        onKeyEvent(input);\n      });\n\n      btn.addEventListener(\"touchcancel\", (e) => {\n        e.preventDefault();\n        this.isButtonDown[input] = false;\n      });\n\n      btn.addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        this.isButtonDown[input] = false;\n      });\n    };\n\n    wireButton(\"left\", Input.Left);\n    wireButton(\"right\", Input.Right);\n    wireButton(\"jump\", Input.Jump);\n    wireButton(\"down\", Input.Down);\n    wireButton(\"escape\", Input.Escape);\n    wireButton(\"interact\", Input.Interact);\n  }\n\n  toCanvasPosition(event: MouseEvent) {\n    return Vector.scale(\n      new Vector(\n        event.clientX - this.canvas.offsetLeft,\n        event.clientY - this.canvas.offsetTop\n      ),\n      ((this.canvas.width / this.canvas.clientWidth) * UI_CANVAS_WIDTH) /\n        ON_SCREEN_CANVAS_WIDTH\n    );\n  }\n\n  /**\n   * @return {InputState} The current state of inputs\n   */\n  getInputState() {\n    return new InputState(this.isButtonDown, this.mousePosition);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { TileImage } from \"../constants/Image\";\nimport { Input } from \"../constants/Keys\";\nimport {\n  CANVAS_WIDTH,\n  HORIZONTAL_TILES,\n  PIXELS_PER_TILE,\n  VERTICAL_TILES,\n} from \"../constants/ScreenConstants\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { clamp } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nimport { Entity } from \"./entity/Entity\";\n\nimport { BlockEnum } from \"./BlockTypes\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { ClosePuzzleEvent, ExitEvent, LevelEvent, OpenPuzzleEvent } from \"./LevelEvent\";\nimport { Interactible } from \"./interactibles/Interactible\";\nimport { Player } from \"./Player\";\nimport { PlayMode } from \"../game-modes/PlayMode\";\n\nconst SCALE_FACTOR = CANVAS_WIDTH / HORIZONTAL_TILES;\n\nexport interface Object {\n  type: BlockEnum;\n  rect: Rectangle;\n}\n\nexport class Level {\n  key: string;\n  levelGrid: BlockEnum[][];\n  width: number;\n  height: number;\n\n  player: Player;\n\n  objects: Object[];\n  exitTriggers: ExitTrigger[];\n  interactibles: Interactible[];\n  entities: Entity[];\n\n  camera: Vector;\n  interactingWith: Interactible | undefined;\n\n  drawnStatic: boolean;\n  playModeManager: PlayMode | undefined;\n\n  constructor(\n    key: string,\n    width: number,\n    height: number,\n    levelGrid: BlockEnum[][],\n    objects: Object[],\n    player: Player,\n    exitTriggers: ExitTrigger[],\n    interactibles: Interactible[],\n    entities: Entity[]\n  ) {\n    this.key = key;\n    this.levelGrid = levelGrid;\n    this.objects = objects;\n    this.player = player;\n    this.exitTriggers = exitTriggers;\n    this.interactibles = interactibles;\n    this.entities = entities;\n\n    this.width = width;\n    this.height = height;\n\n    this.camera = this.getIdealCamera();\n    this.interactingWith = undefined;\n\n    this.drawnStatic = false;\n\n    this.playModeManager = undefined;\n  }\n\n  start(playModeManager: PlayMode) {\n    this.drawnStatic = false;\n    this.interactingWith = undefined;\n    this.playModeManager = playModeManager;\n    this.interactibles.forEach((i) => i.onStart(this));\n    this.entities.forEach((e) => e.onStart(this));\n  }\n\n  addWithoutDuplicate(object: Object) {\n    if (!this.objects.find(({ rect }) => rect === object.rect)) {\n      this.objects.push(object);\n    }\n  }\n\n  emitEvent(event: LevelEvent) {\n    // TODO: Either guarantee that this is available or create a queue to send\n    // these events once it does become available.\n    if (this.playModeManager) {\n      this.playModeManager.onLevelEvent(event);\n    }\n  }\n\n  feedPlayerInfo(previousPlayer: Player, previousExit: ExitTrigger) {\n    if (previousExit.key !== this.key) {\n      console.error(\"Exit key mis-match\");\n    }\n    const position = previousExit.translatePlayerToNext(previousPlayer);\n\n    this.player.position.x = position.x;\n    this.player.position.y = position.y;\n\n    this.player.velocity = previousPlayer.velocity.copy();\n\n    this.camera = this.getIdealCamera();\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    // Update player\n    this.player.update(\n      deltaTime,\n      this.isPlayerActive() ? inputState : InputState.empty(),\n      this\n    );\n\n    // Update interactibles\n    this.interactibles.forEach((interactible) => {\n      interactible.update(this.player, deltaTime, this);\n    });\n    if (!this.interactingWith?.isAreaActive) {\n      this.closeCurrentPuzzle();\n      this.interactingWith = undefined;\n    }\n\n    // Update entities\n    this.entities.forEach((entity) => {\n      entity.update(this.player, deltaTime, this);\n    });\n\n    this.updateCamera(deltaTime);\n\n    this.updateExits();\n  }\n\n  isPlayerActive() {\n    return !this.interactingWith;\n  }\n\n  closeCurrentPuzzle() {\n    // Don't close unnecessarily\n    if (this.interactingWith) {\n      this.emitEvent(new ClosePuzzleEvent(this.interactingWith.id));\n    }\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (this.isPlayerActive()) {\n      this.player.onInput(input);\n    }\n\n    if (input.isForKey(Input.Interact)) {\n      const relevant = this.interactibles.find((i) => i.isAreaActive);\n      if (relevant) {\n        const event = relevant.onInteract();\n\n        if (event && event instanceof OpenPuzzleEvent) {\n          this.interactingWith = relevant;\n          this.emitEvent(event);\n        }\n      }\n    } else if (input.isForKey(Input.Escape)) {\n      this.closeCurrentPuzzle();\n\n      this.interactingWith = undefined;\n    }\n  }\n\n  /**\n   * Check if the player should exit.\n   * @returns The trigger key.\n   */\n  updateExits() {\n    const triggeredExit = this.exitTriggers.find((trigger) =>\n      trigger.hasEntered(this.player)\n    );\n\n    if (triggeredExit) {\n      this.emitEvent(new ExitEvent(triggeredExit));\n    }\n  }\n\n  clampCamera(camera: Vector) {\n    const clampedToPlayer = new Vector(\n      clamp(\n        camera.x,\n        this.player.position.x - HORIZONTAL_TILES + 1,\n        this.player.position.x - 1\n      ),\n      clamp(\n        camera.y,\n        this.player.position.y - VERTICAL_TILES + 1,\n        this.player.position.y - 1\n      )\n    );\n    const clampedToLevel = new Vector(\n      clamp(clampedToPlayer.x, 0, this.width - HORIZONTAL_TILES),\n      clamp(clampedToPlayer.y, 0, this.height - VERTICAL_TILES)\n    );\n\n    return clampedToLevel;\n  }\n\n  getNaiveCamera(position = this.player.position) {\n    return new Vector(\n      position.x - HORIZONTAL_TILES / 2,\n      position.y - VERTICAL_TILES / 2\n    );\n  }\n\n  getIdealCamera(position = this.player.position) {\n    return this.clampCamera(this.getNaiveCamera(position));\n  }\n\n  updateCamera(deltaTime: number) {\n    this.camera = this.clampCamera(\n      Vector.lerp(\n        this.camera,\n        this.getNaiveCamera(\n          Vector.add(\n            this.player.position,\n            new Vector(this.player.velocity.x * 0.3, 0)\n          )\n        ),\n        deltaTime * 2\n      )\n    );\n  }\n\n  withSetupCanvas(canvas: Canvas, action: (canvas: Canvas) => void) {\n    canvas.saveTransform();\n    canvas.scale(SCALE_FACTOR, SCALE_FACTOR);\n    action(canvas);\n    canvas.restoreTransform();\n  }\n\n  /**\n   * Draw the current level.\n   * @param {ScreenManager} screenManager The screen to draw on\n   */\n  draw(screenManager: ScreenManager) {\n    if (!this.drawnStatic) {\n      // Draw background\n      screenManager.background.setColor(\"#6400c8\");\n      screenManager.background.fillRect(\n        0,\n        0,\n        screenManager.background.width,\n        screenManager.background.height\n      );\n\n      this.withSetupCanvas(screenManager.staticWorldCanvas, (canvas) => {\n        canvas.clear();\n\n        canvas.setColor(\"black\");\n        for (let row = 0; row < this.height; row++) {\n          for (let col = 0; col < this.width; col++) {\n            const blockType = this.levelGrid[row][col];\n\n            if (blockType) {\n              canvas.drawImage(\n                TileImage,\n                (blockType - 1) * PIXELS_PER_TILE,\n                0,\n                PIXELS_PER_TILE,\n                PIXELS_PER_TILE,\n                col,\n                row,\n                1,\n                1\n              );\n            }\n          }\n        }\n      });\n\n      this.drawnStatic = true;\n    }\n\n    this.withSetupCanvas(screenManager.dynamicWorldCanvas, (canvas) => {\n      canvas.clear();\n\n      this.withSetupCanvas(screenManager.behindGroundCanvas, () => {\n        screenManager.behindGroundCanvas.clear();\n\n        // Draw interactibles\n        this.interactibles.forEach((interactible) => {\n          interactible.draw(screenManager);\n        });\n\n        // Draw player\n        this.player.draw(canvas);\n\n        // Draw entities\n        this.entities.forEach((entity) => {\n          entity.draw(screenManager);\n        });\n      });\n    });\n\n    screenManager.setCamera(\n      new Vector(\n        Math.floor(this.camera.x * SCALE_FACTOR),\n        Math.floor(this.camera.y * SCALE_FACTOR)\n      )\n    );\n  }\n}\n", "import { Rectangle } from \"../math/Shapes\";\n\n/**\n * They say premature optimization is the root of all evil.\n *\n * Oh no.\n */\n\nclass RectPoolClass {\n  grid: Rectangle[][];\n  shortGrid: Rectangle[][];\n\n  constructor() {\n    this.grid = [];\n    this.shortGrid = [];\n  }\n\n  innerGet(row: number, col: number, isShort: boolean, grid: Rectangle[][]) {\n    if (!(row in grid)) {\n      grid[row] = [];\n    }\n    if (!(col in grid[row])) {\n      grid[row][col] = Rectangle.widthForm(col, row, 1, isShort ? 0.2 : 1);\n    }\n\n    return grid[row][col];\n  }\n\n  get(row: number, col: number, isShort = false) {\n    return this.innerGet(\n      row,\n      col,\n      isShort,\n      isShort ? this.shortGrid : this.grid\n    );\n  }\n}\n\n// Woo! Singleton pattern again...\nexport const RectPool = new RectPoolClass();\n", "import { Canvas } from \"../Canvas\";\nimport { Input } from \"../constants/Keys\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { clamp, sign } from \"../math/Common\";\nimport { Circle, Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { BlockEnum, BlockType } from \"./BlockTypes\";\nimport { Level } from \"./Level\";\n\nimport { RectPool } from \"./RectPool\";\n\nconst PLAYER_RADIUS = 0.8;\n\n// Running parameters\nconst PLAYER_MAX_SPEED = 16;\nconst PLAYER_ACCEL = PLAYER_MAX_SPEED / 0.3;\nconst PLAYER_DECEL = 2 * PLAYER_ACCEL;\nconst TURN_SPEED = 1.8 * PLAYER_ACCEL;\n\n// Jump speed parameters\nconst JUMP_HEIGHT = 4;\nconst JUMP_DURATION = 0.6;\nconst PARAM_A = (4 * JUMP_HEIGHT) / JUMP_DURATION;\nconst JUMP_INITIAL_SPEED = PARAM_A;\nconst GRAVITY = (2 * PARAM_A) / JUMP_DURATION;\n\n// Jump assist parameters\nconst COYOTE_TIME = 0.1;\n\nfunction isDefined<T>(value: T | undefined): value is T {\n  return !!value;\n}\n\nexport class Player {\n  position: Vector;\n  velocity: Vector;\n  collider: Circle;\n\n  isColliding: boolean;\n  isGrounded: boolean;\n  isDropping: boolean;\n\n  wantsToJump: boolean;\n  contactingAnyLedge: boolean;\n  inAirFor: number;\n\n  constructor(position: Vector) {\n    this.position = position;\n    this.collider = new Circle(position, PLAYER_RADIUS);\n\n    this.velocity = new Vector(0, 0);\n\n    this.isColliding = false;\n    this.isGrounded = false;\n    this.isDropping = false;\n\n    this.wantsToJump = false;\n    this.contactingAnyLedge = false;\n    this.inAirFor = 1;\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    if (input.isForKey(Input.Jump)) {\n      this.wantsToJump = true;\n    }\n  }\n\n  collideWithBlock(type: BlockEnum, rect: Rectangle, deltaTime: number) {\n    const isActiveLedge =\n      !this.isDropping &&\n      type === BlockEnum.LEDGE &&\n      this.velocity.y >= 0 &&\n      this.position.y < rect.y1;\n\n    const intersects = this.collider.intersectsRectangle(rect);\n\n    if (intersects && type === BlockEnum.LEDGE) {\n      this.contactingAnyLedge = true;\n      if (this.velocity.y < 0 && this.position.y >= rect.y1) {\n        this.isDropping = true;\n      }\n    }\n\n    if (BlockType.isSolid(type) || isActiveLedge) {\n      if (intersects) {\n        this.isColliding = true;\n        const collidingBy = rect.uncollideCircle(this.collider);\n\n        this.velocity.add(Vector.scale(collidingBy, 1 / deltaTime));\n        // Horizontal rebound\n        if (collidingBy.x > 0 && collidingBy.y === 0) {\n          this.velocity.x = Math.max(0, this.velocity.x);\n        } else if (collidingBy.x < 0 && collidingBy.y === 0) {\n          this.velocity.x = Math.min(0, this.velocity.x);\n        }\n        // Vertical rebound\n        if (collidingBy.y > 0 && collidingBy.x === 0) {\n          this.velocity.y = Math.max(0, this.velocity.y);\n        } else if (collidingBy.y < 0 && collidingBy.x === 0) {\n          this.velocity.y = Math.min(0, this.velocity.y);\n        }\n        this.position.add(collidingBy);\n      }\n      return this.collider.intersectsRectangle(rect);\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   * @param {Level} level The level that the player is in.\n   */\n  update(deltaTime: number, inputState: InputState, level: Level) {\n    const getCellAt = (x: number, y: number) => {\n      return level.levelGrid[Math.floor(y)]?.[Math.floor(x)];\n    };\n    const getRectAt = (x: number, y: number) => {\n      const type = getCellAt(x, y);\n      if (type) {\n        return {\n          type: getCellAt(x, y),\n          rect: RectPool.get(\n            Math.floor(y),\n            Math.floor(x),\n            type === BlockEnum.LEDGE\n          ),\n        };\n      }\n    };\n\n    // Process horizontal input\n    const inputX = inputState.getHorizontalAxis();\n    const acceleration = new Vector(inputX * PLAYER_ACCEL, 0);\n\n    if (inputState.isPressed(Input.Down)) {\n      this.isDropping = true;\n    }\n\n    // Check grounded\n    const playerBottom = this.position.y + this.collider.radius;\n    const cellBelow = getCellAt(this.position.x, playerBottom);\n    const groundingCellBelow = this.isDropping\n      ? BlockType.isSolid(cellBelow)\n      : BlockType.isGrounding(cellBelow);\n\n    const gridCellWithin = getCellAt(this.position.x, this.position.y);\n    const groundedOnGridCell =\n      groundingCellBelow && playerBottom === Math.floor(playerBottom);\n\n    this.isGrounded =\n      groundedOnGridCell ||\n      level.objects.some(\n        ({ type, rect }) =>\n          (this.isDropping\n            ? BlockType.isSolid(type)\n            : BlockType.isGrounding(type)) && this.collider.isKissingBelow(rect)\n      );\n\n    // General motion\n    if (this.isGrounded) {\n      this.inAirFor = 0;\n      if (sign(inputX)) {\n        // Turn speed\n        if (sign(inputX) !== sign(this.velocity.x)) {\n          acceleration.x += -TURN_SPEED * sign(this.velocity.x);\n        }\n      } else {\n        acceleration.x +=\n          -Math.min(Math.abs(this.velocity.x / deltaTime), PLAYER_DECEL) *\n          sign(this.velocity.x);\n      }\n\n      this.velocity.y = 0;\n    } else {\n      // Gravity\n      this.inAirFor += deltaTime;\n      if (gridCellWithin === BlockEnum.VENT) {\n        const ventMultiplier = this.velocity.y > 0 ? 0 : 1.1;\n        acceleration.y -= GRAVITY * ventMultiplier;\n      } else {\n        acceleration.y += GRAVITY;\n      }\n    }\n\n    // Coyote jump\n    if (this.inAirFor < COYOTE_TIME && this.wantsToJump) {\n      this.velocity.y = -JUMP_INITIAL_SPEED;\n    }\n\n    this.velocity.add(Vector.scale(acceleration, deltaTime));\n    this.velocity.x = clamp(\n      this.velocity.x,\n      -PLAYER_MAX_SPEED,\n      PLAYER_MAX_SPEED\n    );\n\n    const step = Vector.scale(this.velocity, deltaTime);\n\n    step.x = clamp(step.x, -PLAYER_RADIUS, PLAYER_RADIUS);\n    step.y = clamp(step.y, -PLAYER_RADIUS, PLAYER_RADIUS);\n\n    this.position.add(step);\n\n    this.isColliding = false;\n\n    const { x, y } = this.position;\n\n    // Re-ordered to prioritise collisions with closer blocks first\n    const nearbyBlocks = [\n      getRectAt(x, y),\n      getRectAt(x, y + 1),\n      getRectAt(x, y - 1),\n      getRectAt(x - 1, y),\n      getRectAt(x + 1, y),\n      getRectAt(x - 1, y - 1),\n      getRectAt(x + 1, y - 1),\n      getRectAt(x - 1, y + 1),\n      getRectAt(x + 1, y + 1),\n    ].filter(isDefined);\n\n    this.contactingAnyLedge = false;\n\n    nearbyBlocks.concat(level.objects).forEach(({ type, rect }) => {\n      this.collideWithBlock(type, rect, deltaTime);\n    });\n\n    this.wantsToJump = false;\n    this.isDropping = this.isDropping && this.contactingAnyLedge;\n  }\n\n  /**\n   * Draw the player on the canvas\n   * @param {Canvas} canvas The canvas to draw on\n   */\n  draw(canvas: Canvas) {\n    canvas.setColor(\"yellow\");\n\n    this.collider.draw(canvas);\n  }\n}\n", "import { Vector } from \"../math/Vector\";\nimport { BlockEnum } from \"./BlockTypes\";\nimport { Entity } from \"./entity/Entity\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { Interactible } from \"./interactibles/Interactible\";\n\nimport { Level, Object } from \"./Level\";\nimport { Player } from \"./Player\";\n\nexport class LevelFactory {\n  key: string;\n  iid: string;\n  width: number;\n  height: number;\n  levelGrid: BlockEnum[][];\n  objects: Object[];\n  playerPosition: Vector;\n  exitTriggers: ExitTrigger[];\n  interactibles: Interactible[];\n  entities: Entity[];\n  worldPosition: Vector;\n\n  constructor(key: string, iid: string, width: number, height: number) {\n    this.key = key;\n    this.iid = iid;\n    this.width = width;\n    this.height = height;\n    this.levelGrid = [];\n    this.objects = [];\n    this.playerPosition = new Vector(16, 9);\n    this.exitTriggers = [];\n    this.interactibles = [];\n    this.entities = [];\n\n    this.worldPosition = new Vector(0, 0);\n  }\n\n  addObjects(objects: Object[]) {\n    this.objects = this.objects.concat(objects);\n    return this;\n  }\n\n  addExits(exits: ExitTrigger[]) {\n    this.exitTriggers = this.exitTriggers.concat(exits);\n    return this;\n  }\n\n  addInteractibles(is: Interactible[]) {\n    this.interactibles = this.interactibles.concat(is);\n    return this;\n  }\n\n  addEntities(es: Entity[]) {\n    this.entities = this.entities.concat(es);\n    return this;\n  }\n\n  setPlayerPos(pos: Vector) {\n    this.playerPosition = pos;\n    return this;\n  }\n\n  setLevelGrid(grid: BlockEnum[][]) {\n    this.levelGrid = grid;\n  }\n\n  makeGridSpace() {\n    this.levelGrid = [];\n\n    for (let row = 0; row < this.height; row++) {\n      this.levelGrid.push([]);\n    }\n  }\n\n  setWorldPosition(vec: Vector) {\n    this.worldPosition = vec;\n  }\n\n  setCell(row: number, col: number, blockType: BlockEnum) {\n    this.levelGrid[row][col] = blockType;\n  }\n\n  create() {\n    return new Level(\n      this.key,\n      this.width,\n      this.height,\n      this.levelGrid,\n      this.objects,\n      new Player(this.playerPosition),\n      this.exitTriggers,\n      this.interactibles,\n      this.entities\n    );\n  }\n}\n", "import { PIXELS_PER_TILE } from \"../constants/ScreenConstants\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\n\nimport { DoorInteractible } from \"./interactibles/DoorInteractible\";\nimport { PuzzleInteractible } from \"./interactibles/PuzzleInteractible\";\nimport { SwitchInteractible } from \"./interactibles/SwitchInteractible\";\nimport { TrapdoorInteractible } from \"./interactibles/TrapdoorInteractible\";\nimport { CoverEntity } from \"./entity/CoverEntity\";\n\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { LevelFactory } from \"./LevelFactory\";\nimport { Level } from \"./Level\";\n\nconst LEVEL_DATA_URL = \"./data/world.json\";\n\ninterface EntityRef {\n  entityIid: string;\n}\n\ninterface FieldData {\n  __identifier: string;\n  __value: string | boolean | string[] | EntityRef | EntityRef[];\n}\n\ninterface EntityData {\n  __identifier: string;\n  iid: string;\n  fieldInstances: FieldData[];\n  __grid: [number, number];\n  width: number;\n  height: number;\n}\n\ninterface GridCell {\n  px: [number, number];\n  src: [number, number];\n}\n\ninterface LayerData {\n  __identifier: string;\n  gridTiles: GridCell[];\n  entityInstances: EntityData[];\n}\n\ninterface LevelData {\n  identifier: string;\n  iid: string;\n  pxWid: number;\n  pxHei: number;\n  worldX: number;\n  worldY: number;\n\n  __neighbours: { levelIid: string }[];\n\n  layerInstances: LayerData[];\n}\n\ninterface WorldData {\n  levels: LevelData[];\n}\n\nfunction loadJson(file: string): Promise<WorldData> {\n  return fetch(file).then((data) => data.json());\n}\n\nfunction find<T extends { __identifier: string }>(list: T[], iden: string) {\n  return list.find((item) => item.__identifier === iden);\n}\n\nfunction findIid<T extends { iid: string }>(list: T[], iid: string) {\n  return list.find((item) => item.iid === iid);\n}\n\nfunction findLayer(level: LevelData, key: string) {\n  return find(level.layerInstances, key);\n}\n\nfunction pxToTile(num: number) {\n  return Math.floor(num / PIXELS_PER_TILE);\n}\n\nfunction srcToBlockType(src: [number, number]) {\n  return pxToTile(src[0]) + 1;\n}\n\nfunction getPrereqs(entity: EntityData) {\n  const raw = (find(entity.fieldInstances, \"prerequisites\")?.__value || []) as EntityRef[];\n  return raw.map((ref) => ref.entityIid);\n}\n\nfunction createPuzzle(entity: EntityData) {\n  const id = entity.iid;\n  const key = find(entity.fieldInstances, \"key\")?.__value as string;\n  if (!key) {\n    console.warn(\"Puzzle with no key!\");\n  }\n  const center = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  const config = {\n    isFlipped: find(entity.fieldInstances, \"isFlipped\")?.__value as boolean,\n  };\n  return new PuzzleInteractible(\n    id,\n    center,\n    Rectangle.aroundPoint(center, 2, 2),\n    getPrereqs(entity),\n    key!,\n    config\n  );\n}\n\nfunction createSwitch(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Switch with no key!\");\n  }\n  const center = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  return new SwitchInteractible(\n    id,\n    center,\n    Rectangle.aroundPoint(center, 2, 2),\n    getPrereqs(entity)\n  );\n}\n\nfunction createDoor(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Door with no key!\");\n  }\n  const door = new Vector(entity.__grid[0] + 2, entity.__grid[1] + 2);\n  return new DoorInteractible(id, door, getPrereqs(entity), entity.height / 10);\n}\n\nfunction createTrapdoor(entity: EntityData) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"Trapdoor with no key!\");\n  }\n  const pos = new Vector(...entity.__grid);\n  const config = {\n    isFlipped: find(entity.fieldInstances, \"isFlipped\")?.__value as boolean,\n    hasLedge: find(entity.fieldInstances, \"hasLedge\")?.__value as boolean,\n  };\n  return new TrapdoorInteractible(\n    id,\n    pos,\n    getPrereqs(entity),\n    entity.width / 10,\n    config\n  );\n}\n\nfunction createCoverEntity(entity: EntityData, entities: EntityData[]) {\n  const id = entity.iid;\n  if (!id) {\n    console.warn(\"CoverEntity with no key!\");\n  }\n  const triggerId = (find(entity.fieldInstances, \"triggerArea\")?.__value as EntityRef)\n    .entityIid;\n  const trigger = findIid(entities, triggerId)!;\n  const config = {\n    coverIsTrigger: find(entity.fieldInstances, \"coverIsTrigger\")?.__value as boolean,\n    canReCover: find(entity.fieldInstances, \"canReCover\")?.__value as boolean,\n  };\n  return new CoverEntity(\n    id,\n    Rectangle.widthForm(\n      ...entity.__grid,\n      entity.width / 10,\n      entity.height / 10\n    ),\n    Rectangle.widthForm(\n      ...trigger.__grid,\n      trigger.width / 10,\n      trigger.height / 10\n    ),\n    config\n  );\n}\n\nfunction firstPass(level: LevelData): LevelFactory {\n  const factory = new LevelFactory(\n    level.identifier,\n    level.iid,\n    pxToTile(level.pxWid),\n    pxToTile(level.pxHei)\n  );\n  factory.makeGridSpace();\n  const solidLayer = findLayer(level, \"Solid\")!;\n  for (const cell of solidLayer.gridTiles) {\n    const col = pxToTile(cell.px[0]);\n    const row = pxToTile(cell.px[1]);\n    const blockType = srcToBlockType(cell.src);\n\n    factory.setCell(row, col, blockType);\n  }\n\n  let setStartPos = false;\n  const entityLayer = findLayer(level, \"EntityLayer\")!;\n\n  const entities = entityLayer.entityInstances;\n  entities.forEach((entity) => {\n    switch (entity.__identifier) {\n      case \"Util\":\n        break;\n      case \"PlayerStart\":\n        factory.setPlayerPos(new Vector(entity.__grid[0], entity.__grid[1]));\n        setStartPos = true;\n        break;\n      case \"PuzzleScreen\":\n        factory.addInteractibles([createPuzzle(entity)]);\n        break;\n      case \"Switch\":\n        factory.addInteractibles([createSwitch(entity)]);\n        break;\n      case \"Door\":\n        factory.addInteractibles([createDoor(entity)]);\n        break;\n      case \"Trapdoor\":\n        factory.addInteractibles([createTrapdoor(entity)]);\n        break;\n      case \"CoverEntity\":\n        factory.addEntities([createCoverEntity(entity, entities)]);\n        break;\n      default:\n        console.warn(\"Processing unknown entity type:\", entity.__identifier);\n    }\n  });\n\n  if (!setStartPos) {\n    console.warn(`Level ${level.identifier} is missing a PlayerStart`);\n  }\n\n  factory.setWorldPosition(\n    new Vector(pxToTile(level.worldX), pxToTile(level.worldY))\n  );\n\n  return factory;\n}\n\nfunction secondPass(level: LevelData, others: Record<string, LevelFactory>) {\n  const factory = others[level.iid];\n  for (const neighbourInfo of level.__neighbours) {\n    const nId = neighbourInfo.levelIid;\n    const neighbour = others[nId];\n    const topLeft = Vector.diff(neighbour.worldPosition, factory.worldPosition);\n    const nextCollider = Rectangle.widthForm(\n      topLeft.x,\n      topLeft.y,\n      neighbour.width,\n      neighbour.height\n    );\n    factory.addExits([\n      new ExitTrigger(nextCollider, neighbour.key, nextCollider),\n    ]);\n  }\n\n  return factory.create();\n}\n\nexport class DataLoader {\n  static hasLoaded = false;\n  static data: WorldData | null = null;\n  static levelMap: Record<string, Level> = {};\n\n  static start() {\n    return loadJson(LEVEL_DATA_URL)\n      .then((data) => {\n        DataLoader.data = data;\n\n        const basicMap: Record<string, LevelFactory> = {};\n\n        data.levels.forEach((level) => {\n          const basicData = firstPass(level);\n          basicMap[basicData.iid] = basicData;\n          basicMap[basicData.key] = basicData;\n        });\n\n        data.levels.forEach((rawLevel) => {\n          const level = secondPass(rawLevel, basicMap);\n          DataLoader.levelMap[level.key] = level;\n        });\n      })\n      .then(() => undefined);\n  }\n\n  static getLevel(key: string) {\n    return DataLoader.levelMap[key];\n  }\n}\n", "import { DataLoader } from \"./DataLoader\";\nimport { ExitTrigger } from \"./ExitTrigger\";\nimport { Level } from \"./Level\";\n\n/**\n * Responsible for finding and loading levels, not managing what level is\n * currently active.\n */\nexport class LevelManager {\n  levelMap: Record<string, Level>;\n  currentLevel: Level;\n\n  constructor() {\n    const key = \"Level_0\";\n    this.levelMap = {};\n    this.currentLevel = DataLoader.getLevel(key);\n    this.levelMap[key] = this.currentLevel;\n  }\n\n  getInitialLevel() {\n    return this.currentLevel;\n  }\n\n  getLevel(key: string, previousExit: ExitTrigger) {\n    const nextLevel = this.levelMap[key] || DataLoader.getLevel(key);\n    nextLevel.feedPlayerInfo(this.currentLevel.player, previousExit);\n\n    this.currentLevel = nextLevel;\n    this.levelMap[key] = nextLevel;\n    return nextLevel;\n  }\n}\n", "import { LevelManager } from \"../level/LevelManager\";\nimport { PuzzleManager } from \"../puzzle-manager/PuzzleManager\";\nimport { Puzzle } from \"../puzzle-manager/Puzzle\";\nimport { Level } from \"../level/Level\";\nimport { ExitEvent, LevelEvent, OpenPuzzleEvent } from \"../level/LevelEvent\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { ScreenManager } from \"../ScreenManager\";\n\nexport class PlayMode {\n  levelManager: LevelManager;\n  puzzleManager: typeof PuzzleManager;\n\n  currentPuzzle: Puzzle | undefined;\n  currentLevel?: Level;\n\n  constructor() {\n    this.levelManager = new LevelManager();\n    this.startLevel(this.levelManager.getInitialLevel());\n    this.puzzleManager = PuzzleManager;\n\n    this.currentPuzzle = undefined;\n  }\n\n  startLevel(level: Level) {\n    this.currentLevel = level;\n    level.start(this);\n  }\n\n  onLevelEvent(event: LevelEvent) {\n    if (event.isExitEvent()) {\n      const exitTrigger = (event as ExitEvent).exitTrigger;\n      this.startLevel(this.levelManager.getLevel(exitTrigger.key, exitTrigger));\n    } else if (event.isOpenPuzzleEvent()) {\n      this.currentPuzzle = this.puzzleManager.getPuzzle((event as OpenPuzzleEvent).puzzleId);\n      this.currentPuzzle.open();\n    } else if (event.isClosePuzzleEvent()) {\n      this.currentPuzzle?.close();\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {object} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentLevel?.update(deltaTime, inputState);\n    this.currentPuzzle?.update(deltaTime, inputState);\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.currentLevel?.onInput(input);\n    this.currentPuzzle?.onInput(input);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager) {\n    this.currentLevel?.draw(screenManager);\n    this.currentPuzzle?.draw(screenManager);\n  }\n}\n", "import { PlayMode } from \"./game-modes/PlayMode\";\nimport { InputEvent, InputState } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\ntype Mode = PlayMode;\n\nexport class GameModeManager {\n  playMode: PlayMode;\n\n  currentMode: Mode;\n\n  constructor() {\n    this.playMode = new PlayMode();\n\n    // Probably needs to initially be a menu mode eventually, or some dev-mode tooling\n    this.currentMode = this.playMode;\n  }\n\n  /**\n   * Update the current gamemode.\n   * @param {number} deltaTime The time that has elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentMode.update(deltaTime, inputState);\n  }\n\n  /**\n   * Process an input event\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.currentMode.onInput(input);\n  }\n\n  /**\n   * Draw the current gamemode.\n   * @param {ScreenManager} screenManager The screenManager object.\n   */\n  draw(screenManager: ScreenManager) {\n    this.currentMode.draw(screenManager);\n  }\n}\n", "const HEX = 16;\nconst ZERO = \"0\";\n\n/**\n * A function to convert a number to a zero-padded hex string.\n * @param {number} number The number to be converted\n * @param {number} digits The expected length (for zero-padding purposes)\n */\nexport const toHex = (number: number, digits: number) => {\n  return number.toString(HEX).padStart(digits, ZERO);\n};\n", "import { toHex } from \"./utils/Color\";\n\nconst CTX = Symbol(\"ctx\");\nconst CANVAS = Symbol(\"canvas\");\n\nexport class Canvas {\n  [CANVAS]: HTMLCanvasElement;\n  [CTX]: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this[CANVAS] = canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      throw Error(\"Unable to get 2d context\");\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    this[CTX] = ctx;\n\n    this[CTX].fillStyle = \"black\";\n    this[CTX].strokeStyle = \"black\";\n\n    this.width = this[CANVAS].width;\n    this.height = this[CANVAS].height;\n  }\n\n  /**\n   * Fill a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  fillRect(x: number, y: number, width: number, height: number) {\n    this[CTX].fillRect(x, y, width, height);\n  }\n\n  clear() {\n    this[CTX].clearRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Draw the outline of a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  strokeRect(x: number, y: number, width: number, height: number) {\n    this[CTX].strokeRect(x, y, width, height);\n  }\n\n  strokeRectInset(x: number, y: number, width: number, height: number, inset: number) {\n    this.strokeRect(\n      x + inset,\n      y + inset,\n      width - inset * 2,\n      height - inset * 2\n    );\n  }\n\n  /**\n   * Fill an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  fillEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].fill();\n  }\n\n  /**\n   * Outline an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  strokeEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Draw a line on the canvas.\n   * @param {number} x0 The start x position\n   * @param {number} y0 The start y position\n   * @param {number} x1 The end x position\n   * @param {number} y1 The start y position\n   */\n  drawLine(x0: number, y0: number, x1: number, y1: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].lineTo(x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Draw a quadratic bezier curve on the canvas.\n   * @param {*} x0 The starting x position\n   * @param {*} y0 The starting y position\n   * @param {*} x1 The ending x position\n   * @param {*} y1 The ending y position\n   * @param {*} xControl The control point x position\n   * @param {*} yControl The control point y position\n   */\n  drawQuadratic(x0: number, y0: number, x1: number, y1: number, xControl: number, yControl: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].quadraticCurveTo(xControl, yControl, x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Scale the canvas.\n   * @param {number} xScale\n   * @param {number} yScale\n   */\n  scale(xScale: number, yScale: number) {\n    this[CTX].scale(xScale, yScale);\n  }\n\n  /**\n   * Translate the canvas.\n   * @param {number} xOffset\n   * @param {number} yOffset\n   */\n  translate(xOffset: number, yOffset: number) {\n    this[CTX].translate(xOffset, yOffset);\n  }\n\n  /**\n   * Set the colour to be used for drawing on the canvas.\n   * @param {string} colorString The name of the color to be used\n   */\n  setColor(colorString: string) {\n    if (colorString === this[CTX].fillStyle) {\n      return;\n    }\n\n    this[CTX].fillStyle = colorString;\n    this[CTX].strokeStyle = colorString;\n  }\n\n  setLineWidth(width: number) {\n    this[CTX].lineWidth = width;\n  }\n\n  get lineWidth() {\n    return this[CTX].lineWidth;\n  }\n\n  setLineDash(pattern: number[]) {\n    this[CTX].setLineDash(pattern);\n  }\n\n  /**\n   * Set the current color via RGB.\n   * @param {number} red Red value from 0-255\n   * @param {number} green Green value from 0-255\n   * @param {number} blue Blue value from 0-255\n   * @param {number | undefined} alpha Alpha value from 0-255\n   */\n  setColorRGB(red: number, green: number, blue: number, alpha = 255) {\n    const colorString = `#${toHex(red, 2)}${toHex(green, 2)}${toHex(\n      blue,\n      2\n    )}${toHex(alpha, 2)}`;\n\n    this.setColor(colorString);\n  }\n\n  /**\n   * Set the current color with hue, saturation, lightness and alpha.\n   * @param {number} hue Hue value from 0-359\n   * @param {number} saturation Saturation value from 0-1\n   * @param {number} lightness Lightness value from 0-1\n   * @param {number | undefined} alpha Alpha value from 0-1\n   */\n  setColorHSLA(hue: number, saturation: number, lightness: number, alpha = 1) {\n    const colorString = `hsla(${hue},${Math.floor(\n      saturation * 100\n    )}%,${Math.floor(lightness * 100)}%,${alpha})`;\n\n    this.setColor(colorString);\n  }\n\n  saveTransform() {\n    this[CTX].save();\n  }\n\n  restoreTransform() {\n    this[CTX].restore();\n  }\n\n  /**\n   * Draw another image to this canvas\n   * @param {Canvas} imageSource\n   * @param {number} sourceX\n   * @param {number} sourceY\n   * @param {number} sourceWidth\n   * @param {number} sourceHeight\n   * @param {number} destinationX\n   * @param {number} destinationY\n   * @param {number} destinationWidth\n   * @param {nubmer} destinationHeight\n   */\n  drawImage(\n    imageSource: Canvas | HTMLImageElement,\n    sourceX: number,\n    sourceY: number,\n    sourceWidth: number,\n    sourceHeight: number,\n    destinationX: number,\n    destinationY: number,\n    destinationWidth: number,\n    destinationHeight: number\n  ) {\n    let image: CanvasImageSource;\n    if (imageSource instanceof Canvas) {\n      image = imageSource[CANVAS];\n    } else if (imageSource instanceof Image) {\n      if (!imageSource.complete) {\n        return;\n      }\n      image = imageSource;\n    } else {\n      throw Error(\"Drawing something unmanageable\");\n    }\n\n    this[CTX].drawImage(\n      image,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destinationX,\n      destinationY,\n      destinationWidth,\n      destinationHeight\n    );\n  }\n\n  /**\n   * Create a Canvas from an id.\n   * @param {string} id The id attribute of the HTMLCanvasElement\n   */\n  static fromId(id: string) {\n    const canvas = document.getElementById(id);\n\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Could not find canvas with id: \"${id}\"`);\n    }\n\n    return new Canvas(canvas);\n  }\n\n  /**\n   * Create a new HTMLCanvasElement and use that as the basis for a Canvas.\n   */\n  static fromScratch(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n\n    return new Canvas(canvas);\n  }\n}\n", "import {\n  CANVAS_HEIGHT,\n  CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_HEIGHT,\n  ON_SCREEN_CANVAS_WIDTH,\n  UI_CANVAS_HEIGHT,\n  UI_CANVAS_WIDTH,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nimport { Canvas } from \"./Canvas\";\n\nconst REAL_CANVAS = Symbol(\"real-canvas\");\n\nfunction getRawCanvas(): HTMLCanvasElement {\n  const rawCanvas = document.getElementById(\"canvas\");\n\n  if (!(rawCanvas instanceof HTMLCanvasElement)) {\n    throw new Error(\"Could not find canvas\");\n  }\n\n  rawCanvas.width = ON_SCREEN_CANVAS_WIDTH;\n  rawCanvas.height = ON_SCREEN_CANVAS_HEIGHT;\n\n  return rawCanvas;\n}\n\nexport class ScreenManager {\n  [REAL_CANVAS]: Canvas;\n  background: Canvas;\n  behindGroundCanvas: Canvas;\n  staticWorldCanvas: Canvas;\n  dynamicWorldCanvas: Canvas;\n  uiCanvas: Canvas;\n  camera: Vector;\n\n  constructor() {\n    const screenCanvas = new Canvas(getRawCanvas());\n\n    if (!(screenCanvas instanceof Canvas)) {\n      throw Error(\"No canvas found!\");\n    }\n\n    this[REAL_CANVAS] = screenCanvas;\n\n    this.background = Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 3);\n    this.behindGroundCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 3\n    );\n    this.staticWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 3\n    );\n    this.dynamicWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 3\n    );\n    this.uiCanvas = Canvas.fromScratch(\n      ON_SCREEN_CANVAS_WIDTH,\n      ON_SCREEN_CANVAS_HEIGHT\n    );\n\n    // Stores the top-left position of the camera\n    this.camera = new Vector(0, 0);\n  }\n\n  setCamera(cameraPosition: Vector) {\n    this.camera = cameraPosition;\n  }\n\n  drawToScreen() {\n    this[REAL_CANVAS].drawImage(\n      this.background,\n      this.camera.x,\n      this.camera.y,\n      CANVAS_WIDTH,\n      CANVAS_HEIGHT,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n    this[REAL_CANVAS].drawImage(\n      this.behindGroundCanvas,\n      this.camera.x,\n      this.camera.y,\n      CANVAS_WIDTH,\n      CANVAS_HEIGHT,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n    this[REAL_CANVAS].drawImage(\n      this.staticWorldCanvas,\n      this.camera.x,\n      this.camera.y,\n      CANVAS_WIDTH,\n      CANVAS_HEIGHT,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n    this[REAL_CANVAS].drawImage(\n      this.dynamicWorldCanvas,\n      this.camera.x,\n      this.camera.y,\n      CANVAS_WIDTH,\n      CANVAS_HEIGHT,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n    this[REAL_CANVAS].drawImage(\n      this.uiCanvas,\n      0,\n      0,\n      UI_CANVAS_WIDTH,\n      UI_CANVAS_HEIGHT,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n  }\n\n  static instance = null;\n  static getInstance() {\n    if (this.instance) {\n      return this.instance;\n    }\n\n    return new ScreenManager();\n  }\n}\n", "import { IS_MOBILE } from \"./constants/ScreenConstants\";\nimport { DataLoader } from \"./level/DataLoader\";\n\nimport { GameModeManager } from \"./GameModeManager\";\nimport { InputEvent, InputManager } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\nconst MAX_FRAME_TIME = 1 / 20;\n\n/**\n * The head owner of everything.\n */\nclass App {\n  screenManager: ScreenManager;\n  gameModeManager: GameModeManager;\n  inputManager: InputManager;\n\n  lastFrameTime: number;\n\n  constructor() {\n    this.screenManager = ScreenManager.getInstance();\n    this.gameModeManager = new GameModeManager();\n    this.inputManager = new InputManager((input) => this.onInput(input));\n\n    this.lastFrameTime = performance.now();\n  }\n\n  start() {\n    this.inputManager.init();\n    this.lastFrameTime = performance.now();\n    requestAnimationFrame(() => this.mainLoop());\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.gameModeManager.onInput(input);\n  }\n\n  mainLoop() {\n    const now = performance.now();\n    const deltaTime = Math.min(\n      (now - this.lastFrameTime) / 1000,\n      MAX_FRAME_TIME\n    );\n    // Do stuff\n    this.gameModeManager.update(deltaTime, this.inputManager.getInputState());\n    this.gameModeManager.draw(this.screenManager);\n    this.screenManager.drawToScreen();\n\n    // Loop\n    requestAnimationFrame(() => this.mainLoop());\n    this.lastFrameTime = now;\n  }\n}\n\nfunction findById(id: string) {\n  const element = document.getElementById(id);\n\n  if (!element) {\n    console.warn(`Can't find element with id: ${id}`);\n  }\n\n  return element;\n}\n\n/**\n * The function used to kick off the whole app.\n */\nconst main = () => {\n  const loading = DataLoader.start();\n\n  loading.then(() => {\n    const app = new App();\n\n    app.start();\n\n    (window as any).app = app;\n  });\n\n  if (!IS_MOBILE && !location.href.includes(\"localhost\")) {\n    Array.from(document.getElementsByTagName(\"p\")).forEach((tag) =>\n      tag.classList.add(\"visible\")\n    );\n  }\n  if (!IS_MOBILE) {\n    findById(\"mobile-controls\")?.remove();\n  }\n  if (IS_MOBILE) {\n    findById(\"canvas\")?.classList.add(\"fit-screen\");\n    findById(\"mobile-controls\")?.classList.remove(\"hidden\");\n  }\n};\n\nwindow.onload = () => {\n  main();\n};\n"],
  "mappings": "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",
  "names": ["IS_MOBILE", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "UI_CANVAS_WIDTH", "UI_CANVAS_HEIGHT", "UI_PIXEL_WIDTH", "clamp", "x", "low", "high", "sign", "Vector", "x", "y", "vector", "factor", "a", "b", "xDiff", "yDiff", "v1", "v2", "t", "Circle", "position", "radius", "otherCircle", "radiusSum", "Vector", "point", "rectangle", "closestX", "clamp", "closestY", "canvas", "Rectangle", "x1", "y1", "x2", "y2", "otherRectangle", "circle", "p0", "pToCenter", "distFromCenter", "circleDistToMyCenter", "horizontalDistance", "verticalDistance", "sign", "inset", "insetBy", "x", "y", "width", "height", "halfWidth", "halfHeight", "TileImage", "EntityImage", "BlockType", "blockType", "Entity", "id", "_level", "_player", "_deltaTime", "_screenManager", "AREA_DEBUG", "Interactible", "Entity", "id", "position", "triggerArea", "prerequisites", "level", "player", "_deltaTime", "_level", "_a", "i", "screenManager", "canvas", "prereq", "xDiff", "Vector", "mid", "control", "OPEN_CLOSE_SPEED", "DoorInteractible", "Interactible", "id", "position", "prerequisites", "height", "Vector", "Rectangle", "level", "player", "deltaTime", "motion", "clamp", "screenManager", "canvas", "h", "EntityImage", "OPEN_DURATION", "CLOSE_DURATION", "PUZZLE_WINDOW_WIDTH", "UI_CANVAS_HEIGHT", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "N_CIRCLE_LAYOUT", "Circle", "Vector", "N_SQUARE_LAYOUT", "Rectangle", "CACHE", "cacheKey", "rows", "cols", "produceObject", "LARGER_DIR", "WIDE_EDGE", "NARROW_EDGE", "CELL_SIZE", "PUZZLE_WINDOW_WIDTH", "NARROW_SIZE", "WIDE_SIZE", "FULL_HEIGHT", "FULL_WIDTH", "TOP_EDGE", "LEFT_EDGE", "xSpacing", "lastX", "i", "ySpacing", "lastY", "matrix", "y1", "y2", "thisRow", "x1", "x2", "Rectangle", "getObject", "key", "positionGetter", "row", "col", "PARTIAL_RADIUS", "Puzzle", "id", "rows", "columns", "validator", "positionGetter", "row", "currentRow", "col", "UI_PIXEL_WIDTH", "pos", "slideInOffset", "Vector", "UI_CANVAS_HEIGHT", "puzzleScreenOffset", "UI_CANVAS_WIDTH", "PUZZLE_WINDOW_WIDTH", "screenManager", "canvas", "offset", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "element", "cellState", "mid", "deltaTime", "inputState", "OPEN_DURATION", "CLOSE_DURATION", "clamp", "position", "input", "anyChange", "click", "clickPosition", "currentState", "nextState", "PuzzleValidator", "validationItems", "state", "item", "canvas", "args", "ValidationItem", "_state", "_canvas", "_args", "CellValidation", "ValidationItem", "row", "column", "ForcedCellValidation", "mustBeOn", "state", "cell", "canvas", "positionGetter", "rect", "width", "center", "Vector", "CountInAreaValidation", "desiredCount", "col", "count", "SOLVED_BACKGROUND", "circle", "N_CIRCLE_LAYOUT", "position", "rotRight", "vector", "Vector", "EdgeValidationItem", "ValidationItem", "isRow", "index", "state", "row", "_canvas", "_center", "_scaleBy", "_isSideways", "canvas", "positionGetter", "cell", "EdgeCountValidationItem", "count", "soFar", "item", "center", "scaleBy", "isSideways", "transformCircle", "circle", "Circle", "v", "N_CIRCLE_LAYOUT", "position", "EdgeGroupsValidationItem", "numGroups", "inGroup", "width", "moveCenter", "pos", "square", "N_SQUARE_LAYOUT", "EdgeBlankGroupsValidationItem", "EdgeNoTripleValidationItem", "value", "center2", "center3", "radius", "PuzzleValidatorFactory", "row", "column", "mustBeOn", "ForcedCellValidation", "count", "CountInAreaValidation", "nums", "isRow", "ValidationItemType", "EdgeCountValidationItem", "num", "index", "EdgeGroupsValidationItem", "EdgeBlankGroupsValidationItem", "yeses", "bool", "EdgeNoTripleValidationItem", "PuzzleValidator", "initPuzzle", "id", "options", "rows", "cols", "rules", "PuzzleValidatorFactory", "cell", "Puzzle", "RULES", "makePuzzle", "id", "initPuzzle", "PuzzleManagerInstance", "puzzle", "PuzzleManager", "LevelEvent", "ExitEvent", "exitTrigger", "OpenPuzzleEvent", "puzzleId", "ClosePuzzleEvent", "PuzzleInteractible", "Interactible", "id", "position", "area", "prereqs", "puzzleId", "config", "PuzzleManager", "Vector", "screenManager", "canvas", "SCREEN_W", "PIXEL_SCALE", "isFlippedMul", "SOLVED_BACKGROUND", "DEFAULT_BACKGROUND", "offset", "rows", "SCREEN_PIXEL", "SCR_WIDTH", "SCR_HEIGHT", "TOP_PAD", "LEFT_PAD", "row", "col", "OpenPuzzleEvent", "SwitchInteractible", "Interactible", "id", "position", "area", "prerequisites", "player", "deltaTime", "level", "screenManager", "canvas", "PIXEL_SCALE", "EntityImage", "OPEN_CLOSE_DUR", "TrapdoorInteractible", "Interactible", "id", "position", "prerequisites", "width", "config", "Vector", "Rectangle", "level", "player", "deltaTime", "motion", "clamp", "screenManager", "canvas", "x", "TileImage", "w", "EntityImage", "UNCOVER_DURATION", "CoverEntity", "Entity", "id", "coverArea", "triggerArea", "config", "player", "level", "deltaTime", "isOpen", "clamp", "screenManager", "canvas", "ExitTrigger", "collider", "key", "nextLevelCollider", "player", "Vector", "Up", "Down", "Left", "Right", "Jump", "Interact", "Escape", "Input", "KEY_MAP", "Input", "InputState", "keyMap", "mousePosition", "input", "Vector", "InputEvent", "_key", "KeyPressEvent", "key", "ClickEvent", "position", "isRightClick", "InputManager", "listener", "onKeyEvent", "symbol", "e", "event", "wireButton", "id", "btn", "UI_CANVAS_WIDTH", "ON_SCREEN_CANVAS_WIDTH", "SCALE_FACTOR", "Level", "key", "width", "height", "levelGrid", "objects", "player", "exitTriggers", "interactibles", "entities", "playModeManager", "i", "object", "rect", "event", "previousPlayer", "previousExit", "position", "deltaTime", "inputState", "_a", "InputState", "interactible", "entity", "ClosePuzzleEvent", "input", "Input", "relevant", "OpenPuzzleEvent", "triggeredExit", "trigger", "ExitEvent", "camera", "clampedToPlayer", "Vector", "clamp", "canvas", "action", "screenManager", "row", "col", "blockType", "TileImage", "RectPoolClass", "row", "col", "isShort", "grid", "Rectangle", "RectPool", "PLAYER_RADIUS", "PLAYER_MAX_SPEED", "PLAYER_ACCEL", "PLAYER_DECEL", "TURN_SPEED", "JUMP_HEIGHT", "JUMP_DURATION", "PARAM_A", "JUMP_INITIAL_SPEED", "GRAVITY", "COYOTE_TIME", "isDefined", "value", "Player", "position", "Circle", "Vector", "input", "Input", "type", "rect", "deltaTime", "isActiveLedge", "intersects", "BlockType", "collidingBy", "inputState", "level", "getCellAt", "x", "y", "_a", "getRectAt", "RectPool", "inputX", "acceleration", "playerBottom", "cellBelow", "groundingCellBelow", "gridCellWithin", "groundedOnGridCell", "sign", "ventMultiplier", "clamp", "step", "nearbyBlocks", "canvas", "LevelFactory", "key", "iid", "width", "height", "Vector", "objects", "exits", "is", "es", "pos", "grid", "row", "vec", "col", "blockType", "Level", "Player", "LEVEL_DATA_URL", "loadJson", "file", "data", "find", "list", "iden", "item", "findIid", "iid", "findLayer", "level", "key", "pxToTile", "num", "srcToBlockType", "src", "getPrereqs", "entity", "_a", "ref", "createPuzzle", "_b", "id", "center", "Vector", "config", "PuzzleInteractible", "Rectangle", "createSwitch", "SwitchInteractible", "createDoor", "door", "DoorInteractible", "createTrapdoor", "pos", "TrapdoorInteractible", "createCoverEntity", "entities", "_c", "triggerId", "trigger", "CoverEntity", "firstPass", "factory", "LevelFactory", "solidLayer", "cell", "col", "row", "blockType", "setStartPos", "secondPass", "others", "neighbourInfo", "nId", "neighbour", "topLeft", "nextCollider", "ExitTrigger", "_DataLoader", "basicMap", "basicData", "rawLevel", "DataLoader", "LevelManager", "key", "DataLoader", "previousExit", "nextLevel", "PlayMode", "LevelManager", "PuzzleManager", "level", "event", "_a", "exitTrigger", "deltaTime", "inputState", "_b", "input", "screenManager", "GameModeManager", "PlayMode", "deltaTime", "inputState", "input", "screenManager", "ZERO", "toHex", "number", "digits", "CTX", "CANVAS", "_Canvas", "canvas", "ctx", "x", "y", "width", "height", "inset", "x0", "y0", "x1", "y1", "xControl", "yControl", "xScale", "yScale", "xOffset", "yOffset", "colorString", "pattern", "red", "green", "blue", "alpha", "toHex", "hue", "saturation", "lightness", "imageSource", "sourceX", "sourceY", "sourceWidth", "sourceHeight", "destinationX", "destinationY", "destinationWidth", "destinationHeight", "image", "id", "Canvas", "REAL_CANVAS", "getRawCanvas", "rawCanvas", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "_ScreenManager", "screenCanvas", "Canvas", "Vector", "cameraPosition", "UI_CANVAS_WIDTH", "UI_CANVAS_HEIGHT", "ScreenManager", "MAX_FRAME_TIME", "App", "ScreenManager", "GameModeManager", "InputManager", "input", "now", "deltaTime", "findById", "id", "element", "main", "_a", "_b", "_c", "DataLoader", "app", "IS_MOBILE", "tag"]
}
